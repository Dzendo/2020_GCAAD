DevByte - Starter Code - Стартовый Код
======================

Проблемы:

0. implementation 'com.google.android.material:material:1.0.0'
При выставлении 1.1.0 вылет на старте при высветке recyclerview полей

1. API 'BaseVariant.getApplicationIdTextResource' is obsolete and has been replaced with 'VariantProperties.applicationId'.

2. build/tmp/kapt3/stubs/debug/com/example/android/devbyteviewerw/database/VideosDatabase.java
public abstract class VideosDatabase extends androidx.room.RoomDatabase {
Schema export directory is not provided to the annotation processor so we cannot export the schema.
You can either provide `room.schemaLocation` annotation processor argument OR set exportSchema to false.
Каталог экспорта схемы не предоставляется обработчику аннотаций, поэтому мы не можем экспортировать схему.
Вы можете либо предоставить `комнату.аргумент обработчика аннотаций schemaLocation или задайте экспорт схемы в false.
 @Database(entities = { YourEntity.class }, version = 1, exportSchema = false)

3. maven { url "https://kotlin.bintray.com/kotlinx/" }  -- вроде не нужен

           binary-compatibility-validator/
           kotlinx-knit/
           kotlinx/
           org/
4. /*javaCompileOptions {   Вроде не нужен ???
               annotationProcessorOptions {
                   //[WARN] Incremental annotation processing requested,
                   // but support is disabled because the following processors are not incremental:
                   // androidx.room.RoomProcessor (DYNAMIC).
                   arguments = ["room.incremental" : "true"]
               }
           }*/
5. implementation "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"  // AS иначе:
> Task :app:kaptGenerateStubsDebugKotlin
w: Runtime JAR files in the classpath should have the same version. These files were found in the classpath:
    N:/_AndroidGradle/caches/transforms-2/files-2.1/9b396b39444539f3e0d3b09b937acd61/jetified-kotlin-stdlib-jdk7-1.4-M1.jar (version 1.4)
    N:/_AndroidGradle/caches/transforms-2/files-2.1/139d3cc4a91960f2937564ae66b53906/jetified-kotlin-reflect-1.3.50.jar (version 1.3)
    N:/_AndroidGradle/caches/transforms-2/files-2.1/b47d3d6cf7ee1e281f3292024641e4ee/jetified-kotlin-stdlib-1.4-M1.jar (version 1.4)
    N:/_AndroidGradle/caches/transforms-2/files-2.1/a242c8a44449feb23b4c69410baa74b1/jetified-kotlin-stdlib-common-1.4-M1.jar (version 1.4)
w: Some runtime JAR files in the classpath have an incompatible version. Consider removing them from the classpath
> Task :app:compileDebugKotlin
w: Runtime JAR files in the classpath should have the same version. These files were found in the classpath:
    N:/_AndroidGradle/caches/transforms-2/files-2.1/9b396b39444539f3e0d3b09b937acd61/jetified-kotlin-stdlib-jdk7-1.4-M1.jar (version 1.4)
    N:/_AndroidGradle/caches/transforms-2/files-2.1/139d3cc4a91960f2937564ae66b53906/jetified-kotlin-reflect-1.3.50.jar (version 1.3)
    N:/_AndroidGradle/caches/transforms-2/files-2.1/b47d3d6cf7ee1e281f3292024641e4ee/jetified-kotlin-stdlib-1.4-M1.jar (version 1.4)
    N:/_AndroidGradle/caches/transforms-2/files-2.1/a242c8a44449feb23b4c69410baa74b1/jetified-kotlin-stdlib-common-1.4-M1.jar (version 1.4)
w: Some runtime JAR files in the classpath have an incompatible version. Consider removing them from the classpath

6. избавление от android.arch navigation and work  в androidx
def work_version = "2.3.4"
    //implementation "android.arch.work:work-runtime-ktx:$work_version"
    implementation "androidx.work:work-runtime-ktx:$work_version"
app/src/main/java/com/example/android/devbyteviewerw/DevByteApplication.kt
'getInstance(): WorkManager' is deprecated. Deprecated in Java
WorkManager.getInstance(applicationContext).enqueueUniquePeriodicWork(



Use as starter code for the Repository codelab.
Используйте в качестве стартового кода для репозитория codelab.

Introduction - Вступление
------------

DevByteViewer app displays a list of DevByte videos. DevByte videos are short
videos made by the Google Android developer relations team to introduce new
developer features on Android. They're also a great way to stay up to date with
new features as they come out as well as tips and best practices. This app
fetches the DevByte video list from the network using the Retrofit library and
displays it on the screen. It uses a ViewModel and LiveData to hold the data and
update the UI. Since the video list is big, results are displayed in a
RecyclerView.

Приложение Dev Byte Viewer отображает список видео Devbytes. Devbytes видео короткие
видео, сделанные командой разработчиков Google Android relations, чтобы представить новые
особенности разработчика на Android. Они также отличный способ оставаться в курсе событий
новые функции по мере их появления, а также советы и лучшие практики. Это приложение
извлекает список видео Devbytes из сети с помощью библиотеки Retrofit и
выводит его на экран. Он использует ViewModel и Live Data для хранения данных и
обновите пользовательский интерфейс. Поскольку список видео большой, результаты отображаются в виде
RecyclerView.


Pre-requisites - Предварительные условия
--------------

You need to know:
- How to open, build, and run Android apps with Android Studio.
- How to use the Navigation Architecture Component
- Passing the data between navigation destinations.
- Read the logs using the Logcat.
- Android architecture components: ViewModel and LiveData.
- How to use Retrofit network library.

Тебе нужно знать:
- Как открывать, создавать и запускать приложения для Android с помощью Android Studio.
- Как использовать компонент архитектуры навигации
- Передача данных между навигационными пунктами назначения.
- Чтение журналов с помощью Logcat.
- - Компоненты архитектуры Android: ViewModel и Live Data.
- Использование модифицированной сетевой библиотеки.


Getting Started  - приступая к работе
---------------

1. Download and run the app.
2. You need Android Studio 3.2 or higher to build this project.
1. Загрузите и запустите приложение.
2. Для создания этого проекта вам понадобится Android Studio 3.2 или выше.

License
-------

Copyright 2019 Google, Inc.

Licensed to the Apache Software Foundation (ASF) under one or more contributor
license agreements.  See the NOTICE file distributed with this work for
additional information regarding copyright ownership.  The ASF licenses this
file to you under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License.  You may obtain a copy of
the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
License for the specific language governing permissions and limitations under
the License.

Это стартовое приложение поставляется с большим количеством кода,
в частности со всеми сетевыми модулями и модулями пользовательского интерфейса,
так что вы можете сосредоточиться на модуле репозитория приложения.

Совет.
Рекомендуется разделять объекты сети, домена и базы данных.
Эта стратегия следует принципу разделения интересов.
Если сетевой ответ или схема базы данных изменятся,
вы захотите иметь возможность изменять компоненты приложения
и управлять ими без обновления всего кода приложения.

Давайте уделим время обзору. Наше приложение будет иметь три типа объектов данных.*****************

1. Первыми являются доменные объекты , хранящиеся в domain пакете.
Исследуйте domain пакет.
Этот пакет содержит data классы для представления данных приложения.
Например, DevByteVideo класс данных в domain/Models.kt классе представляет одно видео DevByte.

2. Второй - это объекты передачи данных для сети, хранящиеся в network пакете.
Исследуйте network пакет.
Класс network/DataTransferObjects.kt содержит класс данных для объекта передачи данных  data transfer object  называется NetworkVideo.
Объект передачи данных используется для анализа результата сети.
Этот файл также содержит удобный метод asDomainModel() для преобразования сетевых результатов в список объектов домена.
Объекты передачи данных отличаются от объектов домена,
потому что они содержат дополнительную логику для анализа сетевых результатов.

Архитектура остальных приложений аналогична другим приложениям, использовавшимся в предыдущих кодах:

Служба Retrofit network/Service.kt, извлекает devbytes список воспроизведения из сети.

DevByteViewModelСодержит данные приложения , как LiveData объекты.

Контроллер пользовательского интерфейса DevByteFragment
содержит элемент RecyclerView для отображения списка видео и наблюдателей для LiveData объектов.

Давайте взглянем на сущности, которые мы предоставили для вас в вашем проекте в Android Studio:
- network/DataTransferObjects.kt
- класс NetworkVideoContainer
- класс NetworkVideo
- domain/Models.kt
- класс Video

-Data Transfer Object
Объекты передачи данных отвечают за анализ и представление значений в сети,
в то время как объекты домена являются основным представлением данных для нашего приложения.
-Domain Object

Делая эти объекты отдельными классами, мы создаем то, что называется «разделением интересов».
 Объект базы данных касается только вещей в базе данных,
 в то время как объекты передачи данных касаются только вещей в сети.



3. Третий тип объекта - это объект базы данных.
 Они отличаются от объектов передачи данных и объектов домена,
 потому что они полностью предназначены для взаимодействия с базой данных.

fun NetworkVideoContainer.asDomainModel(): List<Video> =
fun List<DatabaseVideo>.asDomainModel(): List<Video> =
fun NetworkVideoContainer.asDatabaseModel(): Array<DatabaseVideo> = преобразует объекты базы данных в объекты домена:
fun NetworkVideoContainer.asDatabaseModel(): List<DatabaseVideo> =

4. Концепция: кеширование **************************************************************************
После того, как приложение извлекает данные из сети, оно может кэшировать данные, сохраняя данные в хранилище устройства.
Вы кешируете данные, чтобы иметь к ним доступ позже, когда устройство находится в автономном режиме,
или если вы хотите снова получить доступ к тем же данным.

В следующей таблице показано несколько способов реализации сетевого кэширования в Android.
В этой кодовой метке вы используете Room,
потому что это рекомендуемый способ хранения структурированных данных в файловой системе устройства.

Техника кеширования 1
Retrofit сетевая библиотека, используемая для реализации безопасного с точки зрения типов клиента REST для Android
Вы можете настроить Retrofit для локального хранения копии каждого сетевого результата.
Пользы Хорошее решение для простых запросов и ответов, нечастых сетевых вызовов или небольших наборов данных.

Техника кеширования 2
Вы можете использовать SharedPreferences для хранения пар ключ-значение.
Пользы Хорошее решение для небольшого количества ключей и простых значений.
Вы не можете использовать эту технику для хранения больших объемов структурированных данных.

Техника кеширования 3
Вы можете получить доступ к каталогу внутренней памяти приложения и сохранить в нем файлы данных.
Имя пакета вашего приложения указывает на внутренний каталог хранилища приложения,
который находится в специальном месте в файловой системе Android.
Этот каталог является частным для вашего приложения, и он очищается при удалении вашего приложения.
Пользы
Хорошее решение, если у вас есть конкретные потребности, которые может решить файловая система, например,
если вам нужно сохранить мультимедийные файлы или файлы данных и вам нужно управлять файлами самостоятельно.
Вы не можете использовать эту технику для хранения сложных и структурированных данных.

Техника кеширования 4 Main
Вы можете кэшировать данные с помощью Room библиотеки объектов сопоставления SQLite,
которая обеспечивает уровень абстракции поверх SQLite.
Польза:
Рекомендуемое решение для сложных и структурированных данных,
поскольку лучший способ хранения структурированных данных в файловой системе устройства
- это локальная база данных SQLite.

5. Задача: добавить автономный кеш *****************************************************************
В этой задаче вы добавляете Room базу данных в свое приложение
для использования в качестве автономного кэша.
Ключевая концепция: не извлекайте данные из сети при каждом запуске приложения.
Вместо этого отобразите данные, которые вы выбираете из базы данных.
Этот метод уменьшает время загрузки приложения.
Когда приложение извлекает данные из сети,
сохраняйте данные в базе данных вместо немедленного их отображения.
При получении нового сетевого результата обновите локальную базу данных
и отобразите новый контент на экране из локальной базы данных.
Этот метод гарантирует, что автономный кеш всегда актуален.
Кроме того, если устройство находится в автономном режиме,
ваше приложение все еще может загружать локально кэшированные данные.

6. Концепция: хранилища ****************************************************************************
Шаблон хранилища
Шаблон репозитория является шаблоном , который изолирует источники данных от остальной части приложения.
А хранилище посредничает между источниками данных
(например, постоянных моделей, веб - сервисов и кэшей)
и остальной части приложения.
На диаграмме ниже показано, как компоненты приложения,
такие как используемые действия, LiveData
могут взаимодействовать с источниками данных посредством репозитория.

Для реализации хранилища вы используете класс хранилища,
такой как VideosRepository класс, который вы создадите в следующей задаче.
Класс репозитория изолирует источники данных от остальной части приложения
и предоставляет чистый API для доступа к данным для остальной части приложения.
Использование класса репозитория является рекомендуемым лучшим методом для разделения кода и архитектуры.

Преимущества использования репозитория
Модуль репозитория обрабатывает операции с данными и позволяет использовать несколько бэкэндов.
В типичном реальном приложении в хранилище реализована логика для принятия решения о том,
получать ли данные из сети или использовать результаты, которые кэшируются в локальной базе данных.
Это помогает сделать ваш код модульным и тестируемым.
Вы можете легко смоделировать хранилище и протестировать остальную часть кода.

7. Задача: создать хранилище ***********************************************************************
В этой задаче вы создаете репозиторий для управления автономным кэшем, который вы реализовали в предыдущей задаче.
Ваша Room база данных не имеет логики для управления автономным кешем, она имеет только методы для вставки и извлечения данных.
Хранилище будет иметь логику для извлечения результатов сети и поддержания базы данных в актуальном состоянии.

8. Задача: интегрировать репозиторий, используя стратегию обновления *******************************
В этой задаче вы интегрируете свой репозиторий с ViewModel помощью простой стратегии обновления.
Вы отображаете список воспроизведения видео из Room базы данных, а не извлекаете его напрямую из сети.
Обновления базы данных представляют собой процесс обновления или обновления локальной базы данных,
чтобы сохранить его в синхронизации с данными в сети.
Для этого примера приложения вы используете очень простую стратегию обновления,
при которой модуль, запрашивающий данные из репозитория, отвечает за обновление локальных данных.
В реальном приложении ваша стратегия может быть более сложной.
Например, ваш код может автоматически обновлять данные в фоновом режиме (с учетом пропускной способности)
или кэшировать данные, которые пользователь, скорее всего, будет использовать дальше.

Запустите ваше приложение.
Приложение работает, как и раньше, но теперь список воспроизведения DevBytes выбирается из сети и сохраняется в Room базе данных.
Список воспроизведения отображается на экране из Room базы данных, а не напрямую из сети.

Чтобы заметить разницу, включите режим полета на эмуляторе или устройстве.
Запустите приложение еще раз. Обратите внимание, что всплывающее сообщение «Ошибка сети» не отображается,
вместо этого список воспроизведения выбирается из автономного кэша и отображается.
Выключите режим полета в эмуляторе или устройстве.
Закройте и снова откройте приложение.
Приложение загружает список воспроизведения из автономного кэша, а сетевой запрос выполняется в фоновом режиме.

Если новые данные поступают из сети, экран автоматически обновляется, чтобы показать новые данные.
Однако сервер DevBytes не обновляет свое содержимое, поэтому вы не видите обновления данных.
Совет: Самый простой способ удалить кэш для тестирования - это удалить приложение.

Отличная работа! 09.1 ******************************************************************************
В этой кодовой метке вы реализовали автономный кеш с использованием Room,
подключили кеш к репозиторию и манипулировали LiveData с помощью преобразования.
Вы также интегрировали автономный кэш с функцией ViewModel отображения списка воспроизведения из репозитория,
а не извлекали список воспроизведения из сети.

09.2: WorkManager **********************************************************************************

Большинство реальных приложений должны выполнять длительные фоновые задачи.
Например, приложение может загружать файлы на сервер,
синхронизировать данные с сервера и сохранять их в Room базе данных,
отправлять журналы на сервер или выполнять дорогостоящие операции с данными.
Такие операции должны выполняться в фоновом режиме, вне потока пользовательского интерфейса (основного потока).
Фоновые задачи потребляют ограниченные ресурсы устройства, такие как оперативная память и батарея.
Это может привести к плохому восприятию пользователя, если оно не обрабатывается правильно.

В этом фрагменте кода вы узнаете, как использовать его WorkManager
для планирования фоновой задачи оптимизированным и эффективным способом.
Чтобы узнать больше о других доступных решениях для фоновой обработки в Android,
см. Руководство по фоновой обработке .

Что вы узнаете
Как создать Worker, который представляет собой единицу работы.
Как создать WorkRequest заявку на выполнение работ.
Как добавить ограничения в, WorkRequest чтобы определить, как и когда должен работать работник.
Как использовать WorkManager для планирования фоновых задач.
Что ты будешь делать
Создайте работника для выполнения фоновой задачи для предварительной загрузки списка воспроизведения видео DevBytes из сети.
Запланируйте периодическое выполнение работника.
Добавьте ограничения к WorkRequest.
Расписание периодического, WorkRequest который выполняется один раз в день.

В Android Studio раскройте все пакеты.
Исследуйте database пакет. Пакет содержит объекты базы данных и локальную базу данных, которая реализована с использованием Room.
Исследуйте repository пакет. Пакет содержит VideosRepository класс, который абстрагирует слой данных от остальной части приложения.
Изучите остальную часть начального кода самостоятельно и с помощью предыдущего кода.

Концепция: WorkManager
WorkManager является одним из компонентов архитектуры Android и частью Android Jetpack.
WorkManager для фоновой работы, которая является отложенной и требует гарантированного выполнения:

Отсроченный означает, что работа не требуется запускать немедленно.
Например, отправка аналитических данных на сервер или синхронизация базы данных в фоновом режиме
- это работа, которую можно отложить.
Гарантированное выполнение означает, что задание будет выполняться,
даже если приложение выйдет или устройство перезагрузится.

В то время как WorkManager выполняется фоновая работа,
он заботится о проблемах совместимости и передовых методиках работы аккумулятора и системы.
WorkManager обеспечивает совместимость обратно до уровня API 14.
WorkManager выбирает подходящий способ планирования фоновой задачи в зависимости от уровня API устройства.
Он может использовать JobScheduler(по API 23 и выше) или комбинацию AlarmManager и BroadcastReceiver.

WorkManager также позволяет устанавливать критерии при запуске фоновой задачи.
Например, вы можете захотеть, чтобы задача выполнялась только в том случае,
если состояние батареи, состояние сети или состояние зарядки соответствуют определенным критериям.
Вы узнаете, как устанавливать ограничения позже в этом коде.

Замечания:

WorkManager не предназначен для фоновой работы в процессе,
которая может быть безопасно завершена, если процесс приложения завершен.
WorkManager не предназначен для задач, требующих немедленного выполнения.

A Worker определяет единицу работы, а также WorkRequest определяет, как и когда должна выполняться работа.
Есть две конкретные реализации WorkRequestкласса:

-OneTimeWorkRequestКласс для одноразовых задач. ( Разовое задание выполняется только один раз.)
-PeriodicWorkRequestКласс для периодической работы, работы , которая повторяется с интервалами.
Задачи могут быть одноразовыми или периодическими, поэтому выберите класс соответственно.
Для получения дополнительной информации о планировании повторяющихся работ см. Документацию по повторяющимся работам .

Примечание : минимальный интервал для периодической работы составляет 15 минут.
Периодическая работа не может иметь начальную задержку в качестве одного из ограничений.

9.3 8. Задача: добавить ограничения ****************************************************************
В предыдущем задании вы использовали WorkManager планирование рабочего запроса.
В этой задаче вы добавляете критерии, когда выполнять работу.

При определении WorkRequest, вы можете указать ограничения на время Worker запуска.
Например, вы можете указать, что работа должна выполняться только тогда, когда устройство не используется,
или только когда оно подключено и подключено к Wi-Fi.
Вы также можете указать политику возврата для повторной работы.
В поддерживаемые ограничения являются методы набора в Constraints.Builder.
Чтобы узнать больше, см. Определение ваших рабочих запросов .

PeriodicWorkRequest и ограничения

Например, WorkRequest для повторения работы PeriodicWorkRequest выполняется несколько раз, пока она не будет отменена.
Первое выполнение происходит немедленно или как только заданные ограничения будут выполнены.

Следующее выполнение происходит в течение следующего интервала периода.
Обратите внимание, что выполнение может быть отложено из- WorkManager за оптимизации батареи ОС,
например, когда устройство находится в режиме ожидания .

10. Резюме *****************************************************************************************
WorkManagerAPI позволяет легко планировать откладываемые, асинхронные задачи , которые должны быть надежно работать.
Большинство реальных приложений должны выполнять длительные фоновые задачи. Чтобы запланировать фоновую задачу оптимизированным и эффективным способом, используйте WorkManager.
Основные классы в WorkManager библиотеке Worker, WorkRequest и WorkManager.
WorkerКласс представляет собой единицу работы. Чтобы реализовать фоновую задачу, расширьте Worker класс и переопределите doWork()метод.
WorkRequestКласс представляет собой запрос на выполнение единицы работы. WorkRequest является базовым классом для указания параметров работы, на которую вы планируете работать WorkManager.
Есть две конкретные реализации WorkRequest класса: OneTimeWorkRequest для одноразовых задач и PeriodicWorkRequest для периодических рабочих запросов.
При определении WorkRequest, вы можете указать, Constraints когда Worker следует запускать. Ограничения включают в себя такие вещи, как то, подключено ли устройство, находится ли оно в режиме ожидания или подключен ли Wi-Fi.
Чтобы добавить ограничения к WorkRequest, используйте методы , перечисленные в установленных в Constraints.Builder документации . Например, чтобы указать, что WorkRequest не должен работать, если батарея устройства разряжена, используйте setRequiresBatteryNotLow()метод set.
После того как вы определили WorkRequest, передайте задачу системе Android. Для этого запланируйте задачу одним из WorkManager enqueue способов .
Точное время Worker выполнения зависит от ограничений, которые используются в WorkRequest, и от системных оптимизаций. WorkManager разработан, чтобы дать наилучшее возможное поведение, учитывая эти ограничения.

11. Узнайте больше *********************************************************************************
Курс Udacity:

Разработка приложений для Android с Kotlin
Документация для разработчиков Android:

Определение ваших рабочих запросов
WorkManager
Начало работы с WorkManager
Повторяющаяся работа
Руководство по фоновой обработке
Другой:

Представляем WorkManager
Основы WorkManager