https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#0

https://startandroid.ru/ru/courses/architecture-components/27-course/architecture-components/567-urok-34-praktika-todoapp-tasks.html

Основы тестирования

Эта кодовая лаборатория охватывает основы запуска и написания тестов для Android. Он включает в себя разработку через тестирование, исходные наборы, Robolectric, AndroidX и тестирование ViewModels и LiveData.

Внедрение зависимостей и тестовые двойники

Эта лаборатория кода описывает, как реализовать ручное внедрение зависимостей и использовать тестовые двойники на Android. Он включает в себя настройку ручного внедрения зависимостей, создание подделок, создание макетов, создание ServiceLocators, инструментальные тесты для фрагментов, тестирование навигации и базовое тестирование Espresso.

Обзор тем тестирования

Эта последняя кодовая лаборатория охватывает тестирование определенных типов кода, в том числе:

Тестирование кода с сопрограммами
Комната для тестирования
Ресурс ожидания для эспрессо
Сквозное тестирование с привязкой данных

 05.1: основы тестирования
Эта первая лаборатория кода охватывает основы тестирования на Android, вы напишете свои первые тесты и научитесь тестировать LiveDataи ViewModels.

Вы узнаете о следующих темах:

Как писать и запускать модульные тесты на Android
Как использовать разработку через тестирование
Как выбрать инструментальные тесты и локальные тесты
Вы узнаете о следующих библиотеках и концепциях кода:

JUnit4
Hamcrest
Библиотека тестов AndroidX
Базовая тестовая библиотека компонентов архитектуры AndroidX

Что ты будешь делать
Настраивайте, запускайте и интерпретируйте как локальные, так и инструментальные тесты в Android.
Напишите модульные тесты в Android с помощью JUnit4 и Hamcrest.
Напишите простые LiveDataи ViewModelтесты.

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#3

Шаг 2. Изучите пример кода приложения
Приложение TO-DO основано на популярном образце тестирования и архитектуры Architecture Blueprints (с использованием версии образца с реактивной архитектурой ). Приложение следует архитектуре из Руководства по архитектуре приложения . Он использует ViewModels с фрагментами, репозиторий и комнату. Если вы знакомы с любым из приведенных ниже примеров, это приложение имеет аналогичную архитектуру:

Учебные курсы по основам Android Kotlin
Расширенные обучающие программы для Android
Номер с видом на Codelab
Образец Android Sunflower
Разработка приложений для Android с помощью учебного курса Kotlin Udacity

Более важно, чтобы вы понимали общую архитектуру приложения, чем глубоко разбирались в логике любого отдельного уровня.

Вот список пакетов, которые вы найдете:

Пакет: com.example.android.architecture.blueprints.todoapp

.addedittask

Экран добавления или редактирования задачи: код слоя пользовательского интерфейса для добавления или редактирования задачи.

.data

Уровень данных: это касается уровня данных задач. Он содержит код базы данных, сети и репозитория.

.statistics

Экран статистики: код уровня пользовательского интерфейса для экрана статистики.

.taskdetail

Экран сведений о задаче: код уровня пользовательского интерфейса для отдельной задачи.

.tasks

Экран задач: код уровня пользовательского интерфейса для списка всех задач.

.util

Служебные классы: общие классы, используемые в различных частях приложения, например, для макета обновления смахивания, используемого на нескольких экранах.

Уровень данных (.data)

Это приложение включает смоделированный сетевой уровень в удаленном пакете и уровень базы данных в локальном пакете. Для простоты в этом проекте сетевой уровень моделируется с HashMap задержкой, вместо того, чтобы делать реальные сетевые запросы.

В DefaultTasksRepository координатах или опосредует между сетевым и слоем базы данных и то , что возвращает данные на уровень пользовательского интерфейса.

Слой пользовательского интерфейса (.addedittask, .statistics, .taskdetail, .tasks)

Каждый из пакетов уровня пользовательского интерфейса содержит фрагмент и модель представления, а также любые другие классы, необходимые для пользовательского интерфейса (например, адаптер для списка задач). Это TaskActivity действие, которое содержит все фрагменты.

Навигация

Навигация в приложении управляется компонентом "Навигация" . Это определено в nav_graph.xmlфайле. В моделях представления запускается навигация с помощью Eventкласса; модели представления также определяют, какие аргументы передать. Фрагменты наблюдают за Eventсимволами и выполняют фактическую навигацию между экранами.

Локальные тесты ( исходный набор)test

Эти тесты запускаются локально на JVM вашей машины разработки и не требуют эмулятора или физического устройства. Из-за этого они бегают быстро, но их верность ниже, что означает, что они действуют менее так, как в реальном мире.

В Android Studio локальные тесты представлены значком зеленого и красного треугольника.

Инструментальные тесты ( исходный набор)androidTest

Эти тесты выполняются на реальных или эмулируемых устройствах Android, поэтому они отражают то, что происходит в реальном мире, но также намного медленнее.

В Android Studio инструментальные тесты представлены Android с зеленым и красным треугольником.

Добавьте зависимость Hamcrest
testImplementation "org.hamcrest:hamcrest-all:$hamcrestVersion"

assertEquals(result.completedTasksPercent, 0f)

// versus

assertThat(result.completedTasksPercent, `is`(0f))

 Еще один хороший инструмент для написания удобочитаемых утверждений - это библиотека Truth

7. Задача: написание дополнительных тестов.  Test Driven Development

В этой задаче вы напишете больше тестов, используя JUnit и Hamcrest. Вы также будете писать тесты, используя стратегию, основанную на программной практике разработки через тестирование . Разработка через тестирование или TDD - это школа программирования, которая гласит, что вместо того, чтобы сначала писать код функции, вы сначала пишете свои тесты. Затем вы пишете код функции, чтобы пройти тесты.

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#7

8. Задача: настройка теста ViewModel с помощью AndroidX Test.

Добавьте ядро AndroidX Test и зависимости ext
Добавить зависимость библиотеки Robolectric Testing
Аннотируйте класс с помощью средства запуска тестов AndroidJunit4
Написать тестовый код AndroidX

9. Задача: написание утверждений для LiveData.

Для проверки LiveDataрекомендуется сделать две вещи:
Использовать InstantTaskExecutorRule
Обеспечить LiveDataнаблюдение

10. Задача: написание нескольких тестов ViewModel.

Совет: в следующих уроках вы узнаете гораздо больше о тестировании ViewModels. Прямо сейчас вы не можете протестировать какие-либо методы в используемой модели представления viewModelScope, вы увидите сообщение об ошибке:

Exception in thread "main" java.lang.IllegalStateException: Module with the Main dispatcher had failed to initialize.

Точно так же методы тестирования, которые используются DefaultTaskRepository, сложно, потому что это вызывает код в коде сети и коде базы данных. Все это вы узнаете из следующих лабораторных работ.

12. Резюме
Эта кодовая лаборатория охватывает:

Как запускать тесты из Android Studio.
Разница между локальными ( test) и инструментальными тестами ( androidTest).
Как писать локальные модульные тесты с использованием JUnit и Hamcrest .
Настройка тестов ViewModel с помощью библиотеки тестов AndroidX .

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-test-doubles/#0
Расширенный Android в Kotlin 05.2: Введение в тестовые двойники и внедрение зависимостей
Introduction to Test Doubles and Dependency Injection

Эта вторая тестовая кодовая лаборатория посвящена тестовым двойникам: когда их использовать в Android и как их реализовать с помощью внедрения зависимостей, шаблона Service Locator и библиотек. Поступая так, вы научитесь писать:

Модульные тесты репозитория
Интеграционные тесты фрагментов и моделей просмотра
Тесты навигации по фрагментам

Как спланировать стратегию тестирования
Как создавать и использовать тестовые двойники, а именно фейки и моки
Как использовать ручное внедрение зависимостей на Android для модульных и интеграционных тестов
Как применить шаблон Service Locator
Как тестировать репозитории, фрагменты, модели просмотра и компонент навигации

Пирамида тестирования
Когда вы думаете о стратегии тестирования, есть три связанных аспекта тестирования:

Область действия - Какую часть кода затрагивает тест? Тесты могут выполняться одним методом, во всем приложении или где-то посередине.
Скорость - Насколько быстро проходит тест? Скорость тестирования может варьироваться от миллисекунд до нескольких минут.
Верность - Насколько "реальный" тест? Например, если часть тестируемого кода должна выполнить сетевой запрос, действительно ли тестовый код выполняет этот сетевой запрос или подделывает результат? Если тест действительно разговаривает с сетью, это означает, что у него более высокая точность. Компромисс заключается в том, что выполнение теста может занять больше времени, может привести к ошибкам, если сеть не работает, или может быть дорогостоящим в использовании.
Между этими аспектами есть неизбежные компромиссы. Например, скорость и точность - это компромисс: чем быстрее тест, тем меньше точность, и наоборот. Один из распространенных способов разделить автоматизированные тесты - на эти три категории:

Модульные тесты - это узкоспециализированные тесты, которые выполняются в одном классе, обычно в одном методе этого класса. Если модульный тест не проходит, вы можете точно знать, где именно в вашем коде проблема. У них низкая точность, поскольку в реальном мире ваше приложение включает в себя гораздо больше, чем выполнение одного метода или класса. Они достаточно быстрые, чтобы запускаться каждый раз, когда вы меняете код. Чаще всего это тесты, запускаемые локально (в testисходном наборе). Пример: тестирование отдельных методов в моделях представлений и репозиториях.
Интеграционные тесты - тестируют взаимодействие нескольких классов, чтобы убедиться, что при совместном использовании они ведут себя должным образом. Один из способов структурирования интеграционных тестов - это заставить их протестировать одну функцию, например возможность сохранить задачу. Они тестируют больший объем кода, чем модульные тесты, но по-прежнему оптимизированы для быстрой работы, а не для полной точности. Их можно запускать локально или как инструментальные тесты, в зависимости от ситуации. Пример: тестирование всех функциональных возможностей отдельной пары фрагмент и модель представления.
Сквозные тесты (E2e) - проверьте сочетание работающих вместе функций. Они тестируют большие части приложения, тщательно моделируют реальное использование и поэтому обычно работают медленно. Они обладают высочайшей точностью и говорят вам, что ваше приложение действительно работает в целом. По большому счету, эти тесты будут инструментальными тестами (в androidTestисходном наборе). Пример: запуск всего приложения и одновременное тестирование нескольких функций

5. Задача: написать тест с использованием внедрения зависимостей
На этом этапе вы собираетесь использовать технику, называемую ручным внедрением зависимостей, чтобы вы могли использовать только что созданный поддельный тестовый двойник.


7. Задача: использовать фальшивый репозиторий внутри ViewModel.
Tip: To avoid building a seperate factory for each view model, check out the Architecture Blueprints reactive sample, which shows a slightly more complicated version of the tests you are building. It includes a generic ViewModelFactory that can generate any view model needed, and this extension function.
 чтобы не создавать отдельную фабрику для каждой модели представления, ознакомьтесь с реактивным образцом Architecture Blueprints , в котором показана немного более сложная версия тестов, которые вы создаете. Он включает в себя общий ViewModelFactory, который может генерировать любую необходимую модель представления, и эту функцию расширения .
https://github.com/android/architecture-samples/tree/reactive

8. Задача: запустить фрагмент из теста.
Затем вы напишете интеграционные тесты для проверки взаимодействия фрагмента и модели представления. Вы узнаете, правильно ли обновляет код модели представления ваш пользовательский интерфейс. Для этого вы используете

шаблон ServiceLocator
библиотеки Espresso и Mockito
