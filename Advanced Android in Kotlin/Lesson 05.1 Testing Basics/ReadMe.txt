https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#0

https://startandroid.ru/ru/courses/architecture-components/27-course/architecture-components/567-urok-34-praktika-todoapp-tasks.html

Основы тестирования

Эта кодовая лаборатория охватывает основы запуска и написания тестов для Android. Он включает в себя разработку через тестирование, исходные наборы, Robolectric, AndroidX и тестирование ViewModels и LiveData.

Внедрение зависимостей и тестовые двойники

Эта лаборатория кода описывает, как реализовать ручное внедрение зависимостей и использовать тестовые двойники на Android. Он включает в себя настройку ручного внедрения зависимостей, создание подделок, создание макетов, создание ServiceLocators, инструментальные тесты для фрагментов, тестирование навигации и базовое тестирование Espresso.

Обзор тем тестирования

Эта последняя кодовая лаборатория охватывает тестирование определенных типов кода, в том числе:

Тестирование кода с сопрограммами
Комната для тестирования
Ресурс ожидания для эспрессо
Сквозное тестирование с привязкой данных

 05.1: основы тестирования
Эта первая лаборатория кода охватывает основы тестирования на Android, вы напишете свои первые тесты и научитесь тестировать LiveDataи ViewModels.

Вы узнаете о следующих темах:

Как писать и запускать модульные тесты на Android
Как использовать разработку через тестирование
Как выбрать инструментальные тесты и локальные тесты
Вы узнаете о следующих библиотеках и концепциях кода:

JUnit4
Hamcrest
Библиотека тестов AndroidX
Базовая тестовая библиотека компонентов архитектуры AndroidX

Что ты будешь делать
Настраивайте, запускайте и интерпретируйте как локальные, так и инструментальные тесты в Android.
Напишите модульные тесты в Android с помощью JUnit4 и Hamcrest.
Напишите простые LiveDataи ViewModelтесты.

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#3

Шаг 2. Изучите пример кода приложения
Приложение TO-DO основано на популярном образце тестирования и архитектуры Architecture Blueprints (с использованием версии образца с реактивной архитектурой ). Приложение следует архитектуре из Руководства по архитектуре приложения . Он использует ViewModels с фрагментами, репозиторий и комнату. Если вы знакомы с любым из приведенных ниже примеров, это приложение имеет аналогичную архитектуру:

Учебные курсы по основам Android Kotlin
Расширенные обучающие программы для Android
Номер с видом на Codelab
Образец Android Sunflower
Разработка приложений для Android с помощью учебного курса Kotlin Udacity

Более важно, чтобы вы понимали общую архитектуру приложения, чем глубоко разбирались в логике любого отдельного уровня.

Вот список пакетов, которые вы найдете:

Пакет: com.example.android.architecture.blueprints.todoapp

.addedittask

Экран добавления или редактирования задачи: код слоя пользовательского интерфейса для добавления или редактирования задачи.

.data

Уровень данных: это касается уровня данных задач. Он содержит код базы данных, сети и репозитория.

.statistics

Экран статистики: код уровня пользовательского интерфейса для экрана статистики.

.taskdetail

Экран сведений о задаче: код уровня пользовательского интерфейса для отдельной задачи.

.tasks

Экран задач: код уровня пользовательского интерфейса для списка всех задач.

.util

Служебные классы: общие классы, используемые в различных частях приложения, например, для макета обновления смахивания, используемого на нескольких экранах.

Уровень данных (.data)

Это приложение включает смоделированный сетевой уровень в удаленном пакете и уровень базы данных в локальном пакете. Для простоты в этом проекте сетевой уровень моделируется с HashMap задержкой, вместо того, чтобы делать реальные сетевые запросы.

В DefaultTasksRepository координатах или опосредует между сетевым и слоем базы данных и то , что возвращает данные на уровень пользовательского интерфейса.

Слой пользовательского интерфейса (.addedittask, .statistics, .taskdetail, .tasks)

Каждый из пакетов уровня пользовательского интерфейса содержит фрагмент и модель представления, а также любые другие классы, необходимые для пользовательского интерфейса (например, адаптер для списка задач). Это TaskActivity действие, которое содержит все фрагменты.

Навигация

Навигация в приложении управляется компонентом "Навигация" . Это определено в nav_graph.xmlфайле. В моделях представления запускается навигация с помощью Eventкласса; модели представления также определяют, какие аргументы передать. Фрагменты наблюдают за Eventсимволами и выполняют фактическую навигацию между экранами.

Локальные тесты ( исходный набор)test

Эти тесты запускаются локально на JVM вашей машины разработки и не требуют эмулятора или физического устройства. Из-за этого они бегают быстро, но их верность ниже, что означает, что они действуют менее так, как в реальном мире.

В Android Studio локальные тесты представлены значком зеленого и красного треугольника.

Инструментальные тесты ( исходный набор)androidTest

Эти тесты выполняются на реальных или эмулируемых устройствах Android, поэтому они отражают то, что происходит в реальном мире, но также намного медленнее.

В Android Studio инструментальные тесты представлены Android с зеленым и красным треугольником.

Добавьте зависимость Hamcrest
testImplementation "org.hamcrest:hamcrest-all:$hamcrestVersion"

assertEquals(result.completedTasksPercent, 0f)

// versus

assertThat(result.completedTasksPercent, `is`(0f))

 Еще один хороший инструмент для написания удобочитаемых утверждений - это библиотека Truth

7. Задача: написание дополнительных тестов.  Test Driven Development

В этой задаче вы напишете больше тестов, используя JUnit и Hamcrest. Вы также будете писать тесты, используя стратегию, основанную на программной практике разработки через тестирование . Разработка через тестирование или TDD - это школа программирования, которая гласит, что вместо того, чтобы сначала писать код функции, вы сначала пишете свои тесты. Затем вы пишете код функции, чтобы пройти тесты.

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#7

8. Задача: настройка теста ViewModel с помощью AndroidX Test.

Добавьте ядро AndroidX Test и зависимости ext
Добавить зависимость библиотеки Robolectric Testing
Аннотируйте класс с помощью средства запуска тестов AndroidJunit4
Написать тестовый код AndroidX

9. Задача: написание утверждений для LiveData.

Для проверки LiveDataрекомендуется сделать две вещи:
Использовать InstantTaskExecutorRule
Обеспечить LiveDataнаблюдение

10. Задача: написание нескольких тестов ViewModel.

Совет: в следующих уроках вы узнаете гораздо больше о тестировании ViewModels. Прямо сейчас вы не можете протестировать какие-либо методы в используемой модели представления viewModelScope, вы увидите сообщение об ошибке:

Exception in thread "main" java.lang.IllegalStateException: Module with the Main dispatcher had failed to initialize.

Точно так же методы тестирования, которые используются DefaultTaskRepository, сложно, потому что это вызывает код в коде сети и коде базы данных. Все это вы узнаете из следующих лабораторных работ.

12. Резюме
Эта кодовая лаборатория охватывает:

Как запускать тесты из Android Studio.
Разница между локальными ( test) и инструментальными тестами ( androidTest).
Как писать локальные модульные тесты с использованием JUnit и Hamcrest .
Настройка тестов ViewModel с помощью библиотеки тестов AndroidX .

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-test-doubles/#0
Расширенный Android в Kotlin 05.2: Введение в тестовые двойники и внедрение зависимостей
Introduction to Test Doubles and Dependency Injection

Эта вторая тестовая кодовая лаборатория посвящена тестовым двойникам: когда их использовать в Android и как их реализовать с помощью внедрения зависимостей, шаблона Service Locator и библиотек. Поступая так, вы научитесь писать:

Модульные тесты репозитория
Интеграционные тесты фрагментов и моделей просмотра
Тесты навигации по фрагментам

Как спланировать стратегию тестирования
Как создавать и использовать тестовые двойники, а именно фейки и моки
Как использовать ручное внедрение зависимостей на Android для модульных и интеграционных тестов
Как применить шаблон Service Locator
Как тестировать репозитории, фрагменты, модели просмотра и компонент навигации

Пирамида тестирования
Когда вы думаете о стратегии тестирования, есть три связанных аспекта тестирования:

Область действия - Какую часть кода затрагивает тест? Тесты могут выполняться одним методом, во всем приложении или где-то посередине.
Скорость - Насколько быстро проходит тест? Скорость тестирования может варьироваться от миллисекунд до нескольких минут.
Верность - Насколько "реальный" тест? Например, если часть тестируемого кода должна выполнить сетевой запрос, действительно ли тестовый код выполняет этот сетевой запрос или подделывает результат? Если тест действительно разговаривает с сетью, это означает, что у него более высокая точность. Компромисс заключается в том, что выполнение теста может занять больше времени, может привести к ошибкам, если сеть не работает, или может быть дорогостоящим в использовании.
Между этими аспектами есть неизбежные компромиссы. Например, скорость и точность - это компромисс: чем быстрее тест, тем меньше точность, и наоборот. Один из распространенных способов разделить автоматизированные тесты - на эти три категории:

Модульные тесты - это узкоспециализированные тесты, которые выполняются в одном классе, обычно в одном методе этого класса. Если модульный тест не проходит, вы можете точно знать, где именно в вашем коде проблема. У них низкая точность, поскольку в реальном мире ваше приложение включает в себя гораздо больше, чем выполнение одного метода или класса. Они достаточно быстрые, чтобы запускаться каждый раз, когда вы меняете код. Чаще всего это тесты, запускаемые локально (в testисходном наборе). Пример: тестирование отдельных методов в моделях представлений и репозиториях.
Интеграционные тесты - тестируют взаимодействие нескольких классов, чтобы убедиться, что при совместном использовании они ведут себя должным образом. Один из способов структурирования интеграционных тестов - это заставить их протестировать одну функцию, например возможность сохранить задачу. Они тестируют больший объем кода, чем модульные тесты, но по-прежнему оптимизированы для быстрой работы, а не для полной точности. Их можно запускать локально или как инструментальные тесты, в зависимости от ситуации. Пример: тестирование всех функциональных возможностей отдельной пары фрагмент и модель представления.
Сквозные тесты (E2e) - проверьте сочетание работающих вместе функций. Они тестируют большие части приложения, тщательно моделируют реальное использование и поэтому обычно работают медленно. Они обладают высочайшей точностью и говорят вам, что ваше приложение действительно работает в целом. По большому счету, эти тесты будут инструментальными тестами (в androidTestисходном наборе). Пример: запуск всего приложения и одновременное тестирование нескольких функций

5. Задача: написать тест с использованием внедрения зависимостей
На этом этапе вы собираетесь использовать технику, называемую ручным внедрением зависимостей, чтобы вы могли использовать только что созданный поддельный тестовый двойник.


7. Задача: использовать фальшивый репозиторий внутри ViewModel.
Tip: To avoid building a seperate factory for each view model, check out the Architecture Blueprints reactive sample, which shows a slightly more complicated version of the tests you are building. It includes a generic ViewModelFactory that can generate any view model needed, and this extension function.
 чтобы не создавать отдельную фабрику для каждой модели представления, ознакомьтесь с реактивным образцом Architecture Blueprints , в котором показана немного более сложная версия тестов, которые вы создаете. Он включает в себя общий ViewModelFactory, который может генерировать любую необходимую модель представления, и эту функцию расширения .
https://github.com/android/architecture-samples/tree/reactive

8. Задача: запустить фрагмент из теста.
Затем вы напишете интеграционные тесты для проверки взаимодействия фрагмента и модели представления. Вы узнаете, правильно ли обновляет код модели представления ваш пользовательский интерфейс. Для этого вы используете

шаблон ServiceLocator
библиотеки Espresso и Mockito

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-test-doubles/#8

10. Задача: написание первого интеграционного теста с эспрессо.
Эспрессо помогает:

Взаимодействуйте с представлениями, например нажимая кнопки, перемещая панель или прокручивая экран вниз.
Утверждение, что определенные представления отображаются на экране или находятся в определенном состоянии (например, содержат определенный текст, или что установлен флажок и т. Д.).
Шаг 2. Отключите анимацию.
Тесты эспрессо проводятся на реальном устройстве и, следовательно, по своей природе являются инструментальными тестами. Одна из возникающих проблем - это анимация: если анимация задерживается и вы пытаетесь проверить, отображается ли представление на экране, но оно все еще анимируется, Espresso может случайно не пройти тест. Это может сделать тест на эспрессо нестабильным.


onView(withId(R.id.task_detail_complete_checkbox)).perform(click()).check(matches(isChecked()))
Этот оператор находит представление флажка с идентификатором task_detail_complete_checkbox, щелкает его, а затем утверждает, что он отмечен .

Большинство заявлений об эспрессо состоит из четырех частей:

Статический метод эспрессо
onView

onViewпредставляет собой пример статического метода Espresso, который запускает оператор Espresso. onViewявляется одним из самых распространенных, но есть и другие варианты, например onData.

ViewMatcher
withId(R.id.task_detail_title_text)

withId- это пример объекта, ViewMatcherкоторый получает представление по его идентификатору. Существуют и другие сопоставители представлений, которые вы можете найти в документации .

ViewAction
perform(click())

performМетод , который принимает ViewAction. A ViewAction- это что-то, что можно сделать с представлением, например, здесь это щелчок по представлению.

ViewAssertion
check(matches(isChecked()))

checkкоторый занимает ViewAssertion. ViewAssertions проверяет или утверждает что-то о представлении. Чаще всего ViewAssertionвы будете использовать matchesassertion. Чтобы завершить утверждение ViewMatcher, в данном случае используйте другое isChecked.

Обратите внимание, что вы не всегда вызываете оба performи checkв операторе Espresso. У вас могут быть операторы, которые просто утверждают, используя checkили просто ViewActionиспользуют perform.

11. Задача: использование Mockito для написания тестов навигации.

На этом последнем шаге вы узнаете, как протестировать компонент Navigation , используя другой тип тестового двойника, который называется mock, и библиотеку тестирования Mockito .

Mockito - это фреймворк для создания тестовых двойников. Хотя слово mock используется в API и названии, оно не просто для создания mock. Он также может делать заглушек и шпионов.

13. Резюме
В этой лаборатории кода рассказывалось, как настроить ручную инъекцию зависимостей, локатор сервисов и как использовать фейки и макеты в ваших приложениях Android Kotlin. В частности:

То, что вы хотите протестировать, и ваша стратегия тестирования определяют типы тестов, которые вы собираетесь реализовать для своего приложения. Модульные тесты сфокусированы и быстры. Интеграционные тесты проверяют взаимодействие между частями вашей программы. Сквозные тесты проверяют функции, имеют высочайшую точность, часто оснащены инструментами и могут занять больше времени.
Архитектура вашего приложения влияет на то, насколько сложно его тестировать.
Чтобы изолировать части вашего приложения для тестирования, вы можете использовать тестовые двойники. Двойной тест версия класса созданная специально для тестирования. Например, вы подделываете получение данных из базы данных или Интернета.
Используйте внедрение зависимостей, чтобы заменить реальный класс тестовым классом, например репозиторием или сетевым уровнем.
Используйте инструментальное тестирование ( androidTest) для запуска компонентов пользовательского интерфейса.
Когда вы не можете использовать внедрение зависимостей конструктора, например, для запуска фрагмента, вы часто можете использовать локатор служб. Шаблон Service Locator является альтернативой Dependency Injection. Он включает в себя создание одноэлементного класса под названием «Service Locator», целью которого является предоставление зависимостей как для обычного, так и для тестового кода.

14. Узнать больше
Образцы:

Официальный образец тестирования - это официальный образец тестирования, основанный на том же приложении TO-DO Notes, используемом здесь. Концепции в этом образце выходят за рамки того, что описано в трех тестовых кодовых таблицах.
Демо Sunflower - это основной образец Android Jetpack, который также использует библиотеки тестирования Android.
Образцы для тестирования эспрессо
Курс Udacity:

Разработка приложений для Android с помощью Kotlin
Документация разработчика Android:

Руководство по архитектуре приложения
runBlocking а также runBlockingTest
FragmentScenario
Эспрессо
Mockito
JUnit4
Библиотека тестов AndroidX
Базовая тестовая библиотека компонентов архитектуры AndroidX
Исходные наборы
Тест из командной строки
Внедрение зависимостей на Android
Видео:

Экспертное руководство по внедрению зависимостей на Android (Android Dev Summit '19)
Создание тестируемых приложений для Android (Google I / O'19)
Фрагменты: прошлое, настоящее и будущее (Android Dev Summit '19) - раздел «Тестирование и фрагменты»
Другой:

Использование Dagger в вашем Android-приложении Codelab Tutorial
Тестирование в туалете: знай свои тестовые пары
Руководство по внедрению зависимостей на Android - ADS 2019
Реактивный образец архитектурных чертежей
Кинжал в Котлине: подводные камни и оптимизация
Dagger.dev

