<html>
 <head></head>
 <body>
  <ol> 
   <li> <p>Особенности языка и платформы Java. Редакции Java.</p> </li> 
   <li> <p>Классификация программ по типу исполнения (компилируемые, интерпретируемые, исполняемые на виртуальных машинах). Виртуальная машина Java. HotSpot. JIT-компиляция.</p> </li> 
   <li> <p>Создание простейшей программы на Java, её компиляция в байт-код и запуск. Classpath. JVM языки.</p> </li> 
   <li> <p>Типы данных Java: примитивные типы, ссылочные типы. Приведение типов.</p> </li> 
   <li> <p>Класс String. Назначение классов StringBuffer/StringBuilder. Автобоксинг и анбоксинг.</p> </li> 
   <li> <p>Организация кода: классы, пакеты. Модификаторы доступа.</p> </li> 
   <li> <p>Статические поля, методы, классы.</p> </li> 
   <li> <p>ООП в Java. Интерфейсы. Полиморфизм. Раннее и позднее связывание.</p> </li> 
   <li> <p>Жизненный цикл объекта в Java.</p> </li> 
   <li> <p>Класс java.lang.Object. Методы hashCode и equals.</p> </li> 
   <li> <p>POJO. Неизменяемый объекты.</p> </li> 
   <li> <p>Исключения. Обработка исключительных ситуаций. Блок try-catch-finally, try with resources.</p> </li> 
   <li> <p>Исключения. Иерархия классов исключений. Проверяемые и непроверяемые исключения.</p> </li> 
   <li> <p>Вложенные и внутренние классы.</p> </li> 
   <li> <p>Принципы проектирования SOLID. Single responsibility. Open closed principle. Liskov substitution principle.</p> </li> 
   <li> <p>Принципы проектирования SOLID. Interface segregation. Dependency inversion. Liskov substitution principle.</p> </li> 
   <li> <p>Автоматические системы сборки. Apache Maven: pom.xml, жизненный цикл.</p> </li> 
   <li> <p>Автоматические системы сборки. Apache Maven: управление зависимостями, плагины, архетипы.</p> </li> 
   <li> <p>Модульное тестирование: фреймворк JUnit. Структура тест-класса.</p> </li> 
   <li> <p>Потоки ввода-вывода: InputStream/OutputStream, Reader/Writer. Буферизованные потоки.</p> </li> 
   <li> <p>Пакеты java.io и java.nio. API для работы с файловой системой.</p> </li> 
   <li> <p>Collections Framework. Интерфейс Collection&lt;E&gt; и класс AbstractCollection. Интерфейс Iterator&lt;E&gt;.</p> </li> 
   <li> <p>Collections Framework. Множестка и списки. Сравнение реализаций.</p> </li> 
   <li> <p>Collections Framework. Отображение. Внутреннее устройство Map в java. Интерфейс Map&lt;K, V&gt;. Сравнение реализаций.</p> </li> 
   <li> <p>Collections Framework. Сравнение элементов: интерфейсы Comparable&lt;E&gt; и Comparator&lt;E&gt;.</p> </li> 
   <li> <p>Collections Framework. Классы TreeMap/TreeSet. Алгоритмы для работы с коллекциями в пакете java.util.</p> </li> 
   <li> <p>Многопоточное программирование. Класс Thread, интерфейс Runnable. Состояния потока.</p> </li> 
   <li> <p>Многопоточное программирование. Способы синхронизация потоков. Блокировки и &nbsp;мониторы.</p> </li> 
   <li> <p>Многопоточное программирование. Модель памяти Java. Ключевое слово volatile.</p> </li> 
   <li> <p>Обобщенное программирование (Generics). &nbsp;Стирание типов (Type erasure). Подстановочные типы. (Wildcards).</p> </li> 
   <li> <p>Обобщенное программирование (Generics). Идиома PECS (Producer extends and Consumer super)</p> </li> 
   <li> <p>Lambda-выражения. Функциональные интерфейсы. Consumer, Supplier, Predicate, Function. Пакет java.util.function.</p> </li> 
   <li> <p>Lambda-выражения. Ссылки на методы. Область видимости переменных Effectively final переменные. Внутренний итератор по коллекции.</p> </li> 
   <li> <p>Lambda-выражения. Композиция функций. Lazy-вычисления</p> </li> 
   <li> <p>Stream API. Создание стримов (источники). Особенности работы. Промежуточные операторы</p> </li> 
   <li> <p>Stream API. Параллельные стримы. Терминальные операторы</p> </li> 
   <li> <p>Stream API. Коллекторы (java.util.stream.Collectors) и компараторы (java.util.Comparator)</p> </li> 
   <li> <p>Тип Optional. Default-методы в интерфейсах.</p> </li> 
  </ol>
 </body>
</html>