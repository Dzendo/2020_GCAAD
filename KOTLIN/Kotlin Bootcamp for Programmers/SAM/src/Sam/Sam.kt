package Sam

// SAM - Single Abstract Methods
// Буду все время сталкиваться с SAM в API, написанных на Java
// По сути SAM означает только интерфейс с одним методом. Вот и все.
// Runnable и callable являются двумя примерами:
    // в этом примере runnable имеет абстрактный метод "запустить"
//interface Runnable {
//    fun run()
    // в этом примере Callable имеет единственный метод "вызов"
//}
//interface Callable<T> {
//    fun call(): T
//}
// В Котлин мы должны вызывать функции, которые постоянно принимают SAM в качестве параметров

// Если мы хотим вызват из Java Run сейчас
// мы можем сделать объект runnable и реализовать метод run
// Этот синтаксис object:class позволяет вам создавать объект, который реализует интерфейс
// Это полезно для передачи таких параметров как это
fun example_(){
    val runnable = object : Runnable {
        override fun run() {
           println("I'm a runnable")
        }
    }
    JavaRun.runNow(runnable)
}

// Не слишком увлекательно, но много кода просто для вызова println

// К счастью в Котлине мы можем передать лямбду вместо SAM
// Котлин позаботится, чтобы сделать правильный вид объекта для нас
fun example(){
    JavaRun.runNow {
        println("Passing a lambda as a runnable")
    }
}

// Еще круче, если Вы берете SAM в качестве последнего параметра, как мы делаем здесь
// Вы можете использовать синтаксис последнего вызова параметра,
// чтобы задать лямбду за пределами отпечатков
// И это все что он может сказать о SAM
