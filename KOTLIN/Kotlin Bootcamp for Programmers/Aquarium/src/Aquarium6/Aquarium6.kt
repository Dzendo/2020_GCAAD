package Aquarium6
// написание функций высшего порядка с расширением
// лямбда - самая продвинутая часть языка Котлин
// Требуется время, чтобы научиться их писать
// Тем не менее, они действительно удобны в использовании
// Есть станд библиотека и это только один пример
// есть тонны встроенных функций в станд библ Котлин, использующая расширение лямбда

// Я БУДУ ИСПОЛЬЗОВАТЬ ЭТИ ФУНКЦИИ ВЕЗДЕ В СВОЕМ КОДЕ КОТЛИН


// класс данных с одним свойством для имени:
data class Fish (var name: String )

fun main(){
    fishexamples()
}

fun fishexamples() {
    val fish = Fish("splashy")  // грязный

//простой пример чтобы увидеть как это работает (функ высш порядка):
    // Внутри функции fishexamples() вызываем с with
    // продолжение создания myWith

    myWith (fish.name) {
   // with (fish.name) {                   // {Это внутри лямбды - между фигурными скобками}
        //this.capitalize()              // на объект неявно ссылается слово this
        println(capitalize())                    // превратить в верхний регистр - возвращает копию Splashy
        // Под капотом функция высшенр порядка
    }
    // примерры тонн других лямбд:
    println(fish.run { name })  // здесь просто вернет имя для всех типов данных
    println(fish.apply {  } )            // для всех типов данных возвращает объект, к которому он применен
    // Это применение может быть полезно для вызова функций вновь созданного объекта:
    // Мы создаем новую рыбу и перед тем, как присвоить ее переменной вызываем apply
    // затем применяем лямбду, чтобы установить ее имя
    val  fish2:Fish = Fish(name = "splashy").apply { name = " sharky" }
    println(fish2.name)
    // apply возвращает рыбу, которую мы только что построили
    // это действительно распространенный шаблон для инициализации объектов

    // Теперь LET - возвращает копию измененного объекта
    // LET особенно полезен для сцепления манипуляций
    // перепишем первый пример capitalize: где впервые используем рыбу

    println(fish.let { it.name.capitalize()}
        .let { it + " fish " }
        .let { it.length }
        .let { it +31 })
}

// Чтобы увидеть как это работает
// сделаем нашу собственную значительно упрощенную версию
// которая работает только для строк
// Для начала определим функцию myWith которая принимает два аргумента
// аргументы будут объектом для выполнения операции
// и функция, которая определяет операцию, выполняемую над объектом
// Функция myWith принимает String потому что мы хотим передать имя рыбы
// Второй аргумент - это определение функции операции - block - имя функции - любое
// Для функции необходимо имя, чтобы мы могли его использовать в теле функции myWith
// block - имя функции затем двоеточие и класс который расширяем(String)
// так что мы можем использовать myWith на нем, а мы решили строки
// Класс, который мы расширяем, часто называют объектом-получателем
// Наконец мы указываеь тип возврата оргумента функции -> Unit? тк ничего не возвращаем
// Итого block топерь является функцией расширения для строкового объекта
// и мы можем его применить к строке

fun  myWith(name: String, block: String.() -> Unit) {
    // Мы берем имя и вызываем блокировку на нем:
    name.block()
    // Теперь можем применить К рыбе см выше
}


