Kotlin Bootcamp для программистов 6: функциональные манипуляции
2. Задача: узнать об аннотациях
Аннотации - это способ прикрепления метаданных к коду, и они не являются чем-то конкретным для Kotlin.
 Аннотации читаются компилятором и используются для генерации кода или логики.
  Многие фреймворки, такие как Ktor и Kotlinx , а также Room,
   используют аннотации для настройки того, как они работают и взаимодействуют с вашим кодом.
    Вы вряд ли столкнетесь с какими-либо аннотациями, пока не начнете использовать фреймворки,
     но полезно знать, как читать аннотации.
Есть также аннотации, которые доступны через стандартную библиотеку Kotlin, которая контролирует способ компиляции кода.
 Они действительно полезны, если вы экспортируете Kotlin в код Java, но в противном случае они вам не нужны так часто.
Аннотации идут прямо перед тем, что аннотируется,
и большинство вещей можно аннотировать - классы, функции, методы и даже структуры управления.
 Некоторые аннотации могут принимать аргументы.

 Вы также можете создавать свои собственные аннотации,
  но это в основном полезно, если вы пишете библиотеку,
   которая требует конкретной информации о классах во время выполнения, то есть отражения .
Шаг 2. Создайте собственную аннотацию
Шаг 3: Создайте целевую аннотацию
Аннотации могут быть нацелены на получателей или установщиков.
Когда они это сделают, вы можете применить их с префиксом @get:или @set:.
Это часто возникает при использовании каркасов с аннотациями.

Аннотации действительно эффективны для создания библиотек,
которые проверяют вещи как во время выполнения, так и иногда во время компиляции.
Однако типичный код приложения просто использует аннотации, предоставляемые фреймворками.

3. Задача: узнать о помеченных перерывах
У Котлина есть несколько способов управления потоком.
Вы уже знакомы с тем return, что возвращается из функции в ее вмещающую функцию.
Использование это break как return, но для циклов.

Kotlin дает вам дополнительный контроль над циклами с помощью так называемого разрыва.
break Квалифицировано с меткой переходит к точке выполнения сразу после цикла , отмеченного этой меткой.
Это особенно полезно при работе с вложенными циклами.

Любое выражение в Kotlin может быть помечено меткой.
Метки имеют форму идентификатора, за которым следует @знак.

Точно так же вы можете использовать помеченные continue.
Вместо выхода из помеченного цикла, помеченное продолжение переходит к следующей итерации цикла.

Примечание: помеченный разрыв в Kotlin может использоваться только для выхода из циклов,
в отличие от gotoC ++ или C #.

4. Задача: создать простые лямбды
Лямбды - это анонимные функции, которые являются функциями без имени.
Вы можете назначить их переменным и передать их в качестве аргументов функциям и методам.
Они чрезвычайно полезны.

joinToString() Функция создает строку путем объединения отфильтрованных имен, разделенных строки, заданной.
Это одна из многих полезных функций, встроенных в стандартную библиотеку Kotlin.

5. Task: Write a higher-order function
5. Задача: написать функцию высшего порядка
Передача лямбда-функции или другой функции в качестве аргумента функции создает функцию более высокого порядка.
Фильтр выше - простой пример этого:  myFish.filter { it.name.contains("i")}
filter() является функцией, и вы передаете ей лямбда, которая определяет, как обрабатывать каждый элемент списка.

Написание функций высшего порядка с расширением лямбда-выражений является одной из самых продвинутых частей языка Kotlin.
Чтобы научиться их писать, нужно некоторое время, но ими действительно удобно пользоваться.

Шаг 1: Создайте новый класс
В примере пакета создайте новый файл Kotlin Fish.kt.
В Fish.kt, создать класс данных Fish, с одним свойством, name.
data class Fish (var name: String)
Создать функцию fishExamples(). В fishExamples(), создать рыбу с именем "splashy", все строчные.
fun fishExamples() {
    val fish = Fish("splashy")  // all lowercase
}
Создать main()функцию, которая вызывает fishExamples().
fun main () {
    fishExamples()
}
Скомпилируйте и запустите вашу программу, нажав зеленый треугольник слева от main(). Там нет выхода еще.
Шаг 2: Используйте функцию высшего порядка
with() Функция позволяет сделать одну или несколько ссылок на объект или свойства в более компактном виде.
Использование this. with()на самом деле это функция высшего порядка,
и в lambda вы указываете, что делать с предоставленным объектом.

Используйте with()для заглавных букв имя рыбы в fishExamples().
В фигурных скобках this относится к переданному объекту with().
fun fishExamples() {
    val fish = Fish("splashy")  // all lowercase
    with (fish.name) {
        this.capitalize()
    }
}
Нет вывода, так что добавьте println()вокруг него. И this это неявно и не нужно, так что вы можете удалить его.
fun fishExamples() {
    val fish = Fish("splashy")  // all lowercase
    with (fish.name) {
        println(capitalize())
    }
}
⇒ Splashy
Шаг 3: Создайте функцию высшего порядка
Под капотом with()находится функция высшего порядка.
Чтобы увидеть, как это работает, вы можете сделать свою собственную упрощенную версию,
with()которая работает только для строк.

В Fish.kt, определите функцию, myWith()которая принимает два аргумента.
Аргументы - это объект, с которым нужно работать, и функция, которая определяет операцию.
Конвенция по имени аргумента с функцией block.
В этом случае эта функция не возвращает ничего, что указано с помощью Unit.

fun myWith(name: String, block: String.() -> Unit) {}
Внутри myWith(), block()теперь является функцией расширения String.
Расширяемый класс часто называют объектом-получателем.
Так name же и объект-получатель в этом случае.

В теле myWith(), применять принятый в функции block(), к объекту приемника name.
fun myWith(name: String, block: String.() -> Unit) {
    name.block()
}
В fishExamples(), заменить with()на myWith().
fun fishExamples() {
    val fish = Fish("splashy")  // all lowercase
    myWith (fish.name) {
        println(capitalize())
    }
}
fish.name является аргументом имени и println(capitalize())является блочной функцией.

Запустите программу, и она работает как прежде.
⇒ Splashy
Шаг 4: Изучите больше встроенных расширений
with()Расширение лямбда - очень полезно, и является частью стандартной библиотеки Котлин.
Вот некоторые из других вы могли бы найти под рукой: run(), apply()и let().

run() Функция является расширением , которое работает со всеми типами.
Он принимает одну лямбду в качестве аргумента и возвращает результат выполнения лямбды.

В fishExamples(), позвоните run()на , fish чтобы получить имя.
fish.run {
   name
}
Это просто возвращает name свойство.
Вы можете присвоить это переменной или распечатать.
На самом деле это не полезный пример, поскольку вы можете просто получить доступ к свойству,
но он run()может быть полезен для более сложных выражений.

apply()Функция аналогична run(), но она возвращает измененный объект был применен к вместо результата лямбда.
Это может быть полезно для вызова методов для вновь созданного объекта.

Сделайте копию fishи позвоните, apply()чтобы задать имя новой копии.
val fish2 = Fish(name = "splashy").apply {
     name = "sharky"
}
println(fish2.name)
⇒ акулы

Примечание:run() и apply()похожи, но run()возвращает результат применения функции и apply()возвращает объект после применения функции.

let()Функция аналогична apply(), но она возвращает копию объекта с изменениями.
Это может быть полезно для объединения манипуляций.

Используйте let()для получения имени fish, используйте заглавные буквы,
объедините с ним еще одну строку, получите длину этого результата, добавьте 31 к длине, затем напечатайте результат.
println(fish.let { it.name.capitalize()}
.let{it + "fish"}
.let{it.length}
.let{it + 31})
⇒ 42
В этом примере тип объекта, на который ссылается itis Fish, затем String, Stringснова и наконец Int.

Распечатайте fish после звонка let(), и вы увидите, что он не изменился.
println(fish.let { it.name.capitalize()}
    .let{it + "fish"}
    .let{it.length}
    .let{it + 31})
println(fish)
⇒ 42
рыбы (имя = брызги)

6. Концепция: встроенные функции Inline functions

Лямбды и функции высшего порядка действительно полезны, но есть кое-что, что вы должны знать: лямбды - это объекты.
Лямбда-выражение является экземпляром Function интерфейса, который сам является подтипом Object
Обычно это не проблема, потому что создание объектов и вызов функций не требуют больших накладных расходов,
то есть памяти и процессорного времени.
Но если вы определяете что-то подобное, myWith()которое используете везде, накладные расходы могут сложиться.

Kotlin предоставляет inline способ обработки этого случая, чтобы уменьшить накладные расходы во время выполнения,
добавив немного больше работы для компилятора.
(В inline предыдущем уроке вы немного узнали о разговоре о типах reified.)
Обозначение функции как inline означает, что каждый раз, когда вызывается функция,
компилятор фактически преобразует исходный код в «встроенную» функцию.
То есть компилятор изменит код, чтобы заменить лямбду инструкциями внутри лямбды.

Стоит отметить, что встраивание больших функций увеличивает размер кода,
поэтому лучше всего его использовать для простых функций, которые используются многократно myWith().
Функции расширения из библиотек, о которых вы узнали ранее, помечены inline,
поэтому вам не нужно беспокоиться о создании дополнительных объектов.

7. Задание: узнать об отдельных абстрактных методах SAM = Single Abstract Methods

Один абстрактный метод - это просто интерфейс с одним методом.
Они очень распространены при использовании API, написанных на языке программирования Java,
поэтому для этого есть аббревиатура SAM.
Вот некоторые примеры Runnable, у которых есть один абстрактный метод run(),
и у Callable которых есть один абстрактный метод call().
В Kotlin вы должны вызывать функции, которые постоянно принимают SAM в качестве параметров.
Kotlin позволяет создавать экземпляр объекта, который реализует интерфейс, предшествуя типу с object:.
 Это полезно для передачи параметров в SAM.
JAVA:
 public class JavaRun {
     public static void runNow(Runnable runnable) {
         runnable.run();
     }
 }
 KOTLIN:
 JavaRun.runNow {
         println("Last parameter is a lambda as a Runnable")
     }       // ⇒ Последний параметр - это лямбда в качестве Runnable

 Это основы SAM, Единого Абстрактного Метода.
 Вы можете создать экземпляр, переопределить и сделать вызов SAM с одной строкой кода, используя шаблон:
 Class.singleAbstractMethod { lambda_of_override }

 8. Резюме
 Этот урок рассмотрел лямбды и углубился в функции высшего порядка - ключевые части Kotlin.
 Вы также узнали об аннотациях и помеченных перерывах.

 Используйте аннотации, чтобы указать вещи компилятору. Например:
 @file:JvmName("Foo")
 Используйте помеченные разрывы, чтобы ваш код выходил из вложенных циклов. Например:
 if (i > 10) break@outerLoop // breaks to outerLoop label
 Лямбда может быть очень мощной в сочетании с функциями более высокого порядка.
 Лямбды - это объекты.
 Чтобы избежать создания объекта, вы можете пометить функцию с помощью inline, и компилятор поместит содержимое лямбда-кода в код напрямую.
 Используйте inlineосторожно, но это может помочь уменьшить использование ресурсов вашей программой.
 SAM, Single Abstract Method, является общим шаблоном и упрощен с помощью лямбд. Основной шаблон:
 Class.singleAbstractMethod { lamba_of_override }
 Стандартная библиотека Котлин предоставляет множество полезных функций, в том числе несколько ЗУР, так что узнать , что в нем.
