package example.myapp

fun main() {
    println(matchSeal(SeaLion2()))
    println(matchSeal(Walrus2()))
}

// Шаг 3: Создайте запечатанный класс
//Запечатанный класс является классом , который может быть подклассы, но только внутри файла , в котором она объявлена.
// Если вы попытаетесь создать подкласс класса в другом файле, вы получите ошибку.
//
//Поскольку классы и подклассы находятся в одном файле, Kotlin будет знать все подклассы статически.
// То есть во время компиляции компилятор видит все классы и подклассы и знает,
// что это все они, поэтому компилятор может выполнить дополнительные проверки за вас.

sealed class Seal2
class SeaLion2 : Seal2()
class Walrus2 : Seal2()

fun matchSeal(seal: Seal2): String {
    return when(seal) {
        is Walrus2 -> "walrus"
        is SeaLion2 -> "sea lion"
    }
}

// SealКласс не может быть подклассы в другом файле.
// Если вы хотите добавить больше Seal типов, вы должны добавить их в тот же файл.
// Это делает запечатанные классы безопасным способом представления фиксированного числа типов.
// Например, закрытые классы отлично подходят для возврата успеха или ошибки из сетевого API .