Kotlin Bootcamp для программистов 4:
объектно-ориентированное программирование
Как создать классы и получить доступ к свойствам в Kotlin
Как создавать и использовать конструкторы классов в Котлине
Как создать подкласс и как работает наследование
Об абстрактных классах, интерфейсах и делегировании интерфейсов
Как создавать и использовать классы данных
Как использовать синглтоны, перечисления и запечатанные классы
Что ты будешь делать:
Создать класс со свойствами
Создать конструктор для класса
Создать подкласс
Изучите примеры абстрактных классов и интерфейсов
Создать простой класс данных
Узнайте о синглетах, перечислениях и закрытых классах

2. Терминология
Следующие термины программирования уже должны быть вам знакомы:

Классы - это чертежи объектов. Например, Aquarium класс - это план создания аквариумного объекта.
Объекты являются экземплярами классов; аквариумный объект является одним из актуальных Aquarium.
Свойства - это характеристики классов, такие как длина, ширина и высота объекта Aquarium.
Методы , также называемые функциями-членами , являются функциональными возможностями класса. Методы - это то, что вы можете «делать» с объектом. Например, вы можете объект.fillWithWater()Aquarium
Интерфейс является спецификацией , которая может реализовать класс. Например, очистка является общей для других объектов, кроме аквариумов, и очистка обычно происходит аналогичным образом для различных объектов. Таким образом, вы можете иметь интерфейс с именем, Cleanкоторый определяет clean()метод. AquariumКласс может реализовать Cleanинтерфейс для очистки аквариума с мягкой губкой.
Пакеты - это способ сгруппировать связанный код, чтобы сохранить его организованность или создать библиотеку кода. Как только пакет создан, вы можете импортировать содержимое пакета в другой файл и повторно использовать код и классы в нем.

3. Задача: создать класс
4. Задача: добавить конструкторы классов
Примечание. Параметры основного конструктора могут использоваться в блоках инициализатора.
Любые свойства, используемые в блоках инициализатора, должны быть объявлены ранее.
Шаг 3: Узнайте о вторичных конструкторах
На этом этапе вы узнаете о вторичных конструкторах и добавите их в свой класс.
В дополнение к первичному конструктору, который может иметь один или несколько init блоков,
класс Kotlin также может иметь один или несколько вторичных конструкторов,
позволяющих перегрузить конструктор, то есть конструкторы с разными аргументами.

Примечание: стиль кодирования Kotlin говорит, что каждый класс должен иметь только один конструктор,
используя значения по умолчанию и именованные параметры.
Это связано с тем, что использование нескольких конструкторов приводит к большему количеству путей кода
и вероятности того, что один или несколько путей останутся непроверенными.
Прежде чем писать вторичный конструктор, подумайте, будет ли работать фабричная функция,
чтобы сохранить определение класса чистым.

Примечание. Каждый вторичный конструктор должен сначала вызвать первичный конструктор,
либо напрямую this(), либо косвенно, вызвав другой вторичный конструктор.
Это означает, что любые init блоки в первичном будут вызываться для всех конструкторов,
и весь код в первичном конструкторе будет выполняться первым.
5. Концепция: узнайте о модификаторах видимости
В Kotlin классы, объекты, интерфейсы, конструкторы, функции, свойства и их установщики могут иметь модификаторы видимости :

public означает видимый за пределами класса. По умолчанию все открыто, включая переменные и методы класса.
internal означает, что он будет виден только внутри этого модуля. Модуль представляет собой набор файлов Котлин скомпилированы вместе, например, в библиотеке или приложения.
private означает, что он будет виден только в этом классе (или в исходном файле, если вы работаете с функциями).
protected такой же, как private, но он также будет виден любым подклассам.

Если вам нужно свойство, которое ваш код может читать или записывать, но внешний код может только читать,
вы можете оставить свойство и его получатель открытым и объявить его закрытым, как показано ниже.
var volume: Int
    get() = width * height * length / 1000
    private set(value) {
        height = (value * 1000) / (width * length)
    }
6. Задача: узнать о подклассах и наследовании
Вы должны пометить класс так, open чтобы он мог быть разделен на подклассы.

7. Задача: сравнить абстрактные классы и интерфейсы
Иногда вы хотите определить общее поведение или свойства, которые будут использоваться несколькими связанными классами.
Kotlin предлагает два способа сделать это: интерфейсы и абстрактные классы.
В этой задаче вы создаете абстрактный AquariumFish класс для свойств, общих для всех рыб.
Вы создаете интерфейс FishActionдля определения поведения, общего для всех рыб.

Ни абстрактный класс, ни интерфейс не могут быть созданы сами по себе,
что означает, что вы не можете создавать объекты этих типов напрямую.
Абстрактные классы имеют конструкторы.
Интерфейсы не могут иметь никакой логики конструктора или хранить любое состояние.

Примечание: абстрактные классы всегда открыты; вам не нужно помечать их open.
Свойства и методы абстрактного класса не являются абстрактными, если вы явно не пометите их abstractключевым словом.
Это означает, что подклассы могут использовать их как дано.
Если свойства или методы являются абстрактными, их должны реализовать подклассы.

Когда использовать абстрактные классы против интерфейсов
Приведенные выше примеры просты, но когда у вас много взаимосвязанных классов, абстрактные классы и интерфейсы могут помочь вам сделать ваш проект более чистым, более организованным и простым в обслуживании.

Как отмечено выше, абстрактные классы могут иметь конструкторы, а интерфейсы - нет, но в остальном они очень похожи. Итак, когда вы должны использовать каждый?

Когда вы используете интерфейсы для создания класса, функциональность класса расширяется за счет экземпляров класса, которые он содержит. Композиция имеет тенденцию делать код более легким для повторного использования и рассуждений, чем наследование от абстрактного класса. Кроме того, вы можете использовать несколько интерфейсов в классе, но вы можете использовать подкласс только из одного абстрактного класса.

Примечание. При разработке программ в Kotlin подумайте, как эффективно использовать композицию для создания приложения из небольших компонуемых строительных блоков.

Композиция часто приводит к лучшей инкапсуляции , меньшей связности (взаимозависимости), более чистым интерфейсам и более удобному коду. По этим причинам использование композиции с интерфейсами является предпочтительным дизайном. С другой стороны, наследование от абстрактного класса имеет тенденцию естественного соответствия некоторым проблемам. Поэтому вы должны предпочесть композицию, но когда наследование имеет смысл, Kotlin позволяет вам сделать это тоже!

8. Задача: использовать делегирование интерфейса
В предыдущей задаче были представлены абстрактные классы, интерфейсы и идея композиции.
 Делегирование интерфейса - это сложный метод,
 в котором методы интерфейса реализуются вспомогательным (или делегирующим) объектом,
 который затем используется классом.
 Этот метод может быть полезен, когда вы используете интерфейс в ряду не связанных между собой классов:
 вы добавляете необходимые функциональные возможности интерфейса в отдельный вспомогательный класс,
 и каждый из классов использует экземпляр вспомогательного класса для реализации функциональности.

Делегирование интерфейса является мощным, и вам следует подумать, как его использовать всякий раз,
когда вы можете использовать абстрактный класс на другом языке.
Он позволяет использовать композицию для включения поведения,
вместо того, чтобы требовать множество подклассов, каждый из которых специализируется по-своему.
9. Задача: создать класс данных
Класс данных похож на a structв некоторых других языках - он существует главным образом для хранения некоторых данных
- но объект класса данных все еще является объектом.
Объекты класса данных Kotlin имеют некоторые дополнительные преимущества, такие как утилиты для печати и копирования.
В этой задаче вы создадите простой класс данных и узнаете о поддержке, которую Kotlin предоставляет для классов данных.
Примечание. Хотя Хотя в некоторых языках они похожи на структуры, помните, что объекты класса данных являются объектами.
 Присвоение объекта класса данных другой переменной копирует ссылку на этот объект, а не содержимое.
  Чтобы скопировать содержимое в новый объект, используйте copy()метод.

Предупреждение: The copy(), equals()и другие утилиты класса данных только эталонные свойства ,
 определенные в первичном конструкторе.
 Шаг 2. Используйте деструктуризацию
 val (rock, wood, diver) = decoration
 10. Задание: узнать о синглетах, перечислениях и закрытых классах
 Шаг 1: Напомним синглтон-классы
 object GoldColor : FishColor {
    override val color = "gold"
 }
 Шаг 2: Создать перечисление
 Kotlin также поддерживает перечисления,
 которые позволяют перечислять что-либо и ссылаться на него по имени, как и в других языках.
 Объявите enum, добавив префикс объявления к ключевому слову enum.
 Для базового объявления перечисления нужен только список имен,
 но вы также можете определить одно или несколько полей, связанных с каждым именем.

Перечисления немного похожи на синглтоны - в перечислении может быть только одно и только одно из каждого значения.
Например, может быть только один Color.RED, один Color.GREEN и один Color.BLUE.
В этом примере значения RGB присваиваются rgbсвойству для представления компонентов цвета.
Вы также можете получить порядковый номер перечисления, используя ordinal свойство, и его имя, используя name свойство.

Шаг 3: Создайте запечатанный класс
Запечатанный класс является классом , который может быть подклассы, но только внутри файла , в котором она объявлена.
Если вы попытаетесь создать подкласс класса в другом файле, вы получите ошибку.
Поскольку классы и подклассы находятся в одном файле, Kotlin будет знать все подклассы статически.
То есть во время компиляции компилятор видит все классы и подклассы и знает, что это все они,
поэтому компилятор может выполнить дополнительные проверки за вас.

sealed class Seal
class SeaLion : Seal()
class Walrus : Seal()

fun matchSeal(seal: Seal): String {
   return when(seal) {
       is Walrus -> "walrus"
       is SeaLion -> "sea lion"
   }
}

11. Резюме
Этот урок охватил много вопросов.
Хотя многое из этого должно быть знакомо с другими объектно-ориентированными языками программирования,
Kotlin добавляет некоторые функции, чтобы сделать код кратким и читабельным.

Классы и конструкторы
Определите класс в Kotlin, используя class.
Kotlin автоматически создает сеттеры и геттеры для свойств.
Определите первичный конструктор непосредственно в определении класса.
Например:
class Aquarium(var length: Int = 100, var width: Int = 20, var height: Int = 40)
Если первичному конструктору требуется дополнительный код, запишите его в один или несколько init блоков.
Класс может определять один или несколько вторичных конструкторов, используя constructor,
но стиль Kotlin - вместо этого использовать фабричную функцию.

Модификаторы видимости и подклассы
Все классы и функции в Котлин являются public по умолчанию,
но вы можете использовать модификаторы , чтобы изменить видимость internal, private, или protected.

Чтобы создать подкласс, родительский класс должен быть помечен open.
Чтобы переопределить методы и свойства в подклассе, методы и свойства должны быть отмечены open в родительском классе.

Запечатанный класс может быть разделен на подклассы только в том же файле, где он определен.
Создайте запечатанный класс, добавив к объявлению префикс sealed.

Классы данных, синглтоны и перечисления
Создайте класс данных, добавив префикс объявления к data.
Деструктурирование - это сокращение для присвоения свойств dataобъекта отдельным переменным.

Создайте одноэлементный класс, используя object вместо class.
Определите перечисление, используя enum class.

Абстрактные классы, интерфейсы и делегирование
Абстрактные классы и интерфейсы - это два способа поделиться общим поведением между классами.
Абстрактный класс определяет свойства и поведение, но оставляет реализацию на подклассы.
Интерфейс определяет поведение, и может предоставить стандартные реализации для некоторых или все поведения.
Когда вы используете интерфейсы для создания класса, функциональность класса расширяется за счет экземпляров класса, которые он содержит.

Делегирование интерфейса использует композицию, но также делегирует реализацию классам интерфейса.
Композиция - это мощный способ добавить функциональность в класс с помощью делегирования интерфейса. В целом состав предпочтительнее, но наследование от абстрактного класса лучше подходит для некоторых задач.

12. Узнайте больше
Kotlin соглашения о кодировании
Котлин идиомы
Классы и наследство
Конструкторы
Заводские функции
Свойства и поля
Модификаторы видимости
Абстрактные классы
Интерфейсы
Делегация
Классы данных
равенство
деструктурирующие
Объявления объекта
Enum классы
Запечатанные классы
Обработка необязательных ошибок с использованием запечатанных классов Kotlin