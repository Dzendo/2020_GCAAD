Рефакторинг на Котлин
В этом фрагменте кода вы узнаете, как выполнить рефакторинг вашего кода с Java на Kotlin. Вы также узнаете, что такое соглашения по языку Kotlin и как гарантировать, что код, который вы пишете, следует им.

Эта кодовая метка подходит любому разработчику, использующему Java, который рассматривает возможность миграции своего проекта на Kotlin. Мы начнем с пары классов Java, которые вы преобразуете в Kotlin с помощью IDE. Затем мы посмотрим на преобразованный код и посмотрим, как мы можем улучшить его, сделав его более идиоматичным и избежав распространенных ошибок.

Что вы узнаете
Вы узнаете, как реорганизовать Java в Kotlin. При этом вы изучите следующие особенности и понятия языка Kotlin:

Обращаемость обнуляемость
Реализация синглетонов
Классы данных
Обработка строк
Элвис оператор
деструктурирующие
Свойства и свойства основы
Аргументы по умолчанию и именованные параметры
Работа с коллекциями
Функции расширения
Функции и параметры верхнего уровня
let, apply, withИ runключевые слова

В нашем Userклассе Java у нас было два свойства: firstNameи lastName.
Каждый из них имеет метод получения и установки, что делает его значение изменяемым.
Ключевое слово Kotlin для изменяемых переменных - var это то, что конвертер использует var для каждого из этих свойств.
Если бы у наших свойств Java были только геттеры, они были бы неизменными и были бы объявлены как val переменные.
val похоже на final ключевое слово в Java.

Одним из ключевых отличий между Kotlin и Java является то, что Kotlin явно указывает,
может ли переменная принимать нулевое значение.
Это делается путем добавления ` ?` к объявлению типа.

Наши User свойства Java могут принимать нулевые значения, поэтому каждое из них помечается как обнуляемое с помощью String?.
Если вы аннотируете своих членов Java как ненулевые (используя org.jetbrains.annotations.NotNullили androidx.annotation.NonNull),
конвертер распознает это и сделает поля не равными нулю в Kotlin.

5. Инициализация объекта, сопутствующий объект и синглтоны
Давайте посмотрим, что сделал автоматический конвертер:

initБлок был добавлен (Repository.kt # L33)
staticПоле теперь часть companion objectблока (Repository.kt # L51)
Список usersобнуляется, так как объект не был создан во время объявления (Repository.kt # L9)
Этот getFormattedUserNames()метод теперь называется свойством formattedUserNames(Repository.kt # L11)
Итерация по списку пользователей имеет синтаксис, отличный от синтаксиса Java (Repository.kt # L14)

В Kotlin первичный конструктор не может содержать никакого кода, поэтому код инициализации помещается в init блоки.
Функциональность такая же.
Большая часть init кода обрабатывает инициализирующие свойства.
Это также может быть сделано в декларации собственности.
Например, в версии Kotlin нашего Repository класса мы видим, что свойство users было инициализировано в объявлении.
Свойства и методы Котлинаstatic
В Java мы используем staticключевое слово для полей или функций, чтобы сказать, что они принадлежат классу, но не экземпляру класса. Вот почему мы создали INSTANCEстатическое поле в нашем Repositoryклассе. Эквивалентом Котлина для этого является companion objectблок. Здесь вы также объявите статические поля и статические функции. Конвертер создал и переместил INSTANCEполе сюда.

Обработка синглетонов
Поскольку нам нужен только один экземпляр Repositoryкласса, мы использовали шаблон синглтона в Java. С Kotlin вы можете применить этот шаблон на уровне компилятора, заменив classключевое слово на object.

Удалите приватный конструктор и сопутствующий объект и замените определение класса на object Repository.
При использовании objectкласса мы просто вызываем функции и свойства непосредственно для объекта, например так:

val users = Repository.users
деструктурирующие
Kotlin позволяет разложить объект на несколько переменных, используя синтаксис, называемый объявлением деструктурирования . Мы создаем несколько переменных и можем использовать их независимо.

Например, классы данных поддерживают деструктурирование, поэтому автоматический преобразователь деструктурирует Userобъект в forцикле. Это позволяет напрямую работать с firstNameи lastNameзначениями:


for ((firstName, lastName) in users!!) {
       val name: String?

       if (lastName != null) {
          if (firstName != null) {
                name = "$firstName $lastName"
          }
       ...


12. Wrap up
В этом коде мы рассмотрели основы, необходимые для начала рефакторинга вашего кода с Java на Kotlin.
Этот рефакторинг не зависит от вашей платформы разработки и помогает гарантировать,
что код, который вы пишете, идиоматичен.