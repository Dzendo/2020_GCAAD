# Using Kotlin Coroutines in your Android app

This folder contains the source code for the [Kotlin Coroutines codelab](https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html).

## License

    Copyright 2018 Google LLC

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

1. Прежде чем начать
val plants: LiveData<List<Plant>> = plantDao.getPlants()
LiveDataБудет обновляться с помощью LiveDataстроителя и сопрограмм с дополнительной логикой сортировки:
val plants: LiveData<List<Plant>> = liveData<List<Plant>> {
   val plantsLiveData = plantDao.getPlants()
   val customSortOrder = plantsListSortOrderCache.getOrAwait()
   emitSource(plantsLiveData.map { plantList -> plantList.applySort(customSortOrder) })
}
Вы также реализуете ту же логику с Flow:
private val customSortFlow = plantsListSortOrderCache::getOrAwait.asFlow()

val plantsFlow: Flow<List<Plant>>
   get() = plantDao.getPlantsFlow()
       .combine(customSortFlow) { plants, sortOrder ->
           plants.applySort(sortOrder)
       }
       .flowOn(defaultDispatcher)
       .conflate()

2. Подготовка к настройке
$ git clone https://github.com/googlecodelabs/kotlin-coroutines.git
3. Запустите начальный пример приложения.
start « Выполнить»
При первом запуске приложения появляется список карточек,
на каждой из которых отображается название и изображение определенного растения:
У каждого из них Plantесть growZoneNumber атрибут
Это приложение использует компоненты архитектуры для разделения кода пользовательского интерфейса
в логике приложения MainActivity и PlantListFragment от нее в PlantListViewModel.
PlantRepository обеспечивает мост между ViewModel и PlantDao,
который обращается к Roomбазе данных для возврата списка Plantобъектов.
Затем пользовательский интерфейс берет этот список растений и отображает их в виде RecyclerViewсетки.
PlantListViewModel.kt
val plants: LiveData<List<Plant>> = growZone.switchMap { growZone ->
    if (growZone == NoGrowZone) {
        plantRepository.plants
    } else {
        plantRepository.getPlantsWithGrowZone(growZone)
    }
}
Plant.kt
inline class GrowZone(val number: Int)
val NoGrowZone = GrowZone(-1)
PlantDao.kt
@Query("SELECT * FROM plants ORDER BY name")
fun getPlants(): LiveData<List<Plant>>

@Query("SELECT * FROM plants WHERE growZoneNumber = :growZoneNumber ORDER BY name")
fun getPlantsWithGrowZoneNumber(growZoneNumber: Int): LiveData<List<Plant>>
PlantRepository.kt
val plants = plantDao.getPlants()

fun getPlantsWithGrowZone(growZone: GrowZone) =
    plantDao.getPlantsWithGrowZoneNumber(growZone.number)

4. Растения с индивидуальной сортировкой
Список настраиваемого порядка сортировки состоит из этих четырех растений:
апельсина, подсолнечника, винограда и авокадо.
Обратите внимание, как они появляются сначала в списке,
а затем следуют остальные растения в алфавитном порядке.

5. Получение порядка сортировки
PlantRepository.kt
private var plantsListSortOrderCache =
    CacheOnSuccess(onErrorFallback = { listOf<String>() }) {
        plantService.customPlantSortOrder()
    }
CacheOnSuccess служебный класс, предоставленный в sunflower модуле
PlantRepository.kt
private fun List<Plant>.applySort(customSortOrder: List<String>): List<Plant> {
    return sortedBy { plant ->
        val positionForItem = customSortOrder.indexOf(plant.plantId).let { order ->
            if (order > -1) order else Int.MAX_VALUE
        }
        ComparablePair(positionForItem, plant.name)
    }
}
Эта функция расширения изменит порядок списка, поместив те, Plants которые находятся в customSortOrder начале списка.

6. Построение логики с помощью LiveData
PlantRepository.kt
val plants: LiveData<List<Plant>> = liveData<List<Plant>> {
   val plantsLiveData = plantDao.getPlants()
   val customSortOrder = plantsListSortOrderCache.getOrAwait()
   emitSource(plantsLiveData.map {
       plantList -> plantList.applySort(customSortOrder)
   })
}

fun getPlantsWithGrowZone(growZone: GrowZone) = liveData {
    val plantsGrowZoneLiveData = plantDao.getPlantsWithGrowZoneNumber(growZone.number)
    val customSortOrder = plantsListSortOrderCache.getOrAwait()
    emitSource(plantsGrowZoneLiveData.map { plantList ->
        plantList.applySort(customSortOrder)
    })
}
7. liveData: изменение значений
Мы можем использовать withContextдля переключения на другой диспетчер только для лямбды,
а затем возобновить работу с диспетчером, с которого мы начали.

Добавьте следующее в PlantRepository:

PlantRepository.kt
@AnyThread
suspend fun List<Plant>.applyMainSafeSort(customSortOrder: List<String>) =
    withContext(defaultDispatcher) {
        this@applyMainSafeSort.applySort(customSortOrder)

PlantRepository.kt
fun getPlantsWithGrowZone(growZone: GrowZone) =
   plantDao.getPlantsWithGrowZoneNumber(growZone.number)
       .switchMap { plantList ->
           liveData {
               val customSortOrder = plantsListSortOrderCache.getOrAwait()
               emit(plantList.applyMainSafeSort(customSortOrder))
           }
       }
По сравнению с предыдущей версией, как только пользовательский порядок сортировки получен из сети,
его можно использовать с новым основным сейфом applyMainSafeSort.
Этот результат затем передается объекту switchMap как новое значение, возвращаемое объектом getPlantsWithGrowZone.

Теперь давайте посмотрим, как этот код реализован с помощью Flow, и сравним реализации.

https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb

https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html#0

https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html#0

https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html#0

https://codelabs.developers.google.com/codelabs/advanced-kotlin-coroutines/#0

Чтобы решить такие проблемы, Kotlin представляет особый вид класса под названием an inline class,
который объявляется путем размещения inlineмодификатора перед именем класса:
inline class Password(val value: String)
val securePassword = Password("Don't try this in production")
Встроенный класс должен иметь единственное свойство, инициализированное в основном конструкторе.
Во время выполнения экземпляры встроенного класса будут представлены с использованием этого единственного свойства
(см. Подробности о представлении среды выполнения ниже ):
val securePassword = Password("Don't try this in production")
// Фактического создания экземпляра класса 'Password' не происходит
// Во время выполнения securePassword содержит только String

Члены
Встроенные классы поддерживают некоторые функции обычных классов.
В частности, им разрешено объявлять свойства и функции:
inline class Name(val s: String) {
    val length: Int
        get() = s.length

    fun greet() {
        println("Hello, $s")
    }
}

fun main() {
    val name = Name("Kotlin")
    name.greet() // method `greet` is called as a static method
    println(name.length) // property getter is called as a static method
}
Однако существуют некоторые ограничения для встроенных членов класса:
встроенные классы не могут иметь блоки инициализации
встроенные свойства класса не могут иметь резервных полей
из этого следует, что встроенные классы могут иметь только простые вычислимые свойства
(без lateinit / делегированных свойств)

Для переключения между любым диспетчером сопрограммы используют withContext.
Вызов withContextпереключается на другой диспетчер только для лямбды,
затем возвращается диспетчеру, который вызвал его с результатом этой лямбды.

По умолчанию Котлин сопрограммы предоставляет три диспетчеры: Main, IO, и Default.
Диспетчер ввода-вывода оптимизирован для работы ввода-вывода, такой как чтение из сети или с диска,
в то время как диспетчер по умолчанию оптимизирован для задач, интенсивно использующих ЦП.

https://codelabs.developers.google.com/codelabs/advanced-kotlin-coroutines/#7

8. Знакомство с Flow

API-интерфейсы Flow являются экспериментальными
Многие основные API-интерфейсы в Flowнастоящее время помечены как экспериментальные и,
вероятно, будут изменены до стабильного выпуска.
Эта кодовая лаборатория использует множество экспериментальных API и будет обновляться по мере разработки API.

Мы собираемся построить ту же логику, используя Flow from kotlinx-coroutines.
Прежде чем мы это сделаем, давайте посмотрим, что такое поток и как вы можете включить его в свое приложение.

Поток - это асинхронная версия последовательности , типа коллекции, значения которой создаются лениво.
Как и последовательность, поток создает каждое значение по запросу всякий раз, когда оно необходимо,
и потоки могут содержать бесконечное количество значений.

Итак, почему Котлин представил новый Flow тип и чем он отличается от обычной последовательности?
Ответ кроется в магии async. Flow включает полную поддержку сопрограмм.
Это означает, что вы можете создавать, преобразовывать и Flow использовать сопрограммы.
Вы также можете контролировать параллелизм,
что означает декларативную координацию выполнения нескольких сопрограмм с помощью Flow.

Это открывает множество интересных возможностей.

Поток - это асинхронная последовательность значений
Flowгенерирует значения по одному (вместо всех сразу), которые могут генерировать значения из асинхронных операций,
таких как сетевые запросы, вызовы базы данных или другой асинхронный код.
Он поддерживает сопрограммы во всем своем API, поэтому вы также можете преобразовывать поток с помощью сопрограмм!

Flowможет использоваться в стиле полностью реактивного программирования.
Если вы использовали что-то подобное RxJava раньше, Flow предоставляет аналогичные функции.
Логика приложения может быть выражена сжато путем преобразования потока с функциональными операторами,
такими как map, flatMapLatest, combine, и так далее.

Flowтакже поддерживает функции приостановки для большинства операторов.
Это позволяет выполнять последовательные асинхронные задачи внутри оператора, например map.
Использование приостанавливающих операций внутри потока часто приводит к тому,
что код становится короче и легче читается, чем эквивалентный код в полностью реактивном стиле.

В этой кодовой лаборатории мы собираемся изучить использование обоих подходов.

Как работает поток
Чтобы привыкнуть к тому, как Flow создает значения по запросу (или лениво),
взгляните на следующий поток, который генерирует значения (1, 2, 3)
и печатает до, во время и после создания каждого элемента.

fun makeFlow() = flow {
   println("sending first value")
   emit(1)
   println("first value collected, sending another value")
   emit(2)
   println("second value collected, sending a third value")
   emit(3)
   println("done")
}

scope.launch {
   makeFlow().collect { value ->
       println("got $value")
   }
   println("flow is completed")
}
Если вы запустите это, он выдаст такой вывод:

отправка первого значения
получил 1
первое полученное значение, отправка другого значения
получил 2
Собирается второе значение, отправляется третье значение
получил 3
сделано
поток завершен
Вы можете видеть, как выполнение отскакивает между collect лямбдой и flow построителем.
Каждый раз, когда вызывается построитель потока emit, он suspendsдо тех пор,
пока элемент не будет полностью обработан.
Затем, когда из потока запрашивается другое значение,
оно будет resumesс того места, на котором остановилось,
до тех пор, пока не вызовет emit снова.
Когда flow построитель завершает работу, выполнение Flowотменяется и collect возобновляется,
позволяя и вызывающая сопрограмма печатает «поток завершен».

Призыв к collect очень важен.
Flow использует операторы приостановки,
 например, collect вместо того, чтобы открывать Iterator интерфейс,
  чтобы он всегда знал, когда он активно используется.
   Что еще более важно, он знает,
    когда вызывающий объект не может запросить больше значений,
    поэтому он может очистить ресурсы.

Flow строится с нуля с использованием сопрограмм.
 При использовании suspend и resume механизма сопрограмм,
  они могут синхронизировать выполнение производителя ( flow) с потребителем ( collect).

Если вы использовали реактивные потоки и знакомы с концепцией противодавления,
 это реализуется Flow путем приостановки сопрограммы.

Когда запускается поток
В Flowприведенном выше примере запускается при запуске collect оператора.
 Создание нового Flowпу тем вызова flow построителя или других API не вызывает выполнения какой-либо работы.
  Оператор приостановки collect называется оператором терминала в Flow.
   Существуют и другие операторы терминала приостановки,
    такие как toList, firstи single поставляемые с kotlinx-coroutines,
     и вы можете создать свой собственный.

По умолчанию Flow выполнит:

--Каждый раз, когда оператор терминала применяется без запоминания последнего запуска
--До отмены оператора терминала
--Когда последнее значение было полностью обработано и было запрошено другое значение
Эти правила являются поведением по умолчанию,Flow
 и можно создать объект, Flow который имеет память,
  не перезапускается для каждого оператора терминала
   и выполняется независимо от сбора со встроенными или настраиваемыми преобразованиями файла Flow.

Выполнение Flow называется сбором потока.
 По умолчанию a Flow ничего не будет делать, пока он не будет собран,
  что означает применение любого оператора терминала .

myFlow.toList() // toList collects this flow and adds the values to a List

Мы также говорим , индивидуальное значение собранно из Flow терминального оператора.

myFlow.collect { item -> println("$item has been collected") }

Благодаря этим правилам объект Flow может участвовать в структурированном параллелизме,
 и запускать длительные сопрограммы из файла Flow.
  Нет никаких шансов, что Flow будет утечка ресурсов,
   поскольку они всегда очищаются с использованием правил совместной отмены сопрограмм,
    когда вызывающий объект отменяется.

Давайте изменим приведенный выше поток, чтобы с помощью take оператора взглянуть только на первые два элемента,
 а затем соберем его дважды.

scope.launch {
   val repeatableFlow = makeFlow().take(2)  // we only care about the first two elements
   println("first collection")
   repeatableFlow.collect()
   println("collecting again")
   repeatableFlow.collect()
   println("second collection completed")
}
Запустив этот код, вы увидите следующий результат:

первая коллекция
отправка первого значения
первое полученное значение, отправка другого значения
собирать снова
отправка первого значения
первое полученное значение, отправка другого значения
второй сбор завершен
При flowкаждом collect вызове лямбда начинается сверху.
 Это важно, если поток выполняет дорогостоящую работу,
  например, делает сетевой запрос.
   Кроме того, поскольку мы применили take(2)оператор, поток выдаст только два значения.
    Он не возобновит лямбда-выражение потока снова после второго вызова emit,
     поэтому строка «второе значение собрано ...» никогда не будет печататься.

По умолчанию a Flow будет перезапускаться сверху каждый раз, когда применяется оператор терминала.
 Это важно, если он Flow выполняет дорогостоящую работу, например, делает сетевой запрос.

9. Асинхронность с потоком
Ладно, Flow как ленивый Sequence, но как еще асинхронный?
 Давайте посмотрим на пример асинхронной последовательности - наблюдение за изменениями в базе данных.

 В этом примере нам нужно координировать данные,
 созданные в пуле потоков базы данных, с наблюдателями, которые живут в другом потоке,
  таком как основной поток или поток пользовательского интерфейса.
   И поскольку мы будем выдавать результаты повторно по мере изменения данных,
    этот сценарий естественным образом подходит для шаблона асинхронной последовательности.
 Представьте, что вам поручили написать Roomинтеграцию для Flow.
  Если вы начали с существующей поддержки запросов приостановки в Room,
   вы могли бы написать что-то вроде этого:

// This code is a simplified version of how Room implements flow
fun <T> createFlow(query: Query, tables: List<Tables>): Flow<T> = flow {
    val changeTracker = tableChangeTracker(tables)

    while(true) {
        emit(suspendQuery(query))
        changeTracker.suspendUntilChanged()
    }
}

Этот код использует две воображаемые функции приостановки для создания Flow:

-suspendQuery- функция main-safe, которая запускает обычный Roomзапрос приостановки
-suspendUntilChanged - функция, которая приостанавливает выполнение сопрограммы, пока одна из таблиц не изменится
При сборе поток изначально emitsявляется первым значением запроса.
Как только это значение будет обработано, поток возобновится и suspendUntilChanged вызовет,
 что будет делать, как сказано - приостановить поток, пока одна из таблиц не изменится.
 В этот момент в системе ничего не происходит, пока одна из таблиц не изменится и поток не возобновится.

Когда поток возобновляется, он делает еще один безопасный запрос и emits результаты.
 Этот процесс продолжается бесконечно в бесконечном цикле.

Поток и структурированный параллелизм

Но подождите - мы не хотим утечки работы!
 Сопрограмма сама по себе не очень дорогая, но она постоянно просыпается для выполнения запроса к базе данных.
  Утечка - довольно дорогая вещь.
Несмотря на то, что мы создали бесконечный цикл, он Flowпомогает нам, поддерживая структурированный параллелизм.
Единственный способ получить значения или выполнить итерацию по потоку - использовать оператор терминала.
 Поскольку все операторы терминала являются функциями приостановки,
  работа привязана к времени жизни вызывающей их области.
   Когда область видимости отменяется, поток автоматически отменяет себя,
    используя обычные правила совместной отмены сопрограмм.
     Таким образом, даже если мы написали бесконечный цикл в нашем построителе потоков,
      мы можем безопасно использовать его без утечек благодаря структурированному параллелизму.

Flow поддерживает структурированный параллелизм
Поскольку поток позволяет использовать значения только с операторами терминала,
 он может поддерживать структурированный параллелизм.
Когда потребитель потока отменяется, отменяется все Flow.
 Из-за структурированного параллелизма невозможно получить утечку сопрограммы с промежуточного шага.

  10. Использование Flow с комнатой
На этом шаге вы узнаете , как использовать Flowс Roomи подключить его к UI.
Этот шаг является общим для многих случаев использования Flow.
При таком использовании Flow from Room действует как наблюдаемый запрос к базе данных, аналогичный запросу LiveData.

Обновите Дао
Для начала откройте PlantDao.ktи добавьте два новых запроса, которые возвращают Flow<List<Plant>>:

PlantDao.kt
@Query("SELECT * from plants ORDER BY name")
fun getPlantsFlow(): Flow<List<Plant>>

@Query("SELECT * from plants WHERE growZoneNumber = :growZoneNumber ORDER BY name")
fun getPlantsWithGrowZoneNumberFlow(growZoneNumber: Int): Flow<List<Plant>>

Обратите внимание, что, за исключением возвращаемых типов, эти функции идентичны LiveData версиям.
Но мы разработаем их бок о бок, чтобы сравнить.

В этой кодовой лаборатории мы собираемся построить такое же преобразование базы данных,
 используя LiveData конструктор и Flow.
  В производственное приложение вы должны включить только один из них,
   но полезно сравнить их друг с другом, чтобы увидеть, как они работают.

Указав Flowтип возвращаемого значения, Roomвыполняет запрос со следующими характеристиками:

--Main-safety - запросы с Flow возвращаемым типом всегда выполняются Roomисполнителями, поэтому они всегда безопасны для main.
 Вам не нужно ничего делать в вашем коде, чтобы заставить их работать вне основного потока.
-- Наблюдает за изменениями -Room автоматически наблюдает за изменениями и передает новые значения в поток.
-- Асинхронная последовательность -Flow выдает полный результат запроса при каждом изменении и не вводит никаких буферов.
 Если вы вернете a Flow<List<T>>, поток выдает a, List<T> который содержит все строки из результата запроса.
  Он будет выполняться как последовательность - выдавать по одному результату запроса и приостанавливаться, пока не будет запрошен следующий.
-- Отменяемый - когда область, собирающая эти потоки, Roomот меняется , отменяет наблюдение за этим запросом.

В совокупности это Flow отличный тип возвращаемого значения
 для наблюдения за базой данных на уровне пользовательского интерфейса.

Обновите репозиторий

PlantRepository.kt
val plantsFlow: Flow<List<Plant>>
   get() = plantDao.getPlantsFlow()

fun getPlantsWithGrowZoneFlow(growZoneNumber: GrowZone): Flow<List<Plant>> {
   return plantDao.getPlantsWithGrowZoneNumberFlow(growZoneNumber.number)
}
На данный момент мы просто передаем Flowзначения вызывающей стороне. Это точно так же, как когда мы начали эту кодовую лабораторию с передачи файла LiveDataв ViewModel.

Обновите ViewModel
В PlantListViewModel.kt, давайте начнем с простого и просто разоблачить plantsFlow. Мы вернемся и добавим переключатель зоны роста в потоковую версию в следующих нескольких шагах.

PlantListViewModel.kt
// add a new property to plantListViewModel

val plantsUsingFlow: LiveData<List<Plant>> = plantRepository.plantsFlow.asLiveData()
Опять же, мы будем использовать LiveDataversion ( val plants) для сравнения по мере продвижения.

Поскольку мы хотим сохранить LiveDataслой пользовательского интерфейса для этой кодовой таблицы, мы будем использовать asLiveDataфункцию расширения для преобразования нашего Flowв LiveData. Как и LiveDataконструктор, это добавляет настраиваемый тайм-аут к LiveDataсгенерированному. Это приятно, потому что не позволяет нам перезапускать наш запрос каждый раз при изменении конфигурации (например, при ротации устройства).

asLiveDataОператор преобразует Flowв LiveDataс настраиваемым тайм - аут.

Как и в случае со liveDataсборщиком, тайм-аут поможет Flowвыжить перезапуску. Если другой экран наблюдает до истечения тайм-аута, Flowон не будет отменен.

Поскольку поток обеспечивает безопасность основного и возможность отмены, вы можете полностью передать его Flowна уровень пользовательского интерфейса, не преобразовывая его в LiveData. Однако в этой кодовой лаборатории мы будем использовать LiveDataслой пользовательского интерфейса.

Также в ViewModel, добавьте обновление кеша в initблок. Этот шаг пока необязателен, но если вы очистите кеш и не добавите этот вызов, вы не увидите никаких данных в приложении.

PlantListViewModel.kt
init {
    clearGrowZoneNumber()  // keep this

    // fetch the full plant list
    launchDataLoad { plantRepository.tryUpdateRecentPlantsCache() }
}
Обновить фрагмент
Откройте PlantListFragment.ktи измените subscribeUiфункцию, чтобы она указывала на наш новый plantsUsingFlow LiveData.

PlantListFragment.kt
private fun subscribeUi(adapter: PlantAdapter) {
   viewModel.plantsUsingFlow.observe(viewLifecycleOwner) { plants ->
       adapter.submitList(plants)
   }
}
Запустите приложение с Flow
Если вы снова запустите приложение, вы увидите, что теперь вы загружаете данные с помощью Flow! Поскольку мы еще не реализовали switchMap, опция фильтра ничего не делает.

На следующем шаге мы рассмотрим преобразование данных в файл Flow.
 Ничего не сортирует и не фильтрует Стартует работает

 11. Декларативное объединение потоков.
 На этом шаге вы примените порядок сортировки к plantsFlow. Мы сделаем это с помощью декларативного API flow.

 Что такое декларативное?
 Декларативный - это стиль API, который означает описание того,
  что ваша программа должна делать, а не того, как это делать.
   Одним из наиболее широко известных декларативных языков является SQL,
    который позволяет разработчикам выражать то, что они хотели бы, чтобы база данных запрашивала,
     а не то, как выполнять запрос.
 Используя такие преобразования, как map, combineили mapLatest,
  мы можем выразить, как мы хотели бы преобразовывать каждый элемент,
   когда он движется по потоку декларативно.
    Он даже позволяет нам декларативно выражать параллелизм, что действительно может упростить код.
     В этом разделе вы увидите, как с помощью операторов можно указать Flow запуск двух сопрограмм
      и декларативно объединить их результаты.

 Для начала откройте PlantRepository.ktи определите новый частный поток под названием customSortFlow:
PlantRepository.kt
private val customSortFlow = flow { emit(plantsListSortOrderCache.getOrAwait()) }
Это определяет объект, Flowкоторый при сборе будет вызывать getOrAwaitи emitпорядок сортировки.
Поскольку этот поток генерирует только одно значение,
 вы также можете построить его непосредственно из getOrAwait функции, используя asFlow.
/ Create a flow that calls a single function
private val customSortFlow = plantsListSortOrderCache::getOrAwait.asFlow()
Этот код создает новый объект, Flow который вызывает getOrAwait
 и передает результат как первое и единственное значение.
  Он делает это, ссылаясь на метод getOrAwait, используя :: и вызывая asFlowполученный Function объект.
Оба этих потока делают одно и то же, вызывают getOrAwait и передают результат перед завершением.

Декларативно объединить несколько потоков

Теперь, когда у нас есть два потока, customSortFlowи plantsFlow, давайте объединить их декларативно!
Добавьте combineоператора в plantsFlow:
PlantRepository.kt
private val customSortFlow = plantsListSortOrderCache::getOrAwait.asFlow()

val plantsFlow: Flow<List<Plant>>
   get() = plantDao.getPlantsFlow()
       // When the result of customSortFlow is available,
       // this will combine it with the latest value from
       // the flow above.  Thus, as long as both `plants`
       // and `sortOrder` are have an initial value (their
       // flow has emitted at least one value), any change
       // to either `plants` or `sortOrder`  will call
       // `plants.applySort(sortOrder)`.
       .combine(customSortFlow) { plants, sortOrder ->
          plants.applySort(sortOrder)
       }
combine Оператор объединяет два потока вместе.
 Оба потока будут работать в своей собственной сопрограмме,
  а затем всякий раз, когда какой-либо из потоков создает новое значение,
   преобразование будет вызываться с последним значением из любого потока.
Используя combine, мы можем комбинировать поиск в кэшированной сети с нашим запросом к базе данных.
Оба они будут работать на разных сопрограммах одновременно.
Это означает, что пока Room запускает сетевой запрос, Retrofit может запустить сетевой запрос.
 Затем, как только результат будет доступен для обоих потоков, он вызовет combine лямбду,
  в которой мы применяем загруженный порядок сортировки к загруженным растениям.

Преобразование combine запустит одну сопрограмму для каждого объединяемого потока.
 Это позволяет одновременно комбинировать два потока.
Он объединит потоки «справедливым» образом, что означает, что все они получат шанс произвести значение
 (даже если один из них будет получен в рамках жесткого цикла).

 Чтобы изучить, как combine работает оператор, измените его так,
  customSortFlow чтобы он испускал дважды с существенной задержкой, onStartнапример:
 // Create a flow that calls a single function
 private val customSortFlow = suspend {() }.asFlow()
    .onStart {
        emit(listOf())
        delay(1500)
    }
Преобразование onStart произойдет,
 когда наблюдатель прослушивает перед другими операторами и может выдавать значения-заполнители.
  Итак, здесь мы генерируем пустой список, откладываем вызов getOrAwaitна 1500 мс,
   а затем продолжаем исходный поток.
    Если вы запустите приложение сейчас, вы увидите,
     что запрос к базе данных Room сразу же возвращается в сочетании с пустым списком
      (что означает сортировку по алфавиту).
       Затем примерно через 1500 мс он применяет пользовательскую сортировку.

Прежде чем продолжить работу с codelab, удалите onStart преобразование из файла customSortFlow.

Вы можете использовать onStart для запуска кода приостановки перед запуском потока.
 Он может даже emit добавлять дополнительные значения в поток,
  поэтому вы можете использовать его для передачи Loading состояния в потоке сетевых запросов.

Расход и основная безопасность
Flow может вызывать функции, безопасные для main, как мы делаем здесь,
 и при этом сохраняются обычные гарантии безопасности для сопрограмм.
  И то, Room и другое Retrofit даст нам основную безопасность,
   и нам не нужно ничего делать, чтобы делать сетевые запросы или запросы к базе данных с помощью Flow.

Этот поток уже использует следующие потоки:

-- plantService.customPlantSortOrderработает в потоке Retrofit (он вызывает Call.enqueue)
- getPlantsFlowбудет запускать запросы к Room Executor
- applySortбудет запускаться на собирающем диспетчере (в этом случае Dispatchers.Main)

Так что, если бы все, что мы делали, - это вызывать функции приостановки в потоках Retrofit и использовать их Room,
 нам не нужно было бы усложнять этот код соображениями безопасности.
Однако по мере увеличения размера нашего набора данных вызов applySort может стать достаточно медленным,
 чтобы заблокировать основной поток.
  Flow предлагает декларативный API, вызываемый flowOn для управления потоком, в котором выполняется поток.
Добавьте flowOn к plantsFlow этому:

PlantRepository.kt
private val customSortFlow = plantsListSortOrderCache::getOrAwait.asFlow()

val plantsFlow: Flow<List<Plant>>
   get() = plantDao.getPlantsFlow()
       .combine(customSortFlow) { plants, sortOrder ->
          plants.applySort(sortOrder)
       }
       .flowOn(defaultDispatcher)
       .conflate()
Вызов flowOn имеет два важных эффекта на выполнение кода:
1, Запустите новую сопрограмму в defaultDispatcher (в данном случае Dispatchers.Default),
 чтобы запустить и собрать поток перед вызовом flowOn.
2, Вводит буфер для отправки результатов из новой сопрограммы в последующие вызовы.
3, Выпустить значения из этого буфера в Flow последующий flowOn. В этом случае, это asLiveData в ViewModel.

Это очень похоже на то, как withContext работает переключение диспетчеров,
 но он вводит буфер в середине наших преобразований, который меняет способ работы потока.
 Запускаемой сопрограммой flowOn разрешено производить результаты быстрее,
  чем их потребляет вызывающий объект, и по умолчанию она буферизует большое их количество.
Оператор flowOnзапускает новую сопрограмму для сбора потока над ней и вводит буфер для записи результатов.

Вы можете управлять буфером с помощью большего количества операторов,
 например, conflate которые говорят, что нужно хранить только последнее значение, созданное в буфере.
Важно помнить о буфере при использовании flowOn с большими объектами,
такими как результаты в комнате, поскольку легко использовать большой объем результатов буферизации памяти.
Запустите приложение
Если вы снова запустите приложение, вы увидите, что теперь загружаете данные
 и применяете пользовательский порядок сортировки с помощью Flow!
  Поскольку мы еще не реализовали switchMap, опция фильтра ничего не делает.

На следующем шаге мы рассмотрим другой способ обеспечения основной безопасности использования flow.

 12. Переключение между двумя потоками.
Чтобы завершить потоковую версию этого API, откройте PlantListViewModel.kt,
 где мы будем переключаться между потоками, GrowZone как и в LiveData версии.
Добавьте следующий код под plants liveData:
РастенияListViewModel.kt
private val growZoneChannel = ConflatedBroadcastChannel<GrowZone>()

val plantsUsingFlow: LiveData<List<Plant>> = growZoneChannel.asFlow()
    .flatMapLatest { growZone ->
        if (growZone == NoGrowZone) {
            plantRepository.plantsFlow
        } else {
            plantRepository.getPlantsWithGrowZoneFlow(growZone)
        }
    }.asLiveData()
Этот паттерн показывает, как интегрировать события (изменение зоны роста) в поток.
Он делает то же самое, что и LiveData.switchMapверсия -
 - переключение между двумя источниками данных на основе события.

Пошаговый код
PlantListViewModel.kt
private val growZoneChannel = ConflatedBroadcastChannel<GrowZone>()
Это определяет новый ConflatedBroadcastChannel.
 Это особый вид держателя значений на основе сопрограмм,
  который содержит только последнее значение, которое ему было присвоено.
   Это потокобезопасный примитив параллелизма,
    поэтому вы можете писать в него из нескольких потоков одновременно
     (и выигрывает тот, который считается «последним»).
Вы также можете подписаться, чтобы получать обновления текущего значения.
В целом, он ведет себя так же, как LiveData-
 он просто сохраняет последнее значение и позволяет вам наблюдать за его изменениями.
  Однако, в отличие от этого LiveData,
   вы должны использовать сопрограммы для чтения значений в нескольких потоках.

ConflatedBroadcastChannelЧасто является хорошим способом для вставки события в поток.
 Он предоставляет примитив параллелизма (или низкоуровневый инструмент)
  для передачи значений между несколькими сопрограммами.
Объединяя события, мы отслеживаем только самое последнее событие.
 Часто это правильный поступок, поскольку события пользовательского интерфейса могут происходить быстрее,
  чем обработка, и мы обычно не заботимся о промежуточных значениях.
Если вам действительно нужно передавать все события между сопрограммами и вы не хотите слияния,
 рассмотрите возможность использования, Channel который предлагает семантику BlockingQueue
  использования приостановленных функций.
   channelFlow Строитель может быть использован для канала поддерживается потоками.

PlantListViewModel.kt
val plantsUsingFlow: LiveData<List<Plant>> = growZoneChannel.asFlow()
Один из самых простых способов подписаться на изменения в файле ConflatedBroadcastChannel-
 - это преобразовать его в файл flow.
  Это создает объект, flowкоторый при сборе подписывается на изменения ConflatedBroadcastChannel
  и отправляет их в поток.
   Он не добавляет никаких дополнительных буферов,
    поэтому, если сборщик потока работает медленнее, чем запись в growZoneChannel него,
     он пропускает любые результаты и генерирует только самые последние.

Это также хорошо, потому что отмена подписки на канал произойдет при отмене потока.
asFlow Добавочное ConflatedBroadcastChannel будет конвертировать ConflatedBroadcastChannel в Flow том ,
 что будет иметь то же сплавлено поведение как ConflatedBroadcastChannel.
Это простой способ подписаться на изменения в ConflatedBroadcastChannel.

PlantListViewModel.kt
   .flatMapLatest { growZone ->
Это точно так же, как и switchMap из LiveData.
 При growZoneChannel изменении своего значения будет применяться эта лямбда, и она должна вернуть Flow.
  Затем возвращенное значение Flow будет использоваться Flow для всех последующих операторов.
По сути, это позволяет нам переключаться между разными потоками в зависимости от значения growZone.
flatMapLatestРасширения Flow позволяют переключаться между несколькими потоками.

PlantListViewModel.kt
if (growZone == NoGrowZone) {
    plantRepository.plantsFlow
} else {
    plantRepository.getPlantsWithGrowZoneFlow(growZone)
}
Внутри flatMapLatest мы переключаемся на основе growZone.
 Этот код почти такой же, как и LiveData.switchMap версия,
  с той лишь разницей, что он возвращает Flowsвместо LiveDatas.
PlantListViewModel.kt
   }.asLiveData()
И, наконец, мы преобразуем Flow объект в объект LiveData, поскольку наш Fragment ожидает,
 что мы предоставим объект LiveDataиз класса ViewModel.

asLiveData Оператор будет конвертировать Flowв LiveDataс настраиваемым тайм - аут.
Как и в случае с liveData конструктором, тайм-аут будет поддерживать поток в активном состоянии через ротации,
поэтому ваша коллекция не будет перезапущена.

 Отправить значение в канал
 Чтобы сообщить каналу о смене фильтра, мы можем позвонить offer.
  Это обычная (не приостанавливающая) функция, и это простой способ передать событие в сопрограмму,
   как мы это делаем здесь.
 В ViewModelвызовите offer оба setGrowZoneNumberи clearGrowZoneNumber вот так:
 PlantListViewModel.kt
 fun setGrowZoneNumber(num: Int) {
     growZone.value = GrowZone(num)
     growZoneChannel.offer(GrowZone(num))

     launchDataLoad {
         plantRepository.tryUpdateRecentPlantsForGrowZoneCache(GrowZone(num))
     }
 }

 fun clearGrowZoneNumber() {
     growZone.value = NoGrowZone
     growZoneChannel.offer(NoGrowZone)

     launchDataLoad {
         plantRepository.tryUpdateRecentPlantsCache()
     }
 }

 Запустите приложение еще раз
 Если вы снова запустите приложение, фильтр теперь работает как для LiveDataверсии, так и для Flowверсии!
РАБОТАЕТ
 На следующем шаге мы применим настраиваемую сортировку к getPlantsWithGrowZoneFlow.

13. Смешивание стилей с потоком

Одна из самых интересных особенностей Flow- первоклассная поддержка функций приостановки.
 flow Строитель и почти каждый преобразование выставляет suspend оператор ,
  который может вызывать любые суспендирующие функции.
   В результате основная безопасность для сетевых вызовов и вызовов базы данных,
    а также оркестровка нескольких асинхронных операций могут выполняться
     с помощью вызовов обычных функций приостановки изнутри потока.

По сути, это позволяет естественным образом смешивать декларативные преобразования с императивным кодом.
 Как вы увидите в этом примере, внутри обычного оператора карты вы можете организовать
  несколько асинхронных операций без применения каких-либо дополнительных преобразований.
Во многих местах это может привести к существенно более простому коду, чем при полностью декларативном подходе.

Если вы широко использовали такие библиотеки, как RxJava, это одно из основных отличий, предоставляемых Flow.
Вначале Flow внимательно обдумайте, как можно использовать приостанавливающие преобразования для упрощения кода.
Во многих случаях, вы можете выразить асинхронной код, естественно,
 опираясь на приостановки операций внутри операторов , как map, onStart, и onCompletion.
 Знакомые операторы из Rx , как combine, mapLatest, flatMapLatest, flattenMergeи flatMapMerge
 лучше всего использовать , чтобы организовать параллельности в Flow.

Использование функций приостановки для управления асинхронной работой
Чтобы завершить наше исследование Flow, мы применим настраиваемую сортировку с помощью операторов приостановки.
Откройте PlantRepository.kt и добавьте преобразование карты в getPlantsWithGrowZoneNumber.

PlantRepository.kt
fun getPlantsWithGrowZoneFlow(growZone: GrowZone): Flow<List<Plant>> {
   return plantDao.getPlantsWithGrowZoneNumberFlow(growZone.number)
       .map { plantList ->
           val sortOrderFromNetwork = plantsListSortOrderCache.getOrAwait()
           val nextValue = plantList.applyMainSafeSort(sortOrderFromNetwork)
           nextValue
       }
}

Опираясь на обычные функции приостановки для обработки асинхронной работы,
 эта операция сопоставления является основной, даже если она объединяет две асинхронные операции.
Когда возвращается каждый результат из базы данных, мы получаем кэшированный порядок сортировки
 - и, если он еще не готов, он будет ждать асинхронного сетевого запроса.
  Затем, когда у нас есть порядок сортировки, можно безопасно вызвать applyMainSafeSort,
   который запустит сортировку в диспетчере по умолчанию.
Этот код теперь полностью безопасен для основной сети,
поскольку основные проблемы безопасности перенесены на обычные функции приостановки.
 Это немного проще, чем то же преобразование, реализованное в plantsFlow.

В Flow, mapи другие операторы предоставляют суспендирующую лямбду.
Используя механизм приостановки и возобновления сопрограмм,
 вы часто можете легко организовать последовательные асинхронные вызовы
  без использования декларативных преобразований.

Выдача значения из сопрограммы, отличной от той, которая вызвала приостанавливающее преобразование, является ошибкой .
Если вы запускаете другую сопрограмму внутри операции потока, как мы делаем здесь,
 внутри, getOrAwait и applyMainSafeSort make значение будет возвращено исходной сопрограмме перед emitting ней.

Однако стоит отметить, что он будет работать несколько иначе.
 Кэшированное значение будет извлекаться каждый раз, когда база данных выдает новое значение.
  Это нормально, потому что мы правильно кэшируем его plantsListSortOrderCache,
   но если это запустит новый сетевой запрос, эта реализация сделает много ненужных сетевых запросов.
    Кроме того, в этой .combine версии сетевой запрос и запрос к базе данных выполняются одновременно,
     в то время как в этой версии они выполняются последовательно.

Из-за этих различий нет четкого правила для структурирования этого кода.
 Во многих случаях можно использовать приостанавливающие преобразования, как мы делаем здесь,
  что делает все асинхронные операции последовательными.
Однако в других случаях лучше использовать операторы для управления параллелизмом и обеспечения безопасности main.

14. Управление параллелизмом с потоком

Ты почти там!
 В качестве последнего (необязательного) шага переместим сетевые запросы в сопрограмму на основе потока.

Поступая таким образом, мы удалим логику выполнения сетевых вызовов от вызываемых обработчиков onClick
 и будем управлять ими из growZoneChannel.
  Это помогает нам создать единый источник правды и избежать дублирования кода
   - никакой код не может изменить фильтр без обновления кеша.

Откройте PlantListViewModel.kt и добавьте это в блок инициализации:
PlantListViewModel.kt
init {
   clearGrowZoneNumber()

   growZoneChannel.asFlow()
       .mapLatest { growZone ->
           _spinner.value = true
           if (growZone == NoGrowZone) {
               plantRepository.tryUpdateRecentPlantsCache()
           } else {
               plantRepository.tryUpdateRecentPlantsForGrowZoneCache(growZone)
           }
       }
       .onCompletion {  _spinner.value = false }
       .catch { throwable ->  _snackbar.value = throwable.message  }
       .launchIn(viewModelScope)
}
Этот код запустит новую сопрограмму для наблюдения за значениями, отправленными в growZoneChannel.
 Вы можете закомментировать сетевые вызовы в приведенных ниже методах,
  поскольку они нужны только для данной LiveDataверсии.

PlantListViewModel.kt
fun setGrowZoneNumber(num: Int) {
    growZone.value = GrowZone(num)
    growZoneChannel.offer(GrowZone(num))

    // launchDataLoad {
    //    plantRepository.tryUpdateRecentPlantsForGrowZoneCache(GrowZone(num))
    // }
}

fun clearGrowZoneNumber() {
    growZone.value = NoGrowZone
    growZoneChannel.offer(NoGrowZone)

    // launchDataLoad {
    //    plantRepository.tryUpdateRecentPlantsCache()
    // }
}
Запустите приложение еще раз
Если вы запустите приложение сейчас снова, вы увидите, что обновление сети теперь контролируется каналом!
 Мы существенно улучшили код, поскольку все больше способов изменить фильтр поступают в канал,
  который действует как единственный источник достоверной информации, для которого фильтр активен.
   Таким образом, сетевой запрос и текущий фильтр никогда не рассинхронизируются.

Пошаговый код
Давайте рассмотрим все новые функции, используемые по очереди, начиная с внешней стороны:

PlantListViewModel.kt
growZoneChannel.asFlow()
    // ...
    .launchIn(viewModelScope)
asFlow Оператор будет создавать поток из нашего канала, так же , как мы это делали в plantsUsingFlow.
 Однако на этот раз мы используем launchInоператор для сбора потока внутри нашего ViewModel.
Оператор launchIn создает новую сопрограмму и собирает каждое значение из потока.
 Он будет запущен в CoroutineScope предоставленном - в данном случае в viewModelScope.
  Это здорово, потому что это означает, что, когда это ViewModelбудет очищено, Flow будет отменено.

Без предоставления каких-либо других операторов это мало что Flow дает,
 но поскольку обеспечивает приостановку лямбда-выражений во всех своих операторах,
  легко выполнять асинхронные действия на основе каждого значения

Используя Flow это естественно для сбора данных в ViewModel,
 Repositoryили других слоях данных,когда это необходимо.

Поскольку Flowон не привязан к пользовательскому интерфейсу,
 вам не нужен наблюдатель пользовательского интерфейса для collect потока.
  Это большое отличие, от LiveData которого всегда требуется запускать UI-наблюдатель.
   Это не очень хорошая идея, чтобы попытаться в вашем,
    потому что он не имеет соответствующий жизненный цикл наблюдения.observe LiveData ViewModel

PlantListViewModel.kt
.mapLatest { growZone ->
    _spinner.value = true
    if (growZone == NoGrowZone) {
        plantRepository.tryUpdateRecentPlantsCache()
     else {
        .tryUpdateRecentPlantsForGrowZoneCache(growZone)
     }
}
В этом и заключается магия - mapLatest мы применим эту функцию карты для каждого значения.
 Однако, в отличие от обычного map, он запускает новую сопрограмму для каждого вызова преобразования карты.
  Затем, если новое значение испускается growZoneChannel до завершения предыдущей сопрограммы,
   она отменит его перед запуском новой.

Мы можем использовать mapLatest для управления параллелизмом.
 Вместо того, чтобы самостоятельно строить логику отмены / перезапуска,
  преобразование потока может позаботиться об этом.
   Этот код экономит много кода и снижает сложность по сравнению с написанием той же логики отмены вручную.

Отмена a Flowследует обычным правилам совместной отмены сопрограмм.

Если вы использовали RxJava, вы можете использовать mapLatestточно так же, как и раньше switchMap.
Ключевое отличие состоит в том, что он предоставляет вам приостанавливающую лямбду в новой сопрограмме,
 поэтому вы можете вызывать обычные функции приостановки непосредственно из mapLatest.

PlantListViewModel.kt
.onCompletion {  _spinner.value = false }
.catch { throwable -> _snackbar.value = throwable.message }

onCompletionбудет вызываться каждый раз, когда поток над ним завершается.
 Это то же самое, что и блок finally - это хорошее место для размещения любого кода,
  который необходимо выполнить во время очистки.
   Здесь мы сбрасываем счетчик.

catchОператор будет фиксировать любые исключения , над ним в потоке.
 Он может передать потоку новое значение, например, состояние ошибки,
  повторно выбросить исключение в поток или выполнить работу, как мы здесь.

Когда возникает ошибка, мы просто говорим нам _snackbar отобразить сообщение об ошибке.

Подведение итогов

Этот шаг показал вам, как вы можете управлять параллелизмом, используя Flow,
 а также использовать Flows внутри, ViewModel вне зависимости от наблюдателя пользовательского интерфейса.

В качестве непростого шага попробуйте определить функцию для инкапсуляции загрузки данных этого потока
 со следующей сигнатурой:

fun <T> loadDataFor(source: ConflatedBroadcastChannel<T>, block: suspend (T) -> Unit) {

https://codelabs.developers.google.com/codelabs/advanced-kotlin-coroutines/#13

при запуске в My flow spinner крутится все время и не отменяется
а в finish code все в порядке - ошибку у себя не вижу
22.09.2020 3:00