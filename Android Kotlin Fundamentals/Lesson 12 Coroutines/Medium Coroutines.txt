https://medium.com/androiddevelopers/room-coroutines-422b786dc4c5
https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471


https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb

=========================================================================================
Coroutines on Android (part I): Getting the background
Сопрограммы на Android (часть I): получение фона

Котлин сопрограмма ввести новый стиль параллелизма , который можно использовать на Android для упрощения асинхронного кода.
В Android сопрограммы - отличное решение двух проблем:
Длительные задачи - это задачи, которые слишком долго блокируют основной поток.
Main-security позволяет гарантировать, что любая функция приостановки может быть вызвана из основного потока.

Долгосрочные задачи

Получение веб-страницы или взаимодействие с API включают выполнение сетевого запроса. Точно так же чтение из базы данных или загрузка изображения с диска подразумевает чтение файла. Такого рода вещи я называю длительными задачами - задачами, которые требуют слишком много времени, чтобы ваше приложение остановилось и дождалось их!

В Android каждое приложение имеет основной поток, который отвечает за обработку пользовательского интерфейса (например, представления чертежей) и координацию взаимодействия с пользователем. Если в этом потоке выполняется слишком много работы, приложение зависает или замедляется, что приводит к нежелательному взаимодействию с пользователем. Любая длительная задача должна выполняться без блокировки основного потока, чтобы ваше приложение не отображало то, что называется «jank», например, замороженные анимации, и не реагировало медленно на события касания.

Обычным шаблоном для выполнения сетевого запроса вне основного потока являются обратные вызовы. Обратные вызовы предоставляют дескриптор библиотеки, которую она может использовать для обратного вызова в ваш код в будущем. С обратными вызовами загрузка сайта developer.android.com может выглядеть так:
class ViewModel: ViewModel () { 
   fun fetchDocs () { 
       get ("developer.android.com") {result -> 
           show (результат) 
       } 
    } 
}
Даже если getвызывается из основного потока, он будет использовать другой поток для выполнения сетевого запроса. Затем, как только результат станет доступен из сети, обратный вызов будет вызван в основном потоке. Это отличный способ обрабатывать длительные задачи, а библиотеки, такие как Retrofit, могут помочь вам делать сетевые запросы, не блокируя основной поток.

Использование сопрограмм для длительных задач

Сопрограммы - это способ упростить код, используемый для управления длительными задачами, такими как fetchDocs. Чтобы изучить, как сопрограммы упрощают код для длительных задач, давайте перепишем приведенный выше пример обратного вызова, чтобы использовать сопрограммы.

// Dispatchers.Main
suspend fun fetchDocs() {
    // Dispatchers.Main
    val result = get("developer.android.com")
    // Dispatchers.Main
    show(result)
}
// look at this in the next section
suspend fun get(url: String) = withContext(Dispatchers.IO){/*...*/}
Оказывается, сопрограммы позволяют Kotlin выполнять этот код и никогда не блокировать основной поток.

Сопрограммы основываются на обычных функциях, добавляя две новые операции. В дополнение к invoke (or call) and return , сопрограммы добавить suspend and resume.

suspend - приостановить выполнение текущей сопрограммы, сохраняя все локальные переменные
resume  - продолжить приостановленную сопрограмму с того места, где она была приостановлена

Эта функция добавляется Kotlin ключевым словом suspend в функции. Вы можете вызывать функции приостановки только из других функций приостановки или с помощью построителя сопрограмм, например, launchд ля запуска новой сопрограммы.

Suspend and resume work together to replace callbacks.
Приостановите и возобновите совместную работу, чтобы заменить обратные вызовы.

В приведенном выше примере, getбудет приостановить сопрограммы перед началом сетевого запроса. Функция get по-прежнему будет отвечать за выполнение сетевого запроса из основного потока. Затем, когда сетевой запрос завершается, вместо вызова обратного вызова для уведомления основного потока он может просто возобновить приостановленную сопрограмму.

Глядя на то, как fetchDocs выполняется, вы можете увидеть, как работает приостановка . Каждый раз, когда сопрограмма приостанавливается, текущий кадр стека (место, которое Kotlin использует для отслеживания того, какая функция запущена и ее переменные) копируется и сохраняется на потом. Когда он возобновляется , кадр стека копируется обратно из того места, где он был сохранен, и снова запускается. В середине анимации - когда все сопрограммы в основном потоке приостановлены, основной поток может обновлять экран и обрабатывать пользовательские события. Вместе приостановите и возобновите замену обратных вызовов. Довольно аккуратно!

Когда все сопрограммы в основном потоке приостановлены, основной поток может выполнять другую работу.

Несмотря на то, что мы написали простой последовательный код, который выглядит в точности как блокирующий сетевой запрос, сопрограммы будут запускать наш код именно так, как мы хотим, и избежать блокировки основного потока!
Далее давайте посмотрим, как использовать сопрограммы для обеспечения безопасности в основном, и рассмотрим диспетчеров.

Main-безопасность с сопрограммами

В сопрограммах Kotlin хорошо написанные функции приостановки всегда безопасно вызывать из основного потока. Независимо от того, что они делают, они всегда должны позволять любому потоку вызывать их.

Но есть много вещей, которые мы делаем в наших приложениях для Android, которые слишком медленно выполняются в основном потоке. Сетевые запросы, синтаксический анализ JSON, чтение или запись из базы данных или даже простой перебор больших списков. Любой из них может работать достаточно медленно, чтобы вызвать видимый «мусор» для пользователя, и он должен запускаться из основного потока.

Использование suspend не указывает Kotlin запускать функцию в фоновом потоке. Часто стоит четко и ясно говорить, что сопрограммы будут выполняться в основном потоке. Фактически, это действительно хорошая идея использовать Dispatchers.Main.immediate при запуске сопрограммы в ответ на событие пользовательского интерфейса - таким образом, если вы не выполните длительную задачу, требующую main-security, результат может будет доступен пользователю в следующем кадре.

Сопрограммы будут выполняться в основном потоке, и приостановка не означает фон.

Для того, чтобы функция , которая делает работу, это слишком медленно для основного потока основных безопасного, вы можете сказать Котлин сопрограмм coroutines для выполнения работ либо на Default или IO диспетчере. В Kotlin все сопрограммы coroutines должны работать в диспетчере, даже если они работают в основном потоке. Сопрограммы coroutines могут приостанавливаться suspend , и диспетчер - это то, что знает, как их возобновлять resume.

Чтобы указать, где должны запускаться сопрограммы, Kotlin предоставляет три диспетчера, которые вы можете использовать для отправки потоков.

+ ----------------------------------- + 
| Диспетчеры. Главная           | 
+ ----------------------------------- +
 | Основной поток Main thread на Android, взаимодействовать | 
| с пользовательским интерфейсом и выполнить свет light   | 
| работа | 
+ ----------------------------------- + 
| - Вызов функций приостановки Calling suspend functions  | 
| - Вызов функций пользовательского интерфейса Call UI functions  | 
| - Обновление LiveData Updating LiveData   | 
+ ----------------------------------- + 

+ ------------ ----------------------- + 
| Диспетчеры. IO            | 
+ ----------------------------------- +
 | Оптимизирован для дискового и сетевого ввода-вывода | 
| от основного потока |
+ ----------------------------------- + 
| - База данных * | 
| - Чтение / запись файлов | 
| - Сеть ** | 
+ ----------------------------------- + 

+ ------------ ----------------------- + 
| Диспетчеры. По умолчанию         | 
+ ----------------------------------- +
 | Оптимизирован для работы с интенсивным процессором | 
| от основного потока | 
+ ----------------------------------- + 
| - Сортировка списка Sorting a list  | 
| - Разбор JSON Parsing JSON  | 
| - DiffUtils DiffUtils | 
+ ----------------------------------- +

* Room will provide main-safety automatically if you use suspend functions, RxJava, or LiveData.
** Networking libraries such as Retrofit and Volley manage their own threads and do not require explicit main-safety in your code when used with Kotlin coroutines.
* Комната автоматически обеспечит основную безопасность, если вы используете функции приостановки , RxJava или LiveData .
** Сетевые библиотеки, такие как Retrofit и Volley, управляют своими собственными потоками и не требуют явной main-безопасности в вашем коде при использовании с сопрограммами Kotlin.

Чтобы продолжить приведенный выше пример, давайте воспользуемся диспетчерами для определения getфункции. Внутри тела get вы вызываете withContext(Dispatchers.IO) для создания блока, который будет запускаться в IO диспетчере. Любой код, который вы поместите в этот блок, всегда будет выполняться IO диспетчером. Поскольку withContext сама по себе функция приостановки, она будет работать с использованием сопрограмм для обеспечения основной безопасности.

// Dispatchers.Main 
suspend fun fetchDocs () { 
    // Dispatchers.Main 
    val result = get ("developer.android.com") 
    // Dispatchers.Main 
    show (результат) 
}
// Dispatchers.Main 
suspend fun get (url: String) = 
    // Dispatchers.Main 
    withContext (Dispatchers.IO) { 
        // Dispatchers.IO 
        / * здесь выполняется блокировка сетевого ввода-вывода * / 
    } 
    // Dispatchers.Main
С помощью сопрограмм вы можете выполнять диспетчеризацию потоков с точным управлением. Поскольку withContext позволяет вам контролировать, в каком потоке выполняется любая строка кода, не вводя обратный вызов для возврата результата, вы можете применять его к очень небольшим функциям, таким как чтение из вашей базы данных или выполнение сетевого запроса. Таким образом, хорошей практикой является использование, withContext чтобы убедиться, что каждая функция может быть безопасно вызвана при любом Dispatcher включении Main- таким образом вызывающему абоненту никогда не придется думать о том, какой поток потребуется для выполнения функции.

В этом примере fetchDocs выполняется в основном потоке, но может безопасно вызывать, get который выполняет сетевой запрос в фоновом режиме. Поскольку сопрограммы поддерживают приостановку и возобновление , сопрограмма в основном потоке будет возобновлена ​​с результатом, как только withContext блок будет завершен.

Хорошо написанные функции приостановки всегда можно безопасно вызывать из основного потока (или безопасно из основного потока).

Это действительно хорошая идея - сделать каждую функцию приостановки безопасной. Если он делает что-либо, что касается диска, сети или даже просто использует слишком много ЦП, используйте, withContext чтобы сделать его безопасным для вызова из основного потока. Это шаблон, которому следуют библиотеки на основе сопрограмм, такие как Retrofit и Room. Если вы будете следовать этому стилю во всей кодовой базе, ваш код будет намного проще и позволит избежать смешивания проблем потоковой передачи с логикой приложения. При последовательном выполнении сопрограммы могут свободно запускаться в основном потоке и делать запросы к сети или базе данных с помощью простого кода, гарантируя, что пользователи не увидят «мусора».

Производительность withContext
withContext работает так же быстро, как обратные вызовы или RxJava для обеспечения основной безопасности. В withContext некоторых ситуациях даже можно оптимизировать вызовы сверх того, что возможно с помощью обратных вызовов. Если функция выполняет 10 вызовов базы данных, вы можете указать Kotlin переключиться один раз на внешний для withContext всех 10 вызовов. Тогда, даже если библиотека базы данных будет вызывать withContext повторно, она останется в том же диспетчере и будет следовать быстрому пути. Кроме того, переключение между Dispatchers.Default и Dispatchers.IO оптимизировано, чтобы по возможности избегать переключения потоков.

Что дальше
В этом посте мы изучили, какие проблемы отлично справляются с решением сопрограмм. Сопрограммы - это действительно старая концепция языков программирования, которые в последнее время стали популярными из-за их способности упрощать код, взаимодействующий с сетью.
На Android вы можете использовать их для решения двух действительно распространенных проблем:
--Упрощение кода для длительных задач, таких как чтение из сети, с диска или даже анализ большого результата JSON.
--Выполнение точной main-безопасности, чтобы гарантировать, что вы никогда случайно не заблокируете основной поток, не усложнив код для чтения и записи.

В следующем посте мы рассмотрим, как они подходят для Android, чтобы отслеживать всю работу, которую вы начали с экрана! Прочтите это:

===========================================================================================
Coroutines on Android (part II): Getting started
Сопрограммы на Android (часть II): начало работы

Это часть серии статей об использовании Coroutines на Android.
Этот пост посвящен началу работы и отслеживанию уже начатой ​​работы.

Отслеживание сопрограмм
В первой части мы исследовали проблемы, с которыми отлично справляются сопрограммы.
Напомним, что сопрограммы - отличное решение двух распространенных проблем программирования:
--Длительные задачи - это задачи, которые слишком долго блокируют основной поток.
--Main-security позволяет гарантировать, что любая функция приостановки может быть вызвана из основного потока.
Чтобы решить эти проблемы, сопрограммы основываются на обычных функциях, добавляя приостановку и возобновление . Когда все сопрограммы в определенном потоке приостановлены, поток может выполнять другую работу.

Однако сопрограммы сами по себе не помогают отслеживать выполняемую работу. Совершенно нормально иметь большое количество сопрограмм - сотни или даже тысячи - и все они приостановлены одновременно. И хотя сопрограммы дешевы, работа, которую они выполняют, часто дорогостоящая, например чтение файлов или выполнение сетевых запросов.
С помощью кода вручную отслеживать тысячу сопрограмм довольно сложно. Вы можете попытаться отследить их все и вручную убедиться, что они завершены или отменены, но такой код утомителен и подвержен ошибкам. Если код не идеален, он потеряет след сопрограммы, что я называю утечкой работы .
Утечка работы , как утечка памяти, но хуже. Это потерянная сопрограмма. Помимо использования памяти, утечка работы может возобновиться, чтобы использовать ЦП, диск или даже запустить сетевой запрос.


 leaked coroutine - Утечка сопрограммы может расходовать память, ЦП, диск или даже запускать сетевой запрос, который не нужен.

Чтобы избежать утечки сопрограмм, Kotlin ввел структурированный параллелизм . Структурированный параллелизм - это комбинация языковых функций и передовых практик, которые при соблюдении помогают отслеживать всю работу, выполняемую в сопрограммах.
В Android мы можем использовать структурированный параллелизм для выполнения трех задач:
--Отмените работу, когда она больше не нужна.
--Следите за работой, пока она работает.
--Сообщать об ошибках при выходе из строя сопрограммы.

Давайте углубимся в каждый из них и посмотрим, как структурированный параллелизм помогает нам убедиться, что мы никогда не упускаем из виду сопрограммы и работу с утечками.

Отменить работу с областями действия

В Kotlin сопрограммы должны работать в чем-то, называемом CoroutineScope. A CoroutineScope отслеживает ваши сопрограммы, даже если они приостановлены. В отличие от того, о чем Dispatchers мы говорили в первой части, он на самом деле не выполняет ваши сопрограммы - он просто следит за тем, чтобы вы не теряли их из виду.
Чтобы обеспечить отслеживание всех сопрограмм, Kotlin не позволяет запускать новую сопрограмму без файла CoroutineScope. Вы можете думать о CoroutineScope чем-то вроде облегченной версии ExecutorServiceсо сверхспособностями. Это дает вам возможность запускать новые сопрограммы, которые идут со всем, что приостанавливает и возобновляет работу, которую мы исследовали в первой части.
A CoroutineScope отслеживает все ваши сопрограммы и может отменить все запущенные в нем сопрограммы. Это хорошо сочетается с разработкой Android, где вы хотите убедиться, что вы очищаете все, что было запущено экраном, когда пользователь уходит.

CoroutineScope отслеживает все ваши сопрограммы и может отменить все сопрограммы, запущенные в нем.

Запуск новых сопрограмм

Важно отметить, что вы не можете просто вызвать suspend функцию из любого места. Механизм приостановки и возобновления требует, чтобы вы переключились с обычных функций на сопрограмму.
Есть два способа запустить сопрограммы, и они могут использоваться по-разному:
--launch builder запустит новую сопрограмму « запустил и забыл» - это означает, что он не вернет результат вызывающей стороне.
--async builder запустит новую сопрограмму и позволит вам вернуть результат с помощью вызываемой функции приостановки await.

Почти во всех случаях правильным ответом на вопрос, как запустить сопрограмму из обычной функции, является использование launch.
 Поскольку обычная функция не имеет возможности вызывать await (помните, что она не может вызывать функции приостановки напрямую), нет смысла использовать ее в async качестве основной записи для сопрограмм. Позже мы поговорим о том, когда будет смысл использовать async.

Вместо этого вы должны использовать область сопрограммы, чтобы запустить сопрограмму путем вызова launch.

scope.launch { 
    // Этот блок запускает новую сопрограмму 
    // "в" области видимости. 
    // 
    // Он может вызывать функции приостановки 
   fetchDocs () 
}

Вы можете думать об этом launch как о мосте, который переносит ваш код из обычных функций в мир сопрограмм. Внутри launch тела вы можете вызывать функции приостановки и создавать основную безопасность, как мы обсуждали в предыдущем посте.

Launch - это мост от обычных функций к сопрограммам.

Предупреждение: Большая разница между launch и async как они обрабатывают исключения. async ожидает, что вы в конечном итоге позвоните await чтобы получить результат (или исключение), чтобы по умолчанию исключения не возникали. Это означает, что если вы используете async чтобы запустить новую сопрограмму, она автоматически отбрасывает исключения.

Поскольку launch и async доступны только в a CoroutineScope, вы знаете, что любая создаваемая вами сопрограмма всегда будет отслеживаться областью видимости. Kotlin просто не позволяет вам создавать неотслеживаемую сопрограмму, что позволяет избежать утечек работы.

Начать в ViewModel

Итак, если a CoroutineScope отслеживает все запускаемые в нем launch сопрограммы и создает новую сопрограмму, где именно вы должны вызывать launch и размещать свои области видимости? И когда имеет смысл отменить все сопрограммы, запущенные в области видимости?

На Android часто имеет смысл связать a CoroutineScope с экраном пользователя. Это позволит вам не избежать утечек сопрограмм или делать дополнительную работу Activities или Fragments что больше не относятся к пользователю. Когда пользователь уходит от экрана, все CoroutineScope связанные с этим экраном могут cancel работать.

Структурированное параллелизм гарантирует , когда сфера отменяет все его сопрограмм отменить .

При интеграции сопрограмм с компонентами архитектуры Android вы обычно хотите, чтобы launch сопрограммы в формате ViewModel. Это естественное место, так как именно здесь начинается самая серьезная работа - и вам не придется беспокоиться о том, что вращение убьет все ваши сопрограммы.

Чтобы использовать сопрограммы в a ViewModel, вы можете использовать viewModelScope свойство extension из lifecycle-viewmodel-ktx:2.1.0-alpha04.('2.3.0-alpha07' //  '2.2.0') готовитсяviewModelScope к выпуску в AndroidX Lifecycle (v2.1.0) и в настоящее время находится в альфа- версии.
Вы можете узнать больше о том , как она работает в @manuelvicnt «s блоге . Поскольку библиотека в настоящее время находится на стадии альфа-тестирования, могут быть ошибки, и API-интерфейсы могут измениться до окончательной версии. Если обнаружите какие-либо ошибки, вы можете зарегистрировать их здесь .

Take a look at this example:
class MyViewModel(): ViewModel() {
    fun userNeedsDocs() {
        // Start a new coroutine in a ViewModel
	// Запуск новой сопрограммы в ViewModel 
        viewModelScope.launch {
            fetchDocs()
        }
    }
}

viewModelScope автоматически отменит любую сопрограмму, которая запускается этим, ViewModel когда она очищается (когда onCleared() вызывается обратный вызов). Как правило, это правильное поведение - если мы не загрузили документы, а пользователь закрыл приложение, мы, вероятно, просто тратим их батарею на выполнение запроса.
А для большей безопасности CoroutineScope будет размножаться. Итак, если запускаемая вами сопрограмма продолжает запускать другую сопрограмму, они обе окажутся в одной области. Это означает, что даже когда библиотеки, от которых вы зависите, запускают сопрограмму из вашей viewModelScope, у вас будет способ отменить их!

Предупреждение: сопрограммы отменяются совместно с помощью вызова, CancellationException когда сопрограмма приостановлена. Обработчики исключений, которые перехватывают исключение верхнего уровня, например Throwable, перехватывают это исключение. Если вы используете исключение в обработчике исключений или никогда не приостанавливаете работу, сопрограмма будет оставаться в полуотмененном состоянии.

Итак, когда вам нужно, чтобы сопрограмма работала так долго, как a ViewModel, используйте viewModelScope для переключения с обычных функций на сопрограммы. Затем, поскольку для вас viewModelScope будут автоматически выполняться cancel сопрограммы, вполне нормально написать здесь бесконечный цикл, не создавая утечек.

fun runForever () { 
    // запускаем новую сопрограмму в ViewModel 
    viewModelScope.launch { 
        // отменяем, когда ViewModel очищается 
        while (true) { 
            delay (1_000) 
            // делаем что-то каждую секунду 
        } 
    } 
}

Используя viewModelScope его, вы можете гарантировать, что вся работа, даже этот бесконечный цикл, будет отменена, когда она больше не понадобится.

Следите за работой
Запуск одной сопрограммы - это хорошо - и для большого количества кода это действительно все, что вам когда-либо понадобится. Запустите сопрограмму, сделайте сетевой запрос и запишите результат в базу данных.
Иногда, однако, требуется немного больше сложности. Допустим, вы хотите выполнить два сетевых запроса одновременно (или одновременно) в сопрограмме - для этого вам нужно запустить больше сопрограмм!
Чтобы создать больше сопрограмм, любые приостановленные функции могут запускать другие сопрограммы с помощью другого конструктора, называемого coroutineScope или его кузена supervisorScope . Этот API, честно говоря, немного сбивает с толку. coroutineScope builder and a CoroutineScope разные вещи , хотя и имеет только один символ разницы в их названии.

Запуск новых сопрограмм повсюду - это один из способов создания потенциальных утечек работы. Вызывающий может не знать о новых сопрограммах, и если он не знает, как он может отслеживать работу?
Чтобы исправить это, нам помогает структурированный параллелизм. А именно, он обеспечивает гарантию того, что, когда suspend функция вернется, вся ее работа будет выполнена.

Структурированный параллелизм гарантирует, что после возврата из приостановленной функции вся ее работа будет выполнена.

Вот пример использования coroutineScopeдля получения двух документов:
suspend fun fetchTwoDocs() {
    coroutineScope {
        launch { fetchDoc(1) }
        async { fetchDoc(2) }
    }
}

В этом примере два документа извлекаются из сети одновременно. Первый извлекается в сопрограмме, с launch которой запускается «запустил и забыл» - это означает, что она не вернет результат вызывающей стороне.
Второй документ извлекается с помощью async, поэтому документ может быть возвращен вызывающей стороне. Этот пример является немного странно, так как обычно вы будете использовать async для обоих документов - но я хотел показать , что вы можете смешивать и сочетать launch и в async зависимости от того, что вам нужно.

coroutineScope и supervisorScope позволяют безопасно запускать сопрограммы из приостановленных функций.

Однако обратите внимание, что этот код никогда явно не ожидает какую-либо из новых сопрограмм! Похоже fetchTwoDocs, вернется, пока работают сопрограммы!
Чтобы обеспечить структурированный параллелизм и избежать утечек работы, мы хотим, чтобы при fetchTwoDocs возврате функции приостановки, например, возврата, вся ее работа выполнялась. Это означает, что обе запускаемые сопрограммы должны завершиться до fetchTwoDocs возврата.
Kotlin гарантирует, что работа не уйдет fetchTwoDocs со стороны coroutineScope застройщика. coroutineScopeСтроитель приостановит себя , пока все сопрограммы не начали внутри него завершен. Из-за этого нет возможности вернуться, fetchTwoDocs пока не coroutineScope будут завершены все сопрограммы, запущенные в компоновщике.

Много-много работы

Теперь, когда мы изучили отслеживание одной и двух сопрограмм, пришло время пойти ва-банк и попытаться отслеживать тысячу сопрограмм!
Взгляните на следующую анимацию:

Анимация, показывающая, как coroutineScope может отслеживать тысячу сопрограмм.
В этом примере показано одновременное выполнение тысячи сетевых запросов. Это не рекомендуется в реальном коде Android - ваше приложение будет использовать много ресурсов.

В этом коде мы запускаем тысячу сопрограмм launch внутри coroutineScope построителя. Вы можете увидеть, как все устроено. Поскольку мы находимся в suspend функции, какой-то код где-то должен был использовать a CoroutineScopeдля создания сопрограммы. Мы ничего об этом не знаем CoroutineScope, это может быть какое- viewModelScope то другое CoroutineScope определение где-то еще. Независимо от того, какая это вызывающая область видимости, coroutineScope построитель будет использовать ее в качестве родителя для новой создаваемой области.

Затем внутри coroutineScopeблока launch запустятся сопрограммы «в» новой области видимости. Когда сопрограммы, запущенные при запуске, будут завершены, новый осциллограф будет их отслеживать. Наконец, как только все сопрограммы, запущенные внутри, coroutineScopeбудут завершены, loadLots можно вернуться.

Примечание: отношения родитель-потомок между областями действия и сопрограммами создаются с помощью Job объектов. Но часто можно думать о взаимосвязи между сопрограммами и областями видимости, не углубляясь в этот уровень.

coroutineScope и supervisorScope будут ждать завершения дочерних сопрограмм.

Там очень много здесь происходит под капотом - но важно то , что использование coroutineScope или supervisorScope вы можете launch сопрограмма безопасно из любой приостановки функции. Несмотря на то, что он запустит новую сопрограмму, вы не случайно пропустите работу, потому что вы всегда будете приостанавливать вызывающую программу до завершения новой сопрограммы.

Что действительно круто, так это coroutineScope создание дочерней области. Поэтому, если родительская область видимости будет отменена, она передаст отмену всем новым сопрограммам. Если бы вызывающим был вызывающий viewModelScope, все тысяча сопрограмм автоматически отменялись бы, когда пользователь уходил с экрана. Довольно аккуратно!

Прежде чем мы перейдем к ошибкам, это стоит того момента , чтобы говорить о supervisorScope VS. coroutineScope. Основное отличие состоит в том, что a coroutineScope будет, cancel когда любой из его дочерних элементов потерпит неудачу. Таким образом, если один сетевой запрос терпит неудачу, все остальные запросы немедленно отменяются. Если вместо этого вы хотите продолжить выполнение других запросов даже в случае сбоя одного из них, вы можете использовать файл supervisorScope. A supervisorScope не отменяет других дочерних элементов, когда один из них терпит неудачу.

Сигнальные ошибки при сбое сопрограммы

В сопрограммах об ошибках сигнализируют выбросом исключений, как и в обычных функциях. Исключения из suspend функции будут повторно отправлены вызывающей стороне при возобновлении. Как и в случае с обычными функциями, вы не ограничены попыткой / отловом для обработки ошибок, и вы можете создавать абстракции для выполнения обработки ошибок с другими стилями, если хотите.

Однако бывают ситуации, когда ошибки могут теряться в сопрограммах.

val unrelatedScope = MainScope ()
// пример потерянной ошибки 
suspend fun lostError () { 
    // асинхронный режим без структурированного параллелизма         unrelatedScope.async 
    { 
throw InAsyncNoOneCanHearYou ("except") 
    } 
}
Обратите внимание, что этот код объявляет несвязанную область сопрограммы, которая запустит новую сопрограмму без структурированного параллелизма. Помните, что в начале я сказал, что структурированный параллелизм - это комбинация типов и методов программирования, и введение несвязанных областей сопрограмм в функции приостановки не соответствует методам программирования структурированного параллелизма.
Ошибка потеряна в этом коде, потому что async предполагается, что вы в конечном итоге await вызовете, где он повторно вызовет исключение. Однако, если вы никогда не вызовете await, исключение будет храниться вечно, терпеливо ожидая возникновения.

Структурированный параллелизм гарантирует, что при ошибке сопрограммы будет уведомлен ее вызывающий объект или область действия.

Если вы используете структурированный параллелизм для приведенного выше кода, ошибка будет правильно передана вызывающей стороне.
suspend fun foundError() {
    coroutineScope {
        async { 
            throw StructuredConcurrencyWill("throw")
        }
    }
}
Поскольку coroutineScope будет ждать завершения всех дочерних элементов, он также может получать уведомления, когда они терпят неудачу. Если сопрограмма, запущенная с помощью, coroutineScope выдает исключение, coroutineScope может передать его вызывающей стороне. Поскольку мы используем coroutineScopeв место supervisorScope, он также немедленно отменяет всех других дочерних элементов при возникновении исключения.

Использование структурированного параллелизма
В этом посте я представил структурированный параллелизм и показал, как с его помощью наш код хорошо сочетается с Android, ViewModel чтобы избежать утечек работы.
Я также говорил о том, как с его помощью легче рассуждать о приостановленных функциях. Оба они гарантируют, что они завершают работу до того, как они вернутся, а также гарантируют, что они сигнализируют об ошибках, выявляя исключения.
Если бы вместо этого мы использовали неструктурированный параллелизм, сопрограммы могли бы легко случайно пропустить работу, о которой вызывающий не знал. Работа не может быть отменена, и не будет гарантировано, что исключения будут повторно выброшены. Это сделало бы наш код более удивительным и, возможно, создало бы непонятные ошибки.
Вы можете создать неструктурированный параллелизм, введя новую несвязанную CoroutineScope(обратите внимание на заглавную букву C) или используя вызываемую глобальную область видимости GlobalScope, но вы должны рассматривать неструктурированный параллелизм только в редких случаях, когда вам нужно, чтобы сопрограмма прожила дольше, чем вызывающая область. Затем рекомендуется самостоятельно добавить структуру, чтобы отслеживать неструктурированные сопрограммы, обрабатывать ошибки и иметь хорошую историю отмены.
К структурированному параллелизму нужно привыкнуть, если у вас есть опыт работы с неструктурированным параллелизмом. Структура и гарантии делают более безопасным и простым взаимодействие с suspend функциями. Рекомендуется как можно больше работать со структурированным параллелизмом, потому что это помогает сделать код более легким для чтения и менее удивительным.

В начале этого поста я перечислил три вещи, которые решает для нас структурированный параллелизм.
--Отмените работу, когда она больше не нужна.
--Следите за работой, пока она работает.
--Сообщать об ошибках при выходе из строя сопрограммы.
Выполнение этого структурированного параллелизма дает нам некоторые гарантии в отношении нашего кода. Вот гарантии структурированного параллелизма.
--Когда область действия отменяется-scope cancels  , все ее сопрограммы отменяются .
--Когда приостановленное удовольствие возвращается-suspend fun returns  , вся его работа сделана .
--Когда сопрограмма ошибается , уведомляется ее вызывающая сторона или область действия .
В совокупности гарантии структурированного параллелизма делают наш код более безопасным, более понятным и позволяют избежать утечек работы!

Что дальше?
В этом посте мы изучили, как запускать сопрограммы на Android в ViewModel и как работать со структурированным параллелизмом, чтобы сделать наш код менее удивительным.
В следующем посте мы подробнее поговорим о том, как использовать сопрограммы в практических ситуациях! Прочтите это:
https://medium.com/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45
=========================================================================================
Coroutines On Android (part III): Real work
Сопрограммы на Android (часть III): настоящая работа

Это часть серии статей об использовании Coroutines на Android. Этот пост посвящен решению практических задач с использованием сопрограмм путем реализации одноразовых запросов.

---------------Решение реальных проблем с помощью сопрограмм-----------------------

Первая и вторая части этой серии были посвящены тому, как можно использовать сопрограммы для упрощения кода, обеспечения основной безопасности на Android и предотвращения утечки работы. На этом фоне они выглядят как отличное решение как для фоновой обработки, так и для упрощения кода на основе обратного вызова на Android.
Пока что мы сосредоточились на том, что такое сопрограммы и как ими управлять. В этом посте мы рассмотрим, как их использовать для решения некоторых реальных задач. Сопрограммы - это функция языка программирования общего назначения на том же уровне, что и функции, поэтому вы можете использовать их для реализации всего, что вы могли бы, с функциями и объектами.

 Однако есть два типа задач, которые постоянно возникают в реальном коде, для которых сопрограммы являются отличным решением:
---Одноразовые запросы - это запросы, которые выполняются каждый раз при их вызове - они всегда завершаются после того, как готов результат.
---Потоковые запросы - это запросы, которые продолжают отслеживать изменения и сообщать о них вызывающей стороне - они не завершаются, когда готов первый результат.

Сопрограммы - отличное решение обеих этих задач. В этом посте мы подробно рассмотрим однократные запросы и узнаем, как их реализовать с помощью сопрограмм на Android.

----------------------Запросы на один выстрел-----------------------
Одноразовый запрос выполняется один раз при каждом вызове и завершается, как только готов результат. Этот шаблон аналогичен обычному вызову функции - он вызывается, выполняет некоторую работу, а затем возвращается. Из-за сходства с вызовами функций их легче понять, чем запросы потоковой передачи.

Запрос на один выстрел выполняется каждый раз при его вызове. Он прекращает выполнение, как только готов результат.

В качестве примера одноразового запроса рассмотрим, как ваш браузер загрузил эту страницу. Когда вы щелкнули ссылку на этот пост, ваш браузер отправил сетевой запрос на сервер для загрузки страницы. Как только страница была перенесена в ваш браузер, она перестала взаимодействовать с серверной частью - у нее были все необходимые данные. Если сервер изменил сообщение, новые изменения не будут отображаться в вашем браузере - вам придется обновить страницу.
Таким образом, хотя им не хватает потоковых запросов в реальном времени, одноразовые запросы довольно эффективны. В приложении для Android есть множество вещей, которые можно решить с помощью одноразовых запросов, таких как выборка, хранение или обновление данных. Это также хороший шаблон для таких вещей, как сортировка списка.

---------------Проблема: отображение отсортированного списка-------------------

Давайте рассмотрим одноразовые запросы, посмотрев, как можно отображать отсортированный список. Чтобы конкретизировать пример, давайте создадим приложение инвентаризации для использования сотрудником магазина. Он будет использоваться для поиска продуктов в зависимости от того, когда они в последний раз были в наличии - они захотят иметь возможность сортировать список как по возрастанию, так и по убыванию. В нем так много продуктов, что сортировка может занять почти секунду - поэтому мы будем использовать сопрограммы, чтобы не блокировать основной поток!

В этом приложении все продукты хранятся в базе данных Room. Это хороший вариант использования для изучения, поскольку он не требует сетевого запроса, поэтому мы можем сосредоточиться на шаблоне. Несмотря на то, что пример проще, потому что он не использует сеть, он раскрывает шаблоны, необходимые для реализации одноразовых запросов.

Для реализации этого запроса с помощью сопрограмм, вы представите сопрограммы к ViewModel, Repositoryи Dao. Давайте пройдемся по каждому из них и посмотрим, как их интегрировать с сопрограммами.

class ProductsViewModel(val productsRepository: ProductsRepository): ViewModel() {
   private val _sortedProducts = MutableLiveData<List<ProductListing>>()
   val sortedProducts: LiveData<List<ProductListing>> = _sortedProducts

   /**
    * Called by the UI when the user clicks the appropriate sort button
    * Вызывается пользовательским интерфейсом, когда пользователь нажимает соответствующую кнопку сортировки
    */
   fun onSortAscending() = sortPricesBy(ascending = true)
   fun onSortDescending() = sortPricesBy(ascending = false)

   private fun sortPricesBy(ascending: Boolean) {
       viewModelScope.launch {
           // suspend and resume make this database request main-safe
           // so our ViewModel doesn't need to worry about threading
          // приостановить и возобновить выполнение этого запроса к базе данных
          // поэтому нашей ViewModel не нужно беспокоиться о потоковой передаче
           _sortedProducts.value =
                   productsRepository.loadSortedProducts(ascending)
       }
   }
}

ProductsViewModel отвечает за получение событий от уровня пользовательского интерфейса, а затем за запрос обновленных данных в репозитории. Он используется LiveData для хранения текущего отсортированного списка для отображения пользовательским интерфейсом. Когда приходит новое событие, sortProductsBy запускается новая сопрограмма для сортировки списка и обновляется, LiveData когда результат будет готов. ViewModel, Как правило , правильное место , чтобы начать большинство сопрограмм в этой архитектуре, так как он может отменить сопрограмму в onCleared. Если пользователь покидает экран, ему обычно не нужна выдающаяся работа.
Если вы мало использовали LiveData, ознакомьтесь с этим отличным постом @CeruleanOtter, в котором рассказывается, как они работают для хранения данных для пользовательских интерфейсов.

Это общий шаблон для сопрограмм на Android. Поскольку платформа Android не вызывает функции приостановки, вам необходимо координировать действия с сопрограммой в ответ на событие пользовательского интерфейса. Самый простой способ сделать это - просто запустить новую сопрограмму при наступлении события - и естественное место для этого - файл ViewModel.

----------------В качестве общего шаблона запускайте сопрограммы в ViewModel.------------------

В ViewModelиспользует ProductsRepositoryфактически получает данные. Вот как это выглядит:
class ProductsRepository(val productsDao: ProductsDao) {

  /**
    * This is a "regular" suspending function, which means the caller must
    * be in a coroutine. The repository is not responsible for starting or 
    * stopping coroutines since it doesn't have a natural lifecycle to cancel
    * unnecessary work.
    * Это "обычная" функция приостановки, что означает, что вызывающий должен
    * быть в сопрограмме. Репозиторий не несет ответственности за запуск или
    * остановка сопрограмм, так как у них нет естественного жизненного цикла для отмены
    * ненужная работа.
    *
    * This *may* be called from Dispatchers.Main and is main-safe because
    * Room will take care of main-safety for us.
    * Это *может* вызываться из Dispatchers.Main и является основным безопасным, потому что
    * О главной безопасности позаботится Room.
    */
   suspend fun loadSortedProducts(ascending: Boolean): List<ProductListing> {
       return if (ascending) {
           productsDao.loadProductsByDateStockedAscending()
       } else {
           productsDao.loadProductsByDateStockedDescending()
       }
   }
}

ProductsRepository предоставляет разумный интерфейс для взаимодействия с продуктами. В этом приложении, поскольку все находится в локальной базе данных Room, оно просто предоставляет удобный интерфейс, @Dao который имеет две разные функции для разных порядков сортировки.

Репозиторий является необязательной частью архитектуры компонентов архитектуры Android, но если он у вас есть или аналогичный уровень в вашем приложении, он должен предпочесть предоставлять обычные функции приостановки. Поскольку у репозитория нет естественного жизненного цикла - это просто объект - у него не будет возможности выполнить очистку. В результате любые сопрограммы, запущенные в репозитории, по умолчанию будут протекать.

Помимо предотвращения утечек, благодаря регулярным функциям приостановки репозиторий легко повторно использовать в различных контекстах. Все, что умеет создавать сопрограммы, может вызывать loadSortedProducts. Например, фоновое задание, запланированное библиотекой WorkManager, может вызвать это напрямую.

---------------------------------------------------
Репозиторий должен предпочесть предоставлять обычные функции приостановки- suspend, которые безопасны для основной работы main-safe.
----------------------------------------------------
Примечание. Некоторые фоновые операции сохранения могут потребоваться продолжить после того, как пользователь покинет экран, и имеет смысл запускать эти сохранения без жизненного цикла. В большинстве других случаев viewModelScope это разумный выбор.

Далее ProductsDao это выглядит так:
@Dao
interface ProductsDao {
   // Because this is marked suspend, Room will use it's own dispatcher
   //  to run this query in a main-safe way.
   // Поскольку это помечено как приостановка, Room будет использовать собственный диспетчер
   //   для выполнения этого запроса безопасным способом.
   @Query("select * from ProductListing ORDER BY dateStocked ASC")
   suspend fun loadProductsByDateStockedAscending(): List<ProductListing>

   // Because this is marked suspend, Room will use it's own dispatcher
   //  to run this query in a main-safe way.
   // Поскольку это помечено как приостановка, Room будет использовать собственный диспетчер
   //   для выполнения этого запроса безопасным способом.
   @Query("select * from ProductListing ORDER BY dateStocked DESC")
   suspend fun loadProductsByDateStockedDescending(): List<ProductListing>
} 

ProductsDao это комната, @Dao которая предоставляет две функции приостановки. Поскольку функции отмечены как приостановленные, Room (2.1.0-alpha04) гарантирует, что они безопасны в основном. Это означает, что вы можете позвонить им прямо из Dispatchers.Main. 
**************** https://medium.com/androiddevelopers/room-coroutines-422b786dc4c5
 To use coroutines and Room in your app, update to Room 2.1 and add the new dependency to your build.gradle file:
implementation "androidx.room:room-coroutines:${versions.room}"2.1.0-alpha04 jan 2019
You’ll also need Kotlin 1.3.0 and Coroutines 1.0.0 or newer.
@Dao
interface UsersDao {
    @Query("SELECT * FROM users")
    suspend fun getUsers(): List<User>
    @Query("UPDATE users SET age = age + 1 WHERE userId = :userId")
    suspend fun incrementUserAge(userId: String)
    @Insert
    suspend fun insertUser(user: User)
    @Update
    suspend fun updateUser(user: User)
    @Delete
    suspend fun deleteUser(user: User)
}
DAO with suspend transaction function:
@Dao
abstract class UsersDao {    
    @Transaction
    open suspend fun setLoggedInUser(loggedInUser: User) {
        deleteUser(loggedInUser)
        insertUser(loggedInUser)
    }
    @Query("DELETE FROM users")
    abstract fun deleteUser(user: User)
    @Insert
    abstract suspend fun insertUser(user: User)
}

**********************************************
Небольшое предупреждение: вызывающая это сопрограмма будет в основном потоке. Поэтому, если вы сделали что-то дорогостоящее с результатами - например, преобразовали их в новый список - вы должны убедиться, что не блокируете основной поток.
Примечание: Room использует собственный диспетчер для выполнения запросов в фоновом потоке. Ваш кодне должна использовать withContext(Dispatchers.IO) для вызова приостановки запросов по комнатам. Это усложнит код и замедлит выполнение ваших запросов.

-----------Функции приостановки в Room безопасны в основном и запускаются в настраиваемом диспетчере.-----

----------------Шаблон запроса на один выстрел -----------------
Это полный шаблон для выполнения одноразового запроса с использованием сопрограмм в компонентах архитектуры Android. Мы добавили сопрограммы к ViewModel, Repositoryи Room каждый слой имеет различную ответственность.

1. ViewModel запускает сопрограмму в основном потоке - она ​​завершается, когда получает результат.
2. Репозиторий предоставляет обычные функции приостановки и гарантирует их безопасность для основной работы.
3. База данных и сеть предоставляют регулярные функции приостановки и обеспечивают их безопасность в основной сети.

ViewModel Отвечает за запуск сопрограмм и гарантируя , что они отменят , если пользователь покидает экран. Он не делает дорогих вещей - вместо этого полагается на другие слои для выполнения тяжелой работы. Получив результат, он отправляет его в пользовательский интерфейс, используя LiveData.
Поскольку ViewModelон не выполняет тяжелой работы, он запускает сопрограмму в основном потоке. При запуске в основном он может быстрее реагировать на пользовательские события, если результат доступен немедленно (например, из кеша в памяти).

Предоставляет Repository обычные функции приостановки для доступа к данным. Обычно он не запускает собственные долгоживущие сопрограммы, поскольку у него нет возможности их отменить. Всякий раз, когда Repository нужно делать дорогостоящие вещи, такие как преобразование списка, он должен использовать его withContext для предоставления безопасного для основного интерфейса интерфейса.

Уровень данных (сеть или база данных) всегда предоставляет обычные функции приостановки. Важно, чтобы эти функции приостановки были безопасны для основной работы при использовании сопрограмм Kotlin, и и Room, и Retrofit следуют этому шаблону.

В одноразовом запросе уровень данных предоставляет только функции приостановки. Вызывающий должен позвонить им снова, если им нужно новое значение. Это похоже на кнопку обновления в вашем веб-браузере.

Стоит уделить время тому, чтобы убедиться, что вы понимаете эти шаблоны для одноразовых запросов. Это обычный шаблон для сопрограмм на Android, и вы будете использовать его постоянно.

------------------ Наш первый отчет об ошибке!-----------------------

После тестирования этого решения вы запускаете его в производство, и все идет хорошо в течение нескольких недель, пока вы не получите действительно странный отчет об ошибке:
Тема: 🐞 - неправильный порядок сортировки!
Отчет: Когда я нажимаю кнопки порядка сортировки действительно очень-очень-очень быстро, иногда сортировка бывает неправильной. Такое случается не все время 🙃.

Вы смотрите и чешете в затылке. Что возможно могло пойти не так? Алгоритм кажется довольно простым:
1. Запустите сортировку, запрошенную пользователем.
2. Запустите сортировку в диспетчере помещений.
3. Показать результат сортировки.
У вас возникает соблазн закрыть ошибку «wontfix - не нажимайте кнопки так быстро», но вы беспокоитесь, что что-то может сломаться. После добавления операторов протоколирования и написания теста для одновременного вызова множества видов - вы наконец-то это понимаете!

Оказывается, результат , показанный на самом деле не «результат на то,» это на самом деле результат « последнего сорта к полной.» Когда пользователь спамит кнопку - он запускает несколько сортировок одновременно и может закончить в любом порядке!

--- При запуске новой сопрограммы в ответ на событие пользовательского интерфейса подумайте, что произойдет, если пользователь запустит другую до того, как это завершится.----

Это ошибка параллелизма, и она не имеет ничего общего с сопрограммами. У нас была бы такая же ошибка, если бы мы использовали обратные вызовы, Rx или даже ExecutorService то же самое.
Есть много способов исправить это как в., Так ViewModel и в Repository. Давайте рассмотрим несколько шаблонов, позволяющих гарантировать выполнение одноразовых запросов в ожидаемом пользователем порядке.

------ Лучшее решение: отключить кнопку---------
Основная проблема в том, что мы делаем два вида. Мы можем исправить это, сделав только одну сортировку! Самый простой способ сделать это - отключить кнопки сортировки, чтобы остановить новые события.
Это может показаться простым решением, но это действительно хорошая идея. Код для реализации этого прост, его легко протестировать, и, если он имеет смысл в пользовательском интерфейсе, он полностью решит проблему!
Чтобы отключить кнопки, сообщите пользовательскому интерфейсу, что запрос на сортировку происходит внутри, sortPricesBy например:

// Solution 0: Disable the sort buttons when any sort is running
// Решение 0: отключите кнопки сортировки, когда выполняется какая-либо сортировка

class ProductsViewModel(val productsRepository: ProductsRepository): ViewModel() {
   private val _sortedProducts = MutableLiveData<List<ProductListing>>()
   val sortedProducts: LiveData<List<ProductListing>> = _sortedProducts
  
   private val _sortButtonsEnabled = MutableLiveData<Boolean>()
   val sortButtonsEnabled: LiveData<Boolean> = _sortButtonsEnabled
  
   init {
       _sortButtonsEnabled.value = true
   }

   /**
    * Called by the UI when the user clicks the appropriate sort button
    * Вызывается пользовательским интерфейсом, когда пользователь нажимает соответствующую кнопку сортировки
    */
   fun onSortAscending() = sortPricesBy(ascending = true)
   fun onSortDescending() = sortPricesBy(ascending = false)

   private fun sortPricesBy(ascending: Boolean) {
       viewModelScope.launch {
           // disable the sort buttons whenever a sort is running
	  // отключаем кнопки сортировки всякий раз, когда выполняется сортировка
           _sortButtonsEnabled.value = false
           try {
               _sortedProducts.value =
                       productsRepository.loadSortedProducts(ascending)
           } finally {
               // re-enable the sort buttons after the sort is complete
   	 // повторно активируем кнопки сортировки после завершения сортировки
               _sortButtonsEnabled.value = true
           }
       }
   }
}
Хорошо, это было не так уж плохо. Просто отключите кнопки внутри sortPricesBy звонка в репозиторий.

И в большинстве случаев это верный способ решить эту проблему. Но что, если мы захотим оставить кнопки включенными и исправить ошибку? Это немного сложнее, и мы потратим оставшуюся часть этого поста на изучение нескольких различных вариантов.

Важно: этот код демонстрирует главное преимущество запуска на главном - кнопки мгновенно отключаются в ответ на щелчок. Если вы поменяли диспетчеров, быстрый пользователь медленного телефона может отправить более одного клика!

----------------- Шаблоны параллелизма -----------------

В следующих нескольких разделах рассматриваются сложные темы - и если вы только начинаете работать с сопрограммами, вам не нужно сразу разбираться в них. Простое отключение кнопки - лучшее решение большинства проблем, с которыми вы столкнетесь.

В оставшейся части этого поста мы рассмотрим способы использования сопрограмм, чтобы оставить кнопку включенной, но при этом обеспечить выполнение одноразовых запросов в порядке, который не удивит пользователя. Мы можем сделать это, избегая случайного параллелизма, контролируя, когда сопрограммы запускаются (или не запускаются).

Существует три основных шаблона, которые вы можете использовать для одноразового запроса, чтобы гарантировать, что одновременно выполняется только один запрос.

1. Отмените предыдущую работу, прежде чем начинать новую.
2. Поставьте в очередь следующую работу и дождитесь завершения предыдущих запросов, прежде чем запускать другую.
3. Присоединяйтесь к предыдущей работе, если уже выполняется запрос, просто верните его вместо запуска другого запроса.

Просматривая эти решения, вы заметите, что их реализация имеет некоторую сложность. Чтобы сосредоточиться на том, как использовать эти шаблоны вместо деталей реализации, я создал суть с реализациями всех трех шаблонов в виде многократно используемых абстракций:

******************************
import kotlinx.coroutines.CoroutineStart.LAZY
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.async
import kotlinx.coroutines.cancelAndJoin
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.yield
import java.util.concurrent.atomic.AtomicReference
import kotlin.DeprecationLevel.ERROR

/**
 * A helper class to execute tasks sequentially in coroutines.
 * Вспомогательный класс для последовательного выполнения задач в сопрограммах.
 *
 * Calling [afterPrevious] will always ensure that all previously requested work completes prior to
 * calling the block passed. Any future calls to [afterPrevious] while the current block is running
 * will wait for the current block to complete before starting.
 * Вызов [afterPrevious] всегда гарантирует, что вся ранее запрошенная работа завершится до
 * вызов блока пройден. Любые будущие вызовы [afterPrevious] во время выполнения текущего блока
 * перед запуском будет ждать завершения текущего блока.
 */
class SingleRunner {
    /**
     * A coroutine mutex implements a lock that may only be taken by one coroutine at a time.
     * Мьютекс сопрограммы реализует блокировку, которая может быть взята только одной сопрограммой за раз.
     */
    private val mutex = Mutex()

    /**
     * Ensure that the block will only be executed after all previous work has completed.
     * Убедитесь, что блок будет выполнен только после завершения всей предыдущей работы.
     *
     * When several coroutines call afterPrevious at the same time, they will queue up in the order
     * that they call afterPrevious. Then, one coroutine will enter the block at a time.
     * Когда несколько сопрограмм вызывают afterPrevious одновременно, они выстраиваются в очередь в порядке
     * который они называют afterPrevious. Затем в блок будет входить одна сопрограмма.
     *
     * In the following example, only one save operation (user or song) will be executing at a time.
     * В следующем примере одновременно будет выполняться только одна операция сохранения (пользователя или песни).
     *
     * ```
     * class UserAndSongSaver {
     *    val singleRunner = SingleRunner()
     *
     *    fun saveUser(user: User) {
     *        singleRunner.afterPrevious { api.post(user) }
     *    }
     *
     *    fun saveSong(song: Song) {
     *        singleRunner.afterPrevious { api.post(song) }
     *    }
     * }
     * ```
     *
     * @param block the code to run after previous work is complete.
     * @param блокирует запуск кода после завершения предыдущей работы.
     */
    suspend fun <T> afterPrevious(block: suspend () -> T): T {
        // Before running the block, ensure that no other blocks are running by taking a lock on the
        // mutex.
       // Перед запуском блока убедитесь, что другие блоки не запущены, заблокировав
        // мьютекс.

        // The mutex will be released automatically when we return.
       // Мьютекс будет автоматически освобожден, когда мы вернемся.


        // If any other block were already running when we get here, it will wait for it to complete
        // before entering the `withLock` block.
       // Если какой-либо другой блок уже был запущен, когда мы сюда дойдем, он будет ждать его завершения
        // перед входом в блок `withLock`.
        mutex.withLock {
            return block()
        }
    }
}

/**
 * A controlled runner decides what to do when new tasks are run.
 * Управляемый бегун решает, что делать при запуске новых задач.
 *
 * Note: This implementation is for example only. It will not work in the presence of
 *       multi-threading and is not safe to call from Dispatchers.IO or Dispatchers.Default. In
 *       real code use the thread-safe implementation of [ControlledRunner] code listed below.
 * Примечание: эта реализация приведена только для примера. Не сработает при наличии
 * многопоточность и небезопасно вызывать из Dispatchers.IO или Dispatchers.Default. В
 * реальный код использует поточно-ориентированную реализацию кода [ControlledRunner], перечисленную ниже.
 *
 * By calling [joinPreviousOrRun], the new task will be discarded and the result of the previous task
 * will be returned. This is useful when you want to ensure that a network request to the same
 * resource does not flood.
 * При вызове [joinPreviousOrRun] новая задача будет отброшена, а результат предыдущей задачи
 * будет возвращено. Это полезно, если вы хотите убедиться, что сетевой запрос к тому же
 * ресурс не флудит.
 *
 * By calling [cancelPreviousThenRun], the old task will *always* be cancelled and then the new task will
 * be run. This is useful in situations where a new event implies that the previous work is no
 * longer relevant such as sorting or filtering a list.
 * При вызове [cancelPreviousThenRun] старая задача * всегда * будет отменена, а затем новая задача будет
 * быть запущенным. Это полезно в ситуациях, когда новое событие подразумевает, что предыдущая работа не
 * более актуально, например, сортировка или фильтрация списка.
 */
// @Deprecated ( " Этот код не является потокобезопасным и не должен использоваться. Используйте "  +
//        « Вместо этого приведенная ниже реализация ControlledRunner. » , level =  ERROR )

@Deprecated("This code is not thread-safe and should not be used. Use " +
        "the ControlledRunner implementation below instead.", level = ERROR)
class ControlledRunnerExampleImplementation<T> {
    private var activeTask: Deferred<T>? = null

    /**
     * Cancel all previous tasks before calling block.
     * Отменить все предыдущие задачи перед вызовом блока.
     *
     * When several coroutines call cancelPreviousThenRun at the same time, only one will run and
     * the others will be cancelled.
     * Когда несколько сопрограмм одновременно вызывают cancelPreviousThenRun, запускается только одна
     * остальные будут отменены.
     */

//   @Deprecated ( " Этот код не является потокобезопасным. Вместо этого используйте ControlledRunner ниже. " ,
//            уровень =  ОШИБКА )

    @Deprecated("This code is not thread-safe. Use ControlledRunner below instead.",
            level = ERROR)
    suspend fun cancelPreviousThenRun(block: suspend () -> T): T {
        // If there is an activeTask, cancel it because it's result is no longer needed
        // Если есть activeTask, отмените его, потому что результат больше не нужен
        //
        // By waiting for the cancellation to complete with `cancelAndJoin` we know that activeTask
        // has stopped executing before continuing.
        // Ожидая завершения отмены с помощью `cancelAndJoin`, мы знаем, что activeTask
        // остановил выполнение перед продолжением.
        activeTask?.cancelAndJoin()

        // use a coroutineScope builder to safely start a new coroutine in a suspend function
        // использовать построитель coroutineScope для безопасного запуска новой сопрограммы в функции приостановки
        return coroutineScope {
            // create a new task to call the block
           // создаем новую задачу для вызова блока
            val newTask = async {
                block()
            }
            // when the new task completes, reset activeTask to null
            // this will be called by cancellation as well as normal completion
            // когда новая задача завершается, сбрасываем activeTask на null
            // это будет вызываться как отменой, так и обычным завершением
            newTask.invokeOnCompletion {
                activeTask = null
            }
            // save the newTask to activeTask, then wait for it to complete and return the result
            // сохраняем newTask в activeTask, затем ждем его завершения и возвращаем результат
            activeTask = newTask
            newTask.await()
        }
    }

    /**
     * Don't run the new block if a previous block is running, instead wait for the previous block
     * and return it's result.
     * Не запускайте новый блок, если работает предыдущий блок, вместо этого дождитесь предыдущего блока
     * и вернуть результат.
     *
     * When several coroutines call joinPreviousOrRun at the same time, only one will run and
     * the others will return the result from the winner.
     * Когда несколько сопрограмм вызывают joinPreviousOrRun одновременно, только одна будет запущена и
     * остальные вернут результат от победителя.
     */
//   @Deprecated ( " Этот код не является потокобезопасным. Вместо этого используйте ControlledRunner ниже. " ,
//            уровень =  ОШИБКА )
    @Deprecated("This code is not thread-safe. Use ControlledRunner below instead.",
            level = ERROR)
    suspend fun joinPreviousOrRun(block: suspend () -> T): T {
        // if there is an activeTask, return it's result and don't run the block
       // если есть activeTask, вернуть результат и не запускать блок
        activeTask?.let {
            return it.await()
        }

        // use a coroutineScope builder to safely start a new coroutine in a suspend function
       // использовать построитель coroutineScope для безопасного запуска новой сопрограммы в функции приостановки
        return coroutineScope {
            // create a new task to call the block
	    // создаем новую задачу для вызова блока
            val newTask = async {
                block()
            }
            // when the task completes, reset activeTask to null
            // когда задача завершена, сбрасываем activeTask на null
            newTask.invokeOnCompletion {
                activeTask = null
            }
            // save newTask to activeTask, then wait for it to complete and return the result
            // сохраняем newTask в activeTask, затем ждем его завершения и возвращаем результат
            activeTask = newTask
            newTask.await()
        }
    }
}

/**
 * A controlled runner decides what to do when new tasks are run.
 * Управляемый бегун решает, что делать при запуске новых задач.
 *
 * By calling [joinPreviousOrRun], the new task will be discarded and the result of the previous task
 * will be returned. This is useful when you want to ensure that a network request to the same
 * resource does not flood.
 * При вызове [joinPreviousOrRun] новая задача будет отброшена, а результат предыдущей задачи
 * будет возвращено. Это полезно, если вы хотите убедиться, что сетевой запрос к тому же
 * ресурс не флудит.
 *
 * By calling [cancelPreviousThenRun], the old task will *always* be cancelled and then the new task will
 * be run. This is useful in situations where a new event implies that the previous work is no
 * longer relevant such as sorting or filtering a list.
 * При вызове [cancelPreviousThenRun] старая задача * всегда * будет отменена, а затем новая задача будет
 * быть запущенным. Это полезно в ситуациях, когда новое событие подразумевает, что предыдущая работа не
 * более актуально, например, сортировка или фильтрация списка.
 */
class ControlledRunner<T> {
    /**
     * The currently active task.
     * Текущая активная задача.
     *
     * This uses an atomic reference to ensure that it's safe to update activeTask on both
     * Dispatchers.Default and Dispatchers.Main which will execute coroutines on multiple threads at
     * the same time.
     * Здесь используется атомарная ссылка, чтобы гарантировать безопасное обновление activeTask на обоих
     * Dispatchers.Default и Dispatchers.Main, которые будут выполнять сопрограммы в нескольких потоках в
     * в то же время.
     */
    private val activeTask = AtomicReference<Deferred<T>?>(null)

    /**
     * Cancel all previous tasks before calling block.
     * Отменить все предыдущие задачи перед вызовом блока.
     *
     * When several coroutines call cancelPreviousThenRun at the same time, only one will run and
     * the others will be cancelled.
     * Когда несколько сопрограмм одновременно вызывают cancelPreviousThenRun, запускается только одна
     * остальные будут отменены.
     *
     * In the following example, only one sort operation will execute and any previous sorts will be
     * cancelled.
     * В следующем примере будет выполняться только одна операция сортировки, а все предыдущие сортировки будут
     * отменено.
     *
     * ```
     * class Products {
     *    val controlledRunner = ControlledRunner<Product>()
     *
     *    fun sortAscending(): List<Product> {
     *        return controlledRunner.cancelPreviousThenRun { dao.loadSortedAscending() }
     *    }
     *
     *    fun sortDescending(): List<Product> {
     *        return controlledRunner.cancelPreviousThenRun { dao.loadSortedDescending() }
     *    }
     * }
     * ```
     *
     * @param block the code to run after previous work is cancelled.
     * @return the result of block, if this call was not cancelled prior to returning.
     * @param блокирует выполнение кода после отмены предыдущей работы.
     * @return результат блока, если этот вызов не был отменен до возврата.
     */
    suspend fun cancelPreviousThenRun(block: suspend() -> T): T {
        // fast path: if we already know about an active task, just cancel it right away.
        // быстрый путь: если мы уже знаем об активной задаче, сразу же отмените ее.
        activeTask.get()?.cancelAndJoin()

        return coroutineScope {
            // Create a new coroutine, but don't start it until it's decided that this block should
            // execute. In the code below, calling await() on newTask will cause this coroutine to
            // start.
            // Создаем новую сопрограмму, но не запускаем ее, пока не будет решено, что этот блок должен
            // выполнить. В приведенном ниже коде вызов await () для newTask заставит эту сопрограмму
            // запуск.
            val newTask = async(start = LAZY) {
                block()
            }

            // When newTask completes, ensure that it resets activeTask to null (if it was the
            // current activeTask).
	    // Когда newTask завершается, убедитесь, что он сбрасывает activeTask на null (если это был
            // текущая activeTask).
            newTask.invokeOnCompletion {
                activeTask.compareAndSet(newTask, null)
            }

            // Kotlin ensures that we only set result once since it's a val, even though it's set
            // inside the while(true) loop.
         // Kotlin гарантирует, что мы установим результат только один раз, так как он равен val, даже если он 	// установлен
            // внутри цикла while (true).
            val result: T

            // Loop until we are sure that newTask is ready to execute (all previous tasks are
            // cancelled)
 	    // Цикл, пока мы не будем уверены, что newTask готов к выполнению (все предыдущие задачи
            // отменено)
            while(true) {
                if (!activeTask.compareAndSet(null, newTask)) {
                    // some other task started before newTask got set to activeTask, so see if it's
                    // still running when we call get() here. If so, we can cancel it.
                 // какая-то другая задача началась до того, как newTask был установлен на activeTask, поэтому посмотрите, не
                    // все еще работает, когда мы вызываем здесь get (). Если так, мы можем отменить его.


                    // we will always start the loop again to see if we can set activeTask before
                    // starting newTask.
                  // мы всегда будем запускать цикл снова, чтобы увидеть, можем ли мы установить activeTask перед
                    // запускаем newTask.
                    activeTask.get()?.cancelAndJoin()
                    // yield here to avoid a possible tight loop on a single threaded dispatcher
                    yield()
                } else {
                    // happy path - we set activeTask so we are ready to run newTask
                    // счастливый путь - мы устанавливаем activeTask, поэтому мы готовы запустить newTask
                    result = newTask.await()
                    break
                }
            }
            
            // Kotlin ensures that the above loop always sets result exactly once, so we can return
            // it here!
           // Kotlin гарантирует, что указанный выше цикл всегда устанавливает результат ровно один раз, поэтому мы можем вернуть
            // это здесь!
            result
        }
    }

    /**
     * Don't run the new block if a previous block is running, instead wait for the previous block
     * and return it's result.
     * Не запускайте новый блок, если работает предыдущий блок, вместо этого дождитесь предыдущего блока
     * и вернуть результат.
     *
     * When several coroutines call jonPreviousOrRun at the same time, only one will run and
     * the others will return the result from the winner.
     * Когда несколько сопрограмм вызывают jonPreviousOrRun одновременно, только одна будет запущена и
     * остальные вернут результат от победителя.
     *
     * In the following example, only one network operation will execute at a time and any other
     * requests will return the result from the "in flight" request.
     * В следующем примере одновременно выполняется только одна сетевая операция, а любая другая
     * запросы вернут результат запроса "в полете".
     *
     * ```
     * class Products {
     *    val controlledRunner = ControlledRunner<Product>()
     *
     *    fun fetchProducts(): List<Product> {
     *        return controlledRunner.joinPreviousOrRun {
     *            val results = api.fetchProducts()
     *            dao.insert(results)
     *            results
     *        }
     *    }
     * }
     * ```
     *
     * @param block the code to run if and only if no other task is currently running
     * @return the result of block, or if another task was running the result of that task instead.
     * @param блокирует запуск кода тогда и только тогда, когда никакая другая задача в данный момент не запущена
     * @return результат блока, или если вместо этого другая задача выполняла результат этой задачи.
     */
    suspend fun joinPreviousOrRun(block: suspend () -> T): T {
        // fast path: if there's already an active task, just wait for it and return the result
      // быстрый путь: если уже есть активная задача, просто дождитесь ее и верните результат
        activeTask.get()?.let {
            return it.await()
        }
        return coroutineScope {
            // Create a new coroutine, but don't start it until it's decided that this block should
            // execute. In the code below, calling await() on newTask will cause this coroutine to
            // start.
            // Создаем новую сопрограмму, но не запускаем ее, пока не будет решено, что этот блок должен
            // выполнить. В приведенном ниже коде вызов await () для newTask заставит эту сопрограмму
            // запуск.
            val newTask = async(start = LAZY) {
                block()
            }

            newTask.invokeOnCompletion {
                activeTask.compareAndSet(newTask, null)
            }

            // Kotlin ensures that we only set result once since it's a val, even though it's set
            // inside the while(true) loop.
            // Kotlin гарантирует, что мы установим результат только один раз, так как он равен val, даже если он установлен
            // внутри цикла while (true).
            val result: T

            // Loop until we figure out if we need to run newTask, or if there is a task that's
            // already running we can join.
            // Цикл, пока не выясним, нужно ли нам запускать newTask, или есть задача, которая
            // уже работает, мы можем присоединиться.
            while(true) {
                if (!activeTask.compareAndSet(null, newTask)) {
                    // some other task started before newTask got set to activeTask, so see if it's
                    // still running when we call get() here. There is a chance that it's already
                    // been completed before the call to get, in which case we need to start the
                    // loop over and try again.
                   // какая-то другая задача началась до того, как newTask был установлен на activeTask, поэтому посмотрите, не
                    // все еще работает, когда мы вызываем здесь get (). Есть шанс, что это уже
                    // был завершен до вызова get, и в этом случае нам нужно запустить
                    // зациклиться и повторить попытку.
                    val currentTask = activeTask.get()
                    if (currentTask != null) {
                        // happy path - we found the other task so use that one instead of newTask
                        // счастливый путь - мы нашли другую задачу, поэтому используйте ее вместо newTask
                        newTask.cancel()
                        result = currentTask.await()
                        break
                    } else {
                        // retry path - the other task completed before we could get it, loop to try
                        // setting activeTask again.
                       // путь повтора - другая задача завершена до того, как мы ее получили, цикл для попытки
                        // снова устанавливаем activeTask.

                        // call yield here in case we're executing on a single threaded dispatcher
                        // like Dispatchers.Main to allow other work to happen.
                        // здесь вызываем yield на случай, если мы выполняем однопоточный диспетчер
                        // как Dispatchers.Main, чтобы разрешить выполнение другой работы.
                        yield()
                    }
                } else {
                    // happy path - we were able to set activeTask, so start newTask and return its
                    // result
		    // счастливый путь - мы смогли установить activeTask, поэтому запустите newTask и верните его
                    // результат
                    result = newTask.await()
                    break
                }
            }

            // Kotlin ensures that the above loop always sets result exactly once, so we can return
            // it here!
	    // Kotlin гарантирует, что указанный выше цикл всегда устанавливает результат ровно один раз, поэтому мы можем вернуть
           // это здесь!
            result
        }
    }
}
https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L19
*****************************************************

----------------Решение №1: Отменить предыдущую работу
В случае сортировки получение нового события от пользователя часто означает, что вы можете отменить последнюю сортировку. В конце концов, какой смысл продолжать, если пользователь уже сказал вам, что не хочет результата?
Чтобы отменить предыдущий запрос, нам нужно как-то его отслеживать. Функция cancelPreviousThenRun в сущности делает именно это.
Давайте посмотрим, как это можно использовать для исправления ошибки:

// Solution #1: Cancel previous work


// This is a great solution for tasks like sorting and filtering that
// can be cancelled if a new request comes in.
// Это отличное решение для таких задач, как сортировка и фильтрация
// может быть отменен при поступлении нового запроса.
********************************************************************************************
class ProductsRepository(val productsDao: ProductsDao, val productsApi: ProductsService) {
   var controlledRunner = ControlledRunner<List<ProductListing>>()  //**********************

   suspend fun loadSortedProducts(ascending: Boolean): List<ProductListing> {
       // cancel the previous sorts before starting a new one
       // отменяем предыдущие сортировки перед запуском нового
       return controlledRunner.cancelPreviousThenRun {   //****************************
           if (ascending) {
               productsDao.loadProductsByDateStockedAscending()
           } else {
               productsDao.loadProductsByDateStockedDescending()
           }
       }
   }
}
*******************************************************************************************

Использование cancelPreviousThenRun, чтобы гарантировать, что одновременно выполняется только одна сортировка.
Рассмотрение примера реализации по cancelPreviousThenRun сути - хороший способ увидеть, как отслеживать незавершенную работу.

// see the complete implementation at
// увидеть полную реализацию на
// https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7
suspend fun cancelPreviousThenRun(block: suspend () -> T): T {
   // If there is an activeTask, cancel it because it's result is no longer needed
   // Если есть activeTask, отмените его, потому что результат больше не нужен
   activeTask?.cancelAndJoin()
   
   // ...

Вкратце, он всегда отслеживает текущую активную сортировку в переменной-члене activeTask. Всякий раз, когда начинается сортировка, она немедленно cancelAndJoin выполняется для всего, что находится в данный момент activeTask. Это приводит к отмене любых выполняемых сортировок перед запуском новой.
Лучше использовать абстракции, подобные ControlledRunner<T> этой, вместо того, чтобы смешивать произвольный параллелизм с логикой приложения.
https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L19
----------- Рассмотрите возможность создания абстракций, чтобы избежать смешивания специальных шаблонов параллелизма с кодом приложения. -------------

     Важно: этот шаблон не очень подходит для использования в глобальных одиночных вызовах, поскольку несвязанные вызывающие абоненты не должны отменять друг друга.

---------------- Решение # 2: поставьте следующую работу в очередь -----------------

Есть одно решение для ошибок параллелизма, которое всегда работает.
Просто ставьте запросы в очередь, чтобы одновременно могло происходить только одно! Так же, как очередь или очередь в магазине, запросы будут выполняться по одному в том порядке, в котором они были запущены.
Для этой конкретной проблемы сортировки отмена, вероятно, лучше, чем постановка в очередь, но об этом стоит поговорить, потому что это всегда работает.

// Solution #2: Add a Mutex
// Решение №2: добавить мьютекс

// Note: This is not optimal for the specific use case of sorting
// or filtering but is a good pattern for network saves.
// Примечание: это не оптимально для конкретного варианта использования сортировки
// или фильтрация, но это хороший шаблон для сетевых сохранений.

class ProductsRepository(val productsDao: ProductsDao, val productsApi: ProductsService) {
   val singleRunner = SingleRunner()

   suspend fun loadSortedProducts(ascending: Boolean): List<ProductListing> {
       // wait for the previous sort to complete before starting a new one
      // ожидаем завершения предыдущей сортировки перед началом новой
       return singleRunner.afterPrevious {
           if (ascending) {
               productsDao.loadProductsByDateStockedAscending()
           } else {
               productsDao.loadProductsByDateStockedDescending()
           }
       }
   }
}

Когда появляется новая сортировка, она использует экземпляр, SingleRunner чтобы гарантировать, что одновременно выполняется только одна сортировка.
Он использует a Mutex , который представляет собой единый билет (или блокировку), который сопрограмма должна получить, чтобы войти в блок. Если другая сопрограмма попытается выполнить попытку во время выполнения одной, она приостановится, пока все ожидающие сопрограммы не будут выполнены с Mutex.

------ Mutex позволяет вам гарантировать, что одновременно запускается только одна сопрограмма - и они будут завершаться в том порядке, в котором они были запущены. ------

---------------- Решение 3. Присоединяйтесь к предыдущей работе ----------------

Третье решение - присоединиться к предыдущей работе. Было бы неплохо, если бы новый запрос снова начал ту же работу, которая уже была наполовину завершена.

Этот шаблон не имеет особого смысла с функцией сортировки, но он естественным образом подходит для сетевой выборки, которая загружает данные.

Для нашего приложения для инвентаризации продуктов пользователю потребуется способ получить новую инвентаризацию продуктов с сервера. В качестве простого пользовательского интерфейса мы предоставим им кнопку обновления, которую они могут нажать, чтобы начать новый сетевой запрос.
Как и кнопки сортировки, простое отключение кнопки во время выполнения запроса - полное решение проблемы. Но если бы мы этого не сделали - или не смогли - мы могли бы вместо этого присоединиться к существующему запросу.

Давайте посмотрим на код с использованием joinPreviousOrRun из сути, чтобы увидеть, как это может работать:

class ProductsRepository(val productsDao: ProductsDao, val productsApi: ProductsService) {
   var controlledRunner = ControlledRunner<List<ProductListing>>()

   suspend fun fetchProductsFromBackend(): List<ProductListing> {
       // if there's already a request running, return the result from the 
       // existing request. If not, start a new request by running the block.
	// если уже выполняется запрос, вернуть результат из
       // существующий запрос. Если нет, запустите новый запрос, запустив блок.
       return controlledRunner.joinPreviousOrRun {
           val result = productsApi.getProducts()
           productsDao.insertAll(result)
           result
       }
   }
}
Это меняет поведение cancelPreviousAndRun. Вместо того, чтобы отбросить предыдущий запрос путем его отмены, он отклонит новый запрос и не запустит его. Если запрос уже выполняется, он ожидает результата текущего запроса «в полете» и возвращает его вместо выполнения нового. Блок будет выполнен только в том случае, если еще не было запущенного запроса.

Вы можете увидеть, как это работает в начале joinPreviousOrRun - он просто возвращает предыдущий результат, если в нем что-то есть activeTask:

// see the complete implementation at
// увидеть полную реализацию на
// https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L124

suspend fun joinPreviousOrRun(block: suspend () -> T): T {
    // if there is an activeTask, return it's result and don't run the block
	// если есть activeTask, вернуть результат и не запускать блок
    activeTask?.let {
        return it.await()
    }
    // ...
Этот шаблон хорошо масштабируется для таких запросов, как получение товаров от id. Вы можете добавить карту из id в, а Deferred затем использовать ту же логику соединения, чтобы отслеживать предыдущие запросы для того же продукта.

------------ Присоединиться к предыдущей работе - отличное решение, чтобы избежать повторных сетевых запросов. ---

===================== Что дальше?================================

В этом посте мы изучили, как реализовать одноразовый запрос с помощью сопрограмм Kotlin. Для начала мы реализовали полный шаблон, показывающий, как запустить сопрограмму в файлах, ViewModel а затем предоставить обычные функции приостановки из a Repository и Room Dao.
Для большинства задач это все, что вам нужно сделать, чтобы использовать сопрограммы Kotlin на Android. Этот шаблон можно применить ко многим распространенным задачам, таким как сортировка списка, как мы показали здесь. Вы также можете использовать его для получения, сохранения или обновления данных в сети.
Затем мы рассмотрели небольшую ошибку, которая может возникнуть, и возможные решения. Самый простой (и часто лучший) способ исправить это - в пользовательском интерфейсе - просто отключите кнопки сортировки, пока сортировка выполняется.
В заключение мы рассмотрели некоторые расширенные шаблоны параллелизма и способы их реализации в сопрограммах Kotlin. Код для этого является немного сложным, но это действительно обеспечивает хорошее введение в некоторую продвинутую Сопрограмме тему.

В следующем посте мы рассмотрим запросы потоковой передачи и узнаем, как использовать liveDataконструктор!
In the next post, we’ll take a look at streaming requests and explore how to use the liveData builder!