# Using Kotlin Coroutines in your Android app

This folder contains the source code for the [Kotlin Coroutines codelab](https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html).

## License

    Copyright 2018 Google LLC

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    Вот фрагмент кода, чтобы дать вам представление о том, что вы будете делать.

    // Async callbacks
    networkRequest { result ->
       // Successful network request
       databaseSave(result) { rows ->
         // Result saved
       }
    }

    Код на основе обратного вызова будет преобразован в последовательный код с помощью сопрограмм.

    // The same code with coroutines
    val result = networkRequest()
    // Successful network request
    databaseSave(result)
    // Result saved

    Что ты будешь делать
    Вызовите код, написанный с помощью сопрограмм, и получите результат.
    Используйте функции приостановки, чтобы сделать асинхронный код последовательным.
    Используйте launchи runBlockingдля управления выполнением кода.
    Изучите методы преобразования существующих API в сопрограммы с использованием suspendCoroutine.
    Используйте сопрограммы с компонентами архитектуры.
    Изучите передовой опыт тестирования сопрограмм.

    start - Простое приложение, использующее компоненты архитектуры Android, в которые вы будете добавлять сопрограммы
    finished_code - проект с уже добавленными сопрограммами
    my - мое с комменатирями на русском  от start к finish

Это начальное приложение использует потоки для увеличения счетчика через короткую задержку после нажатия на экран.
Он также получит новый заголовок из сети и отобразит его на экране.
Попробуйте сейчас, и вы увидите, что счетчик и сообщение изменится после небольшой задержки.
В этой лаборатории кода вы конвертируете это приложение для использования сопрограмм.

MainActivityотображает пользовательский интерфейс, регистрирует слушателей кликов и может отображать Snackbar.
 Она проходит события в MainViewModelи обновляет экран , основанный на LiveDataв MainViewModel.
MainViewModelобрабатывает события onMainViewClickedи будет общаться с MainActivityиспользованиемLiveData.
Executorsопределяет, BACKGROUND,что может запускать вещи в фоновом потоке.
TitleRepository получает результаты из сети и сохраняет их в базе данных.

kotlinx-coroutines-core - Основной интерфейс для использования сопрограмм в Kotlin
kotlinx-coroutines-android - Поддержка основного потока Android в сопрограммах

4. Сопрограммы в Котлине --------------------------------------------------------------------

На Android важно избегать блокировки основного потока.
Основной поток - это единственный поток, который обрабатывает все обновления пользовательского интерфейса.
Это также поток, который вызывает все обработчики кликов и другие обратные вызовы пользовательского интерфейса.
Таким образом, он должен работать бесперебойно, чтобы гарантировать удобство использования.

Чтобы ваше приложение отображалось для пользователя без каких-либо видимых пауз,
основной поток должен обновлять экран каждые 16 мс или более , что составляет около 60 кадров в секунду.
Многие общие задачи занимают больше времени, например, анализ больших наборов данных JSON,
запись данных в базу данных или выборка данных из сети.
Следовательно, подобный вызов кода из основного потока может привести к приостановке,
заиканию или даже зависанию приложения.
А если вы слишком долго блокируете основной поток, приложение может даже аварийно завершить работу
и отобразить диалоговое окно « Приложение не отвечает ».

Шаблон обратного вызова
Один из способов выполнения длительных задач без блокировки основного потока - это обратные вызовы.
Используя обратные вызовы, вы можете запускать длительные задачи в фоновом потоке.
Когда задача завершается, вызывается обратный вызов, чтобы сообщить вам о результате в основном потоке.

Взгляните на пример шаблона обратного вызова.

// Slow request with callbacks
@UiThread
fun makeNetworkRequest() {
    // The slow network request runs on another thread
    slowFetch { result ->
        // When the result is ready, this callback will get the result
        show(result)
    }
    // makeNetworkRequest() exits after calling slowFetch without waiting for the result
}

Поскольку этот код снабжен аннотацией @UiThread, он должен выполняться достаточно быстро для выполнения в основном потоке.
Это означает, что он должен возвращаться очень быстро, чтобы следующее обновление экрана не было отложено.
Однако, поскольку slowFetch для завершения потребуется секунды или даже минуты,
основной поток не может дождаться результата.
show(result)Обратный вызов позволяет slowFetchзапускать в фоновом потоке и возвращает результат ,
 когда он будет готов.

 Обратные вызовы - отличный шаблон, однако у них есть несколько недостатков.
 Код, который активно использует обратные вызовы, может стать трудным для чтения и более трудным для размышлений.
 Кроме того, обратные вызовы не позволяют использовать некоторые языковые функции, например исключения.

 Использование сопрограмм для удаления обратных вызовов

Сопрограммы Kotlin позволяют преобразовывать код на основе обратного вызова в последовательный код.
Код, написанный последовательно, обычно легче читается и даже может использовать языковые функции,
такие как исключения.

В конце концов, они делают то же самое:
ждут, пока не станет доступен результат из долго выполняющейся задачи, и продолжают выполнение.
Однако в коде они выглядят совсем иначе.

Ключевое слово suspend- это способ Kotlin пометить функцию или тип функции, доступную для сопрограмм.
 Когда сопрограмма вызывает отмеченную функцию suspend, вместо блокировки до тех пор, пока эта функция не вернется,
 как при обычном вызове функции, она приостанавливает выполнение до тех пор, пока результат не будет готов,
 а затем возобновляет работу с того места, где было остановлено с результатом.
 Пока он приостанавливается в ожидании результата, он разблокирует поток, в котором он запущен,
 чтобы другие функции или сопрограммы могли запускаться.

 Например, в приведенном ниже коде makeNetworkRequest() и slowFetch() являются обеими suspend функциями.

 // Slow request with coroutines
 @UiThread
 suspend fun makeNetworkRequest() {
     // slowFetch is another suspend function so instead of
     // blocking the main thread  makeNetworkRequest will `suspend` until the result is
     // ready
     // медленная выборка-это еще одна функция приостановки, поэтому вместо
     // блокировки основного потока, сделать сетевой запрос будет "приостановить", пока результат не будет
     // готовый
     val result = slowFetch()
     // continue to execute after the result is ready
     // продолжайте выполнение после того, как результат будет готов
     show(result)
 }

 // slowFetch is main-safe using coroutines
 // медленная выборка является основной-безопасной с использованием сопрограмм
 suspend fun slowFetch(): SlowResult { ... }

Как и в случае с версией обратного вызова,
 он makeNetworkRequest должен сразу же вернуться из основного потока, потому что он отмечен @UiThread.
 Это означает, что обычно он не мог вызывать такие методы блокировки, как slowFetch.
 Вот где suspend ключевое слово творит чудеса.

 Важно : suspend ключевое слово не указывает, на каком коде потока выполняется.
         Функции приостановки могут выполняться в фоновом или основном потоке.

По сравнению с кодом, основанным на обратном вызове,
код сопрограммы обеспечивает тот же результат разблокировки текущего потока с меньшим количеством кода.
Благодаря последовательному стилю легко объединить несколько длительных задач
без создания множества обратных вызовов.
Например, код, который получает результат от двух конечных точек сети и сохраняет его в базе данных,
может быть записан как функция в сопрограммах без обратных вызовов.
Вот так:
@WorkerThread
suspend fun makeNetworkRequest() {
    // slowFetch and anotherFetch are suspend functions
    // медленная выборка и другая выборка являются функциями приостановки
    val slow = slowFetch()
    val another = anotherFetch()
    // save is a regular function and will block this thread
    // save-это обычная функция, которая блокирует этот поток
    database.save(slow, another)
}

// slowFetch is main-safe using coroutines
// медленная выборка является основной-безопасной с использованием сопрограмм
suspend fun slowFetch(): SlowResult { ... }
// anotherFetch is main-safe using coroutines
// еще одна выборка является основной-безопасной с использованием сопрограмм
suspend fun anotherFetch(): AnotherResult { ... }

Сопрограммы под другим именем
Паттерн asyncи awaitна других языках основан на сопрограммах.
Если вы знакомы с этим шаблоном, suspend ключевое слово похоже на async.
Однако в Котлине await() это неявно при вызове suspend функции.
В Kotlin есть метод, Deferred.await()
 который используется для ожидания результата от сопрограммы,
 запущенной asyncпостроителем.

5. Управление пользовательским интерфейсом с помощью сопрограмм -------------------------------

В этом упражнении вы напишете сопрограмму для отображения сообщения после задержки.
Понимание CoroutineScope
В Kotlin все сопрограммы выполняются внутри CoroutineScope.
Область видимости контролирует время жизни сопрограмм посредством своей работы.
Когда вы отменяете задание области видимости, она отменяет все сопрограммы, запущенные в этой области.
В Android вы можете использовать область видимости для отмены всех запущенных сопрограмм,
когда, например, пользователь уходит от Activityили Fragment.
Области также позволяют указать диспетчера по умолчанию.
Диспетчер контролирует, какой поток запускает сопрограмму.

Для сопрограмм, запускаемых пользовательским интерфейсом,
обычно правильно запускать их на том, Dispatchers.Mainкоторый является основным потоком в Android.
Запущенная сопрограмма Dispatchers.Main не будет блокировать основной поток во время приостановки.
Поскольку ViewModelсопрограмма почти всегда обновляет пользовательский интерфейс в основном потоке,
запуск сопрограмм в основном потоке позволяет сэкономить дополнительные переключатели потоков.
Сопрограмма, запущенная в основном потоке, может переключать диспетчеров в любое время после запуска.
Например, он может использовать другой диспетчер для синтаксического анализа
большого результата JSON из основного потока.

Сопрограммы предлагают основную безопасность
Поскольку сопрограммы могут легко переключать потоки в любое время и передавать результаты обратно в исходный поток,
рекомендуется запускать связанные с пользовательским интерфейсом сопрограммы в основном потоке.
Библиотеки любят Roomи Retrofitпредлагают основную безопасность при использовании сопрограмм,
поэтому вам не нужно управлять потоками для выполнения сетевых вызовов или вызовов базы данных.
Это часто может привести к существенно более простому коду.
Однако блокирующий код, такой как сортировка списка или чтение из файла,
по-прежнему требует явного кода для создания основной безопасности, даже при использовании сопрограмм.
Это также верно, если вы используете сетевую библиотеку или библиотеку базы данных,
которая (пока) не поддерживает сопрограммы.

Использование viewModelScope
Библиотека AndroidX lifecycle-viewmodel-ktx добавляет CoroutineScope к ViewModels,
который настроен для запуска сопрограмм, связанных с пользовательским интерфейсом.
Чтобы использовать эту библиотеку, вы должны включить ее в build.gradle (Module: start)файл вашего проекта.
Этот шаг уже выполнен в проектах codelab.

dependencies {
  ...
  реализация "androidx.lifecycle: lifecycle-viewmodel-ktx: xxx"
}

Библиотека добавляет viewModelScope как функцию расширения ViewModelкласса.
Эта область связана с Dispatchers.Mainи будет автоматически отменена, когда ViewModelбудет очищена.

Переход от потоков к сопрограммам

В MainViewModel.ktнайти следующее TODO вместе с этим кодом:

MainViewModel.kt
/**
* Wait one second then update the tap count.
*/
private fun updateTaps() {
   // TODO: Convert updateTaps to use coroutines
   tapCount++
   BACKGROUND.submit {
       Thread.sleep(1_000)
       _taps.postValue("$tapCount taps")
   }
}

Этот код использует BACKGROUND ExecutorService(определенный в util/Executor.kt) для работы в фоновом потоке.
Поскольку sleep блокирует текущий поток, он заморозит пользовательский интерфейс,
если он будет вызван в основном потоке.
Через секунду после того, как пользователь щелкает по основному экрану, он запрашивает снэк-бар.

Вы можете убедиться в этом, удалив ФОН из кода и запустив его снова.
Счетчик загрузки не отображается, и через секунду все "перескакивает" в конечное состояние.

Замените updateTapsэтим кодом на основе сопрограмм, который делает то же самое.
Вам нужно будет импортировать launchи delay.
fun updateTaps() {
   // launch a coroutine in viewModelScope
   viewModelScope.launch {
       tapCount++
       // suspend this coroutine for one second
       delay(1_000)
       // resume in the main dispatcher
       // _snackbar.value can be called directly from main thread
       _taps.postValue("$tapCount taps")
   }
}
Этот код делает то же самое, ожидая одну секунду перед отображением закусочной.
Однако есть несколько важных отличий:

viewModelScope.launch запустит сопрограмму в viewModelScope.
 Это означает, что когда задание, которое мы передали, viewModelScopeбудет отменено,
  все сопрограммы в этом задании / области будут отменены.
   Если пользователь покинул Activity до delayвозврата, эта сопрограмма будет автоматически отменена,
    когда onClearedвызывается при уничтожении ViewModel.
Поскольку viewModelScopeпо умолчанию установлен диспетчер Dispatchers.Main,
 эта сопрограмма будет запущена в основном потоке.
  Позже мы увидим, как использовать разные потоки.
Функция delayесть suspendфункция. В Android Studio это отображается значком в левом желобе.
 Несмотря на то, что эта сопрограмма выполняется в основном потоке, delay не блокирует поток ни на секунду.
  Вместо этого диспетчер планирует возобновить сопрограмму через одну секунду при выполнении следующего оператора.

Давай, беги. Когда вы щелкнете по главному экрану, через секунду вы увидите закусочную.

В следующем разделе мы рассмотрим, как протестировать эту функцию.

6. Тестирование сопрограмм через поведение -----------------------------------------

В этом упражнении вы напишете тест для только что написанного кода.
В этом упражнении показано, как тестировать работающие сопрограммы с Dispatchers.Main помощью библиотеки kotlinx-coroutines-test.
Позже в этой кодовой лаборатории вы реализуете тест, который напрямую взаимодействует с сопрограммами.

kotlinx-coroutines-testБиблиотека , используемая в данном разделе помечается как экспериментальные
и может иметь важные изменения до выпуска.

Правило - это способ запуска кода до и после выполнения теста в JUnit.
 Два правила используются, чтобы позволить нам протестировать MainViewModel в тесте вне устройства:

InstantTaskExecutorRule это правило JUnit, которое настраивает LiveData синхронное выполнение каждой задачи
MainCoroutineScopeRule- это настраиваемое правило в этой кодовой базе,
 которое настраивается Dispatchers.Main на использование TestCoroutineDispatcherfrom kotlinx-coroutines-test.
  Это позволяет тестам продвигать виртуальные часы для тестирования и позволяет использовать код Dispatchers.Mainв модульных тестах.
В этом setupметоде новый экземпляр MainViewModelсоздается с использованием подделок тестирования
 - это поддельные реализации сети и базы данных, представленные в стартовом коде,
  чтобы помочь писать тесты без использования реальной сети или базы данных.

Для этого теста подделки нужны только для удовлетворения зависимостей MainViewModel.
 Позже в этой лаборатории кода вы обновите подделки для поддержки сопрограмм.
@Test
fun whenMainClicked_updatesTaps() {
   subject.onMainViewClicked()
   Truth.assertThat(subject.taps.getValueForTest()).isEqualTo("0 taps")
   coroutineScope.advanceTimeBy(1000)
   Truth.assertThat(subject.taps.getValueForTest()).isEqualTo("1 taps")
}
При вызове onMainViewClickedбудет запущена только что созданная сопрограмма. Этот тест проверяет, что текст нажатий остается «0 нажатий» сразу после onMainViewClickedвызова, а затем через 1 секунду он обновляется до «1 нажатий» .

Этот тест использует виртуальное время для управления выполнением сопрограммы, запущенной onMainViewClicked. MainCoroutineScopeRuleПозволяет приостановить, возобновить или контролировать выполнение сопрограмм, которые запускаются на Dispatchers.Main. Здесь мы вызываем, advanceTimeBy(1_000)что заставит главного диспетчера немедленно выполнить сопрограммы, возобновление которых запланировано на 1 секунду позже.

Этот тест полностью детерминирован, что означает, что он всегда будет выполняться одинаково. И, поскольку он полностью контролирует выполнение запускаемых сопрограмм, Dispatchers.Mainему не нужно ждать одну секунду, пока значение не будет установлено.
Запустить существующий тест

https://developer.android.com/codelabs/kotlin-coroutines?return=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fandroid-coroutines%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fkotlin-coroutines#6
7. Переход от обратных вызовов к сопрограммам

На этом шаге вы начнете преобразовывать репозиторий для использования сопрограмм.
 Для этого мы добавим сопрограмм к ViewModel, Repository, Roomи Retrofit.

Хорошая идея - понять, за что отвечает каждая часть архитектуры,
 прежде чем мы переключим их на использование сопрограмм.

MainDatabase реализует базу данных с использованием Room, которая сохраняет и загружает файл Title.
MainNetwork реализует сетевой API, который получает новый заголовок.
 Он использует Retrofit для получения заголовков.
  Retrofitнастроен на случайный возврат ошибок или фиктивных данных,
   но в остальном ведет себя так, как если бы он делал реальные сетевые запросы.
TitleRepository реализует единый API для извлечения или обновления заголовка
 путем объединения данных из сети и базы данных.
MainViewModelпредставляет состояние экрана и обрабатывает события.
 Он скажет репозиторию обновить заголовок, когда пользователь коснется экрана.
Поскольку сетевой запрос управляется UI-событиями, и мы хотим запустить на их основе сопрограмму,
 естественным местом для начала использования сопрограмм является файл ViewModel.

Версия обратного вызова
/**
* Refresh the title, showing a loading spinner while it refreshes and errors via snackbar.
*/
fun refreshTitle() {
   // TODO: Convert refreshTitle to use coroutines
   _spinner.value = true
   repository.refreshTitleWithCallbacks(object: TitleRefreshCallback {
       override fun onCompleted() {
           _spinner.postValue(false)
       }

       override fun onError(cause: Throwable) {
           _snackBar.postValue(cause.message)
           _spinner.postValue(false)
       }
   })
}
В этой реализации обратный вызов используется для следующих действий:

Перед тем, как начать запрос, он отображает счетчик загрузки с _spinner.value = true
Когда он получает результат, он очищает счетчик загрузки с помощью _spinner.value = false
Если появляется ошибка, он сообщает снэк-панели отображать и очищает счетчик
Обратите внимание, что onCompletedобратный вызов не передается title.
Поскольку мы записываем все заголовки в Roomбазу данных,
 пользовательский интерфейс обновляется до текущего заголовка,
  наблюдая за LiveDataобновленным файлом Room.

В обновлении сопрограмм мы сохраним точно такое же поведение.
Хорошим шаблоном является использование наблюдаемого источника данных, такого как Room база данных,
чтобы автоматически поддерживать пользовательский интерфейс в актуальном состоянии.

Что значит?object: TitleRefreshCallback
Это способ создания анонимного класса в Котлине.
Он создает новый объект, который реализует TitleRefreshCallback.

Версия сопрограмм------------------
Давайте перепишем refreshTitleсопрограммы!
Поскольку он нам понадобится сразу, давайте сделаем пустую функцию приостановки в нашем репозитории ( TitleRespository.kt). Определите новую функцию, которая использует suspendоператор, чтобы сообщить Kotlin, что он работает с сопрограммами.

TitleRepository.kt
suspend fun refreshTitle() {
    // TODO: Refresh from network and write to database
    delay(500)
}

Когда вы закончите с этой кодовой лабораторией, вы обновите ее,
 чтобы использовать Retrofit и Room для получения нового заголовка
  и записи его в базу данных с помощью сопрограмм.
   На данный момент он просто потратит 500 миллисекунд, делая вид, что выполняет работу, а затем продолжит.

В MainViewModel замените версию обратного вызова refreshTitleтой, которая запускает новую сопрограмму:

MainViewModel.kt

/**
* Refresh the title, showing a loading spinner while it refreshes and errors via snackbar.
*/
fun refreshTitle() {
   viewModelScope.launch {
       try {
           _spinner.value = true
           repository.refreshTitle()
       } catch (error: TitleRefreshError) {
           _snackBar.value = error.message
       } finally {
           _spinner.value = false
       }
   }
}

Давайте пройдемся по этой функции:
viewModelScope.launch {
Точно так же, как сопрограмма для обновления количества нажатий,
 начните с запуска новой сопрограммы в viewModelScope.
  Это будет использовать, Dispatchers.Main что нормально.
   Несмотря на то, что он refreshTitle будет выполнять сетевой запрос и запрос к базе данных,
    он может использовать сопрограммы для предоставления основного безопасного интерфейса.
     Это означает, что его можно будет безопасно вызывать из основного потока.

Поскольку мы используем viewModelScope, когда пользователь уходит от этого экрана,
 работа, начатая этой сопрограммой, автоматически отменяется.
  Это означает, что он не будет делать дополнительных сетевых запросов или запросов к базе данных.

  При создании сопрограммы из не-сопрограммы начните с launch .
  Таким образом, если они генерируют неперехваченное исключение,
   оно автоматически распространяется на обработчики неперехваченных исключений
    (которые по умолчанию вызывают сбой приложения).

Сопрограмма, запущенная с async, не будет генерировать исключение для вызывающего, пока вы не вызовете await.
Однако вы можете вызывать только await изнутри сопрограммы, поскольку это функция приостановки.
Оказавшись внутри сопрограммы, вы можете использовать запуск или асинхронный запуск
 для запуска дочерних сопрограмм.
  Используйте, launch когда у вас нет результата, который нужно вернуть, и async когда он есть.


  Следующие несколько строк кода на самом деле назвать refreshTitleв repository.

  try {
      _spinner.value = true
      repository.refreshTitle()
  }

  Прежде чем эта сопрограмма что-либо сделает, она запускает счетчик загрузки,
   а затем вызывает его refreshTitleкак обычную функцию.
    Однако, поскольку refreshTitleэто функция приостановки, она выполняется иначе, чем обычная функция.

  Нам не нужно передавать обратный вызов.
  Сопрограмма будет приостановлена, пока не будет возобновлена refreshTitle.
  Хотя это выглядит так же, как обычный вызов функции блокировки,
  он автоматически ожидает завершения запроса сети и базы данных,
   прежде чем возобновить работу без блокировки основного потока.

   } catch (error: TitleRefreshError) {
       _snackBar.value = error.message
   } finally {
       _spinner.value = false
   }

   Исключения в приостановленных функциях работают так же, как ошибки в обычных функциях.
   Если вы выдаете ошибку в функции приостановки, она будет передана вызывающей стороне.
   Таким образом, даже если они выполняются совершенно по-разному,
   вы можете использовать обычные блоки try / catch для их обработки.
   Это полезно, поскольку позволяет полагаться на встроенную языковую поддержку обработки ошибок
   вместо создания настраиваемой обработки ошибок для каждого обратного вызова.

   И, если вы выбросите исключение из сопрограммы, эта сопрограмма по умолчанию отменит своего родителя.
   Это означает, что можно легко отменить несколько связанных задач вместе.

   А затем, в блоке finally, мы можем убедиться, что счетчик всегда выключен после выполнения запроса.

  Что происходит с неперехваченными исключениями
  Неперехваченные исключения в сопрограмме аналогичны неперехваченным исключениям в коде, отличном от сопрограммы.
  По умолчанию они отменяют сопрограммы Job и уведомляют родительские сопрограммы о том, что они должны отменить себя.
  Если никакая сопрограмма не обрабатывает исключение,
  оно в конечном итоге будет передано обработчику неперехваченных исключений в CoroutineScope.

  По умолчанию неперехваченные исключения будут отправлены обработчику неперехваченных исключений потока на JVM.
  Вы можете настроить это поведение, предоставив CoroutineExceptionHandler .

  8. Создание основных безопасных функций из блокирующего кода -------------------------------

  В этом упражнении вы узнаете, как переключить поток, в котором выполняется сопрограмма,
   чтобы реализовать рабочую версию TitleRepository.

   Откройте TitleRepository.ktи просмотрите существующую реализацию на основе обратного вызова.

   TitleRepository.kt
   fun refreshTitleWithCallbacks(titleRefreshCallback: TitleRefreshCallback) {
      // This request will be run on a background thread by retrofit
      BACKGROUND.submit {
          try {
              // Make network request using a blocking call
              val result = network.fetchNextTitle().execute()
              if (result.isSuccessful) {
                  // Save it to database
                  titleDao.insertTitle(Title(result.body()!!))
                  // Inform the caller the refresh is completed
                  titleRefreshCallback.onCompleted()
              } else {
                  // If it's not successful, inform the callback of the error
                  titleRefreshCallback.onError(
                          TitleRefreshError("Unable to refresh title", null))
              }
          } catch (cause: Throwable) {
              // If anything throws an exception, inform the caller
              titleRefreshCallback.onError(
                      TitleRefreshError("Unable to refresh title", cause))
          }
      }
   }

В TitleRepository.ktметоде refreshTitleWithCallbacksреализован обратный вызов,
 чтобы сообщить вызывающему о загрузке и состоянии ошибки.

Эта функция делает несколько вещей, чтобы реализовать обновление.
Переключиться на другой поток с помощью BACKGROUND ExecutorService
Выполните fetchNextTitleсетевой запрос с помощью execute()метода блокировки.
 Это запустит сетевой запрос в текущем потоке, в данном случае в одном из потоков в BACKGROUND.
Если результат успешный, сохраните его в базе данных с помощью insertTitleи вызовите onCompleted()метод.
Если результат оказался неудачным или возникло исключение,
 вызовите метод onError, чтобы сообщить вызывающей стороне о неудачном обновлении.

 Эта реализация на основе обратного вызова является основной, потому что она не блокирует основной поток.
 Но он должен использовать обратный вызов, чтобы сообщить вызывающему, когда работа завершена.
 Он также вызывает обратные вызовы в BACKGROUND потоке, который он тоже переключил.

 Вызов блокировки вызовов из сопрограмм -------------------
 Не вводя сопрограммы в сеть или базу данных,
 мы можем сделать этот код безопасным для основной работы с помощью сопрограмм.
 Это позволит нам избавиться от обратного вызова и передать результат обратно потоку,
 который его изначально вызвал.

 Вы можете использовать этот шаблон в любое время,
 когда вам нужно выполнить блокирующую или интенсивную работу ЦП из сопрограммы,
 такую ​​как сортировка и фильтрация большого списка или чтение с диска.

 Этот шаблон следует использовать для интеграции с API-интерфейсами блокировки в вашем коде
 или для выполнения интенсивной работы с ЦП.
 По возможности лучше использовать обычные функции приостановки из библиотек, таких как Room или Retrofit.

 Для переключения между любым диспетчером сопрограммы используют withContext.
 Вызов withContextпереключается на другой диспетчер только для лямбды,
 затем возвращается к диспетчеру, который вызвал его с результатом этой лямбды.

 По умолчанию Котлин сопрограммы предоставляет три диспетчеры: Main, IO, и Default.
 Диспетчер ввода-вывода оптимизирован для работы ввода-вывода,
 такой как чтение из сети или с диска, в то время как диспетчер по умолчанию
 оптимизирован для задач с интенсивным использованием ЦП.

suspend fun refreshTitle() {
   // interact with *blocking* network and IO calls from a coroutine
   withContext(Dispatchers.IO) {
       val result = try {
           // Make network request using a blocking call
           network.fetchNextTitle().execute()
       } catch (cause: Throwable) {
           // If the network throws an exception, inform the caller
           throw TitleRefreshError("Unable to refresh title", cause)
       }

       if (result.isSuccessful) {
           // Save it to database
           titleDao.insertTitle(Title(result.body()!!))
       } else {
           // If it's not successful, inform the callback of the error
           throw TitleRefreshError("Unable to refresh title", null)
       }
   }
}

Эта реализация использует блокирующие вызовы для сети и базы данных,
но все же немного проще, чем версия обратного вызова.

Этот код все еще использует блокирующие вызовы.
Оба вызова execute() и insertTitle(...) будут блокировать поток, в котором выполняется эта сопрограмма.
Однако, переключаясь на Dispatchers.IO использование withContext,
мы блокируем один из потоков в диспетчере ввода-вывода.
Сопрограмма, которая вызвала это, возможно, запущенная Dispatchers.Main,
будет приостановлена​до завершения withContextлямбда.

По сравнению с версией обратного вызова есть два важных отличия:

withContextв данном случае возвращает результат обратно диспетчеру, который его вызвал Dispatchers.Main.
Версия обратного вызова вызвала обратные вызовы в потоке в BACKGROUNDслужбе исполнителя.

Вызывающий не должен передавать обратный вызов этой функции.
Они могут полагаться на приостановку и возобновление, чтобы получить результат или ошибку.

Совет для продвинутых
Этот код не поддерживает отмену сопрограмм, но может!
 Отмена сопрограммы осуществляется совместно.
  Это означает, что ваш код должен явно проверять отмену,
   что происходит с вами всякий раз, когда вы вызываете функции в kotlinx-coroutines.

Поскольку этот withContextблок вызывает только блокирующие вызовы, он не будет отменен,
 пока не вернется из withContext.
Чтобы исправить это, вы можете yield регулярно звонить,
 чтобы дать другим сопрограммам шанс запустить и проверить отмену.
  Здесь вы должны добавить вызов yield между сетевым запросом и запросом к базе данных.
   Затем, если сопрограмма будет отменена во время сетевого запроса, она не сохранит результат в базе данных.
Вы также можете явно проверить отмену, что вам следует делать при создании низкоуровневых интерфейсов сопрограмм.

Запустите приложение еще раз
Если вы запустите приложение снова, вы увидите,
 что новая реализация на основе сопрограмм загружает результаты из сети!
На следующем шаге вы интегрируете сопрограммы в Room и Retrofit.

9. Сопрограммы в помещении и дооснащение -----------------------------------

Чтобы продолжить интеграцию сопрограмм,
 мы собираемся использовать поддержку функций приостановки в стабильной версии Room и Retrofit,
  а затем существенно упростим код, который мы только что написали, с помощью функций приостановки.

Корутины в комнате
Сначала откройте MainDatabase.ktи сделайте insertTitleприостановку:

MainDatabase.kt
suspend fun insertTitle(title: Title)
Когда вы это сделаете, Room сделает ваш запрос основным и автоматически выполнит его в фоновом потоке.
Однако это также означает, что вы можете вызывать этот запрос только из сопрограммы.
И - это все, что вам нужно сделать, чтобы использовать сопрограммы в Room. Довольно изящно

Корутины в модификации
Теперь давайте посмотрим, как интегрировать сопрограммы с Retrofit.
Откройте MainNetwork.kt и переключитесь fetchNextTitle на функцию приостановки.
 Также измените тип возвращаемого значения с Call<String>на String.

 Для поддержки функции приостановки требуется Retrofit 2.6.0 или более поздняя версия.

Чтобы использовать функции приостановки в Retrofit, вам нужно сделать две вещи:
Добавьте к функции модификатор приостановки
Удалите Callоболочку из возвращаемого типа.
 Здесь мы возвращаемся String, но вы также можете вернуть сложный тип с поддержкой json.
  Если вы все же хотите предоставить доступ к полной версии Retrofit Result,
   вы можете вернуться Result<String>вместо Stringфункции приостановки.
Модернизация автоматически сделает функции приостановки безопасными для основной сети,
 чтобы вы могли вызывать их прямо из Dispatchers.Main.

 И Room, и Retrofit делают функции приостановки безопасными .
 Эти функции suspend funs безопасно вызывать Dispatchers.Main,
  даже если они извлекаются из сети и записываются в базу данных.

  И Room, и Retrofit используют настраиваемый диспетчер и не используют Dispatchers.IO.

  Room будет запускать сопрограммы с использованием настроенного запроса и транзакции по умолчанию Executor.
  Retrofit создаст новый Call объект под капотом и вызовет для него enqueue, чтобы отправить запрос асинхронно.

  Использование помещения и дооснащение -------------------

 Теперь, когда Room и Retrofit поддерживают функции приостановки, мы можем использовать их из нашего репозитория.
 Откройте TitleRepository.kt и посмотрите, как использование функций приостановки значительно упрощает логику
  даже по сравнению с версией с блокировкой:
Название Repository.kt
suspend fun refreshTitle() {
   try {
       // Make network request using a blocking call
       val result = network.fetchNextTitle()
       titleDao.insertTitle(Title(result))
   } catch (cause: Throwable) {
       // If anything throws an exception, inform the caller
       throw TitleRefreshError("Unable to refresh title", cause)
   }
}

 Вау, это намного короче.
 Что произошло?
 Оказывается, использование приостановки и возобновления позволяет сделать код намного короче.
 Модернизация позволяет нам использовать здесь возвращаемые типы, такие как String или User объект, вместо Call.
  Это безопасно, потому что внутри функции приостановки Retrofit можно запустить сетевой запрос в фоновом потоке
   и возобновить сопрограмму после завершения вызова.

   Более того, мы избавились от withContext.
   Поскольку и Room, и Retrofit предоставляют функции приостановки, безопасные для основного устройства,
    можно безопасно организовать эту асинхронную работу из Dispatchers.Main.

    Вам не нужно использовать withContextдля вызова основных безопасных функций приостановки.

    По соглашению, вы должны убедиться, что suspendфункции, написанные в вашем приложении,
     безопасны для основной работы .
     Таким образом, их можно будет безопасно вызывать даже с любого диспетчера Dispatchers.Main.

    Исправление ошибок компилятора
Запустите приложение
Запустите приложение еще раз, после его компиляции вы увидите,
что оно загружает данные с использованием сопрограмм на всем пути от ViewModel до Room и Retrofit!

Поздравляем, вы полностью перешли на использование сопрограмм в этом приложении!
В заключение поговорим немного о том, как протестировать то, что мы только что сделали.

10. Непосредственное тестирование сопрограмм ----------------------------------

В этом упражнении вы напишете тест, который suspendнапрямую вызывает функцию.

Поскольку он refreshTitleпредставлен как общедоступный API, он будет протестирован напрямую, показывая, как вызывать функции сопрограмм из тестов.

Вот refreshTitleфункция, которую вы реализовали в последнем упражнении:

TitleRepository.kt
suspend fun refreshTitle() {
   try {
       // Make network request using a blocking call
       val result = network.fetchNextTitle()
       titleDao.insertTitle(Title(result))
   } catch (cause: Throwable) {
       // If anything throws an exception, inform the caller
       throw TitleRefreshError("Unable to refresh title", cause)
   }
}

Напишите тест, который вызывает функцию приостановки
Открыть TitleRepositoryTest.ktв testпапке с двумя TODOS.

Попробуйте позвонить refreshTitleс первого теста whenRefreshTitleSuccess_insertsRows.

@Test
fun whenRefreshTitleSuccess_insertsRows() {
   val subject = TitleRepository(
       MainNetworkFake("OK"),
       TitleDaoFake("title")
   )

   subject.refreshTitle()
}

Поскольку refreshTitleэто suspendфункция, Kotlin не знает, как ее вызвать, кроме как из сопрограммы или другой функции приостановки, и вы получите ошибку компилятора, например: «Приостановить функцию refreshTitle следует вызывать только из сопрограммы или другой приостановленной функции».

Средство выполнения тестов ничего не знает о сопрограммах, поэтому мы не можем сделать этот тест функцией приостановки. Мы могли бы launchиспользовать сопрограмму с CoroutineScopeподобием в a ViewModel, однако тесты должны запускать сопрограммы до завершения, прежде чем они вернутся. Как только тестовая функция возвращается, тест окончен. Начало сопрограмм launchпредставляет собой асинхронный код, который может завершиться в какой-то момент в будущем. Поэтому, чтобы протестировать этот асинхронный код, вам нужно каким-то образом сказать тесту, чтобы он дождался завершения вашей сопрограммы. Поскольку launchэто неблокирующий вызов, это означает, что он сразу же возвращается и может продолжать запускать сопрограмму после возврата из функции - ее нельзя использовать в тестах. Например:

@Test
fun whenRefreshTitleSuccess_insertsRows() {
   val subject = TitleRepository(
       MainNetworkFake("OK"),
       TitleDaoFake("title")
   )

   // launch starts a coroutine then immediately returns
   GlobalScope.launch {
       // since this is asynchronous code, this may be called *after* the test completes
       subject.refreshTitle()
   }
   // test function returns immediately, and
   // doesn't see the results of refreshTitle
}

Иногда этот тест терпит неудачу. Вызов launchнемедленно вернется и выполнится одновременно с остальной частью тестового примера. У теста нет способа узнать, был ли refreshTitleон запущен или нет, и любые утверждения, такие как проверка того, что база данных была обновлена, будут ошибочными. И, если refreshTitleвозникло исключение, оно не будет выброшено в стек тестовых вызовов. Вместо этого он будет брошен в GlobalScopeобработчик неперехваченных исключений.

В библиотеке kotlinx-coroutines-testесть runBlockingTestфункция, которая блокирует, пока вызывает функции приостановки. Когда runBlockingTestвызывается функция приостановки или launchesновая сопрограмма, она по умолчанию выполняет ее немедленно. Вы можете думать об этом как о способе преобразования приостановленных функций и сопрограмм в обычные вызовы функций.

Кроме того, вам runBlockingTestбудут повторно выброшены неперехваченные исключения. Это упрощает тестирование, когда сопрограмма генерирует исключение.

Важно : функция runBlockingTestвсегда будет блокировать вызывающего, как и обычный вызов функции. Сопрограмма будет работать синхронно в том же потоке. Вы должны избегать runBlockingи runBlockingTestв своем коде приложения и предпочитать то, launchчто возвращается немедленно.

runBlockingTestдолжен использоваться только из тестов, поскольку он выполняет сопрограммы контролируемым тестом образом, в то время как runBlockingможет использоваться для предоставления блокирующих интерфейсов сопрограмм.

Реализуйте тест с одной сопрограммой
Заверните вызов refreshTitleс runBlockingTestи удалить GlobalScope.launchоболочку из subject.refreshTitle ().

НазваниеRepositoryTest.kt
@Test
fun whenRefreshTitleSuccess_insertsRows() = runBlockingTest {
   val titleDao = TitleDaoFake("title")
   val subject = TitleRepository(
           MainNetworkFake("OK"),
           titleDao
   )

   subject.refreshTitle()
   Truth.assertThat(titleDao.nextInsertedOrNull()).isEqualTo("OK")
}

В этом тесте используются предоставленные подделки, чтобы проверить, что "ОК" вставлено в базу данных с помощью refreshTitle.

Когда тест вызывает runBlockingTest, он блокируется до тех пор, пока не runBlockingTestзавершится запуск сопрограммы . Затем внутри, когда мы вызываем, refreshTitleон использует обычный механизм приостановки и возобновления, чтобы дождаться добавления строки базы данных в нашу подделку.

После завершения тестовой сопрограммы runBlockingTestвозвращается.

Напишите тест на тайм-аут
Мы хотим добавить короткий таймаут к сетевому запросу. Давайте сначала напишем тест, а затем реализуем тайм-аут. Создайте новый тест:

НазваниеRepositoryTest.kt
@Test(expected = TitleRefreshError::class)
fun whenRefreshTitleTimeout_throws() = runBlockingTest {
   val network = MainNetworkCompletableFake()
   val subject = TitleRepository(
           network,
           TitleDaoFake("title")
   )

   launch {
       subject.refreshTitle()
   }

   advanceTimeBy(5_000)
}

В этом тесте используется предоставленная подделка MainNetworkCompletableFake, которая представляет собой сетевую подделку, которая предназначена для приостановки вызывающих абонентов, пока тест не продолжит их. Когда refreshTitleпытается сделать сетевой запрос, он зависает навсегда, потому что мы хотим проверить таймауты.

Затем запускается отдельная сопрограмма для вызова refreshTitle. Это ключевая часть тайм-аутов тестирования, тайм-аут должен происходить в другой сопрограмме, нежели runBlockingTestсозданная. Таким образом, мы можем вызвать следующую строку, advanceTimeBy(5_000)которая увеличит время на 5 секунд и вызовет таймаут другой сопрограммы.

Это полный тест тайм-аута, и он пройдет, как только мы реализуем тайм-аут.

Запустите его сейчас и посмотрите, что произойдет:

Вызвано: kotlinx.coroutines.test.UncompletedCoroutinesError: Тест завершен с активными заданиями: ["...]

Одна из особенностей runBlockingTestзаключается в том, что он не позволит вам утекать сопрограммы после завершения теста. Если в конце теста останутся незавершенные сопрограммы, такие как наша сопрограмма запуска, она не пройдет проверку.

Добавить тайм-аут
Откройте TitleRepositoryи добавьте пятисекундный таймаут к выборке по сети. Вы можете сделать это с помощью withTimeoutфункции:

TitleRepository.kt
suspend fun refreshTitle() {
   try {
       // Make network request using a blocking call
       val result = withTimeout(5_000) {
           network.fetchNextTitle()
       }
       titleDao.insertTitle(Title(result))
   } catch (cause: Throwable) {
       // If anything throws an exception, inform the caller
       throw TitleRefreshError("Unable to refresh title", cause)
   }
}

Запустите тест. Когда вы запустите тесты, вы должны увидеть, что все тесты пройдены!

В следующем упражнении вы узнаете, как писать функции высшего порядка с помощью сопрограмм.

runBlockingTestполагается на TestCoroutineDispatcherуправление сопрограммами.

В результате рекомендуется ввести a TestCoroutineDispatcherили TestCoroutineScopeпри использовании runBlockingTest. Это делает сопрограммы однопоточными и дает возможность явно управлять всеми сопрограммами в тестах.

Если вы не хотите изменять поведение сопрограмм - например, в интеграционном тесте - вы можете вместо этого использовать runBlockingреализации по умолчанию для всех диспетчеров.

runBlockingTestявляется экспериментальным и в настоящее время содержит ошибку , из-за которой тест не проходит, если сопрограмма переключается на диспетчер, который выполняет сопрограмму в другом потоке. В последней стабильной версии этой ошибки не ожидается.

11. Использование сопрограмм в функциях высшего порядка ---------------------------------

В этом упражнении вы реорганизовать refreshTitle в MainViewModel использовать общую функцию загрузки данных.
 Это научит вас создавать функции высшего порядка, использующие сопрограммы.

 Текущая реализация refreshTitleработает, но мы можем создать общую сопрограмму загрузки данных,
  которая всегда показывает счетчик.
   Это может быть полезно в кодовой базе, которая загружает данные в ответ на несколько событий
    и хочет обеспечить постоянное отображение счетчика загрузки.

Рассматривая текущую реализацию, каждая строка, кроме repository.refreshTitle()шаблона,
 показывает счетчик и ошибки отображения.

 // MainViewModel.kt

 fun refreshTitle() {
    viewModelScope.launch {
        try {
            _spinner.value = true
            // this is the only part that changes between sources
            repository.refreshTitle()
        } catch (error: TitleRefreshError) {
            _snackBar.value = error.message
        } finally {
            _spinner.value = false
        }
    }
 }
Важно : несмотря на то, что мы используем только viewModelScope в этой кодовой таблице,
 обычно нормально добавлять область видимости в любом месте, где это имеет смысл.
  Не забудьте отменить его, если он больше не нужен.
Например, вы можете объявить один в адаптере RecyclerView для выполнения операций DiffUtil.

Использование сопрограмм в функциях высшего порядка ----------------------------------
Добавьте этот код в MainViewModel.kt

MainViewModel.kt
private fun launchDataLoad(block: suspend () -> Unit): Job {
   return viewModelScope.launch {
       try {
           _spinner.value = true
           block()
       } catch (error: TitleRefreshError) {
           _snackBar.value = error.message
       } finally {
           _spinner.value = false
       }
   }
Теперь refreshTitle()выполните рефакторинг, чтобы использовать эту функцию более высокого порядка.

MainViewModel.kt
fun refreshTitle() {
   launchDataLoad {
       repository.refreshTitle()
   }
}
Абстрагируя логику отображения счетчика загрузки и отображения ошибок, мы упростили наш фактический код, необходимый для загрузки данных.
Отображение счетчика или отображение ошибки - это то, что легко обобщить для любой загрузки данных,
в то время как фактический источник и место назначения данных необходимо указывать каждый раз.

Чтобы построить эту абстракцию, launchDataLoad принимает аргумент, block который является приостановленной лямбдой.
Лямбда приостановки позволяет вызывать функции приостановки.
Вот как Котлин орудия сопрограмм строители launchи runBlockingмы использовали в этом codelab.

// suspend lambda

block: suspend () -> Unit

Чтобы приостановить лямбду, начните с suspend ключевого слова.
Стрелка функции и тип возвращаемого значения Unitзавершают объявление.

Вам не часто приходится объявлять собственные приостановленные лямбды,
но они могут быть полезны для создания подобных абстракций, инкапсулирующих повторяющуюся логику!

12. Использование сопрограмм с WorkManager ======================================

В этом упражнении вы узнаете, как использовать код на основе сопрограмм из WorkManager.

Что такое WorkManager
На Android есть много вариантов отложенной фоновой работы.
В этом упражнении показано, как интегрировать WorkManager с сопрограммами.
WorkManager - это совместимая, гибкая и простая библиотека для отложенной фоновой работы.
WorkManager - это рекомендуемое решение для этих случаев использования на Android.

WorkManager - это часть Android Jetpack и компонент архитектуры для фоновой работы,
 которая требует сочетания гибкого и гарантированного выполнения.
Оппортунистическое выполнение означает, что WorkManager выполнит вашу фоновую работу, как только сможет.
Гарантированное выполнение означает, что WorkManager позаботится о логике для начала вашей работы в различных ситуациях,
даже если вы уйдете от своего приложения.

По этой причине WorkManager - хороший выбор для задач, которые в конечном итоге должны быть выполнены.

Некоторые примеры задач, которые можно использовать с WorkManager:

Загрузка журналов
Применение фильтров к изображениям и сохранение изображения
Периодическая синхронизация локальных данных с сетью
Чтобы узнать больше о WorkManager, ознакомьтесь с документацией .

Использование сопрограмм с WorkManager
WorkManager предоставляет разные реализации своего базового ListenableWorker класса для разных вариантов использования.

Простейший класс Worker позволяет нам выполнять некоторые синхронные операции с помощью WorkManager.
Однако, поскольку мы до сих пор работали над преобразованием нашей кодовой базы для использования сопрограмм и функций приостановки,
лучший способ использовать WorkManager - это использовать CoroutineWorker класс,
который позволяет определить нашу doWork() функцию как функцию приостановки.

Для начала откройте RefreshMainDataWork. Он уже расширяется CoroutineWorker, и вам нужно его реализовать doWork.

Внутри suspend doWork функции вызовите refreshTitle() из репозитория и верните соответствующий результат!

После того, как вы закончите TODO, код будет выглядеть так:

override suspend fun doWork(): Result {
   val database = getDatabase(applicationContext)
   val repository = TitleRepository(network, database.titleDao)

   return try {
       repository.refreshTitle()
       Result.success()
   } catch (error: TitleRefreshError) {
       Result.failure()
   }
}
Обратите внимание, что CoroutineWorker.doWork() это функция приостановки.
В отличие от более простого Worker класса, этот код НЕ запускается на Executor, указанном в вашей конфигурации WorkManager,
а вместо этого использует диспетчер в coroutineContext члене (по умолчанию Dispatchers.Default).

Тестирование нашего CoroutineWorker

Никакая кодовая база не может быть полной без тестирования.

WorkManager предоставляет несколько различных способов тестирования ваших Workerклассов,
чтобы узнать больше об исходной инфраструктуре тестирования, вы можете прочитать документацию .

WorkManager v2.1 представляет новый набор API-интерфейсов для поддержки более простого способа тестирования
ListenableWorkerклассов и, как следствие, CoroutineWorker.
В нашем коде мы будем использовать один из этих новых API: TestListenableWorkerBuilder.

Чтобы добавить наш новый тест, обновите RefreshMainDataWorkTest файл в androidTest папке.

Содержимое файла:


@RunWith(JUnit4::class)
class RefreshMainDataWorkTest {

@Test
fun testRefreshMainDataWork() {
   val fakeNetwork = MainNetworkFake("OK")

   val context = ApplicationProvider.getApplicationContext<Context>()
   val worker = TestListenableWorkerBuilder<RefreshMainDataWork>(context)
           .setWorkerFactory(RefreshMainDataWork.Factory(fakeNetwork))
           .build()

   // Start the work synchronously
   val result = worker.startWork().get()

   assertThat(result).isEqualTo(Result.success())
}

}
Прежде чем мы перейдем к тесту, мы расскажем WorkManagerо фабрике, чтобы мы могли внедрить фальшивую сеть.

Сам тест использует TestListenableWorkerBuilderдля создания нашего рабочего, который мы затем можем запустить, вызвав startWork()метод.

WorkManager - это всего лишь один пример того, как сопрограммы могут использоваться для упрощения проектирования API.

13. Поздравляем!
В этой лаборатории мы рассмотрели основы, которые вам понадобятся, чтобы начать использовать сопрограммы в своем приложении!

Мы рассмотрели:

Как интегрировать сопрограммы в приложения Android из заданий UI и WorkManager для упрощения асинхронного программирования,
Как использовать сопрограммы внутри a ViewModelдля извлечения данных из сети и сохранения их в базе данных, не блокируя основной поток.
И как отменить все сопрограммы по ViewModelзавершении работы.
Для тестирования кода на основе сопрограмм мы охватили как тестирование поведения, так и прямой вызов suspendфункций из тестов.

Выучить больше
Ознакомьтесь с кодовой таблицей « Расширенные сопрограммы с Kotlin Flow и LiveData »,
 чтобы узнать о более сложных сопрограммах на Android.
 "Advanced Coroutines with Kotlin Flow and LiveData":
 https://developer.android.com/codelabs/advanced-kotlin-coroutines/index.html

Чтобы узнать больше об отмене и исключениях в сопрограммах, ознакомьтесь с этой серией статей:
 Часть 1: Сопрограммы , Часть 2: Отмена в сопрограммах и Часть 3: Исключения в сопрограммах .

Part 1: Coroutines https://medium.com/androiddevelopers/coroutines-first-things-first-e6187bf3bb21
Part 2: Cancellation in coroutines https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629
Part 3: Exceptions in coroutines. https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c


У сопрограмм Kotlin есть много функций, которые не были охвачены этой кодовой лабораторией.
Если вам интересно узнать больше о сопрограммах Kotlin, прочтите руководства по сопрограммам, опубликованные JetBrains.
Также ознакомьтесь с разделом « Повышение производительности приложений с помощью сопрограмм Kotlin »,
чтобы узнать о дополнительных шаблонах использования сопрограмм на Android.

coroutines guides
https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutines-guide.md
Improve app performance with Kotlin coroutines"
https://developer.android.com/kotlin/coroutines

Назад

