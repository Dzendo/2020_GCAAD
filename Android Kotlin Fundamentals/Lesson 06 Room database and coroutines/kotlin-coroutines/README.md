# Using Kotlin Coroutines in your Android app

This folder contains the source code for the [Kotlin Coroutines codelab](https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html).

## License

    Copyright 2018 Google LLC

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

1. Прежде чем начать
В этой кодовой метке вы узнаете, как использовать Kotlin Coroutines в приложении для Android - новый способ управления фоновыми потоками, который может упростить код за счет уменьшения потребности в обратных вызовах. Сопрограммы - это функция Kotlin, которая преобразует асинхронные обратные вызовы для длительных задач, таких как доступ к базе данных или сети, в последовательный код.

Вот фрагмент кода, чтобы дать вам представление о том, что вы будете делать.

// Async callbacks
networkRequest { result ->
   // Successful network request
   databaseSave(result) { rows ->
     // Result saved
   }
}
Код на основе обратного вызова будет преобразован в последовательный код с использованием сопрограмм.

// The same code with coroutines
val result = networkRequest()
// Successful network request
databaseSave(result)
// Result saved
Вы начнете с существующего приложения, созданного с использованием компонентов архитектуры , которое использует стиль обратного вызова для длительных задач.

К концу этой кодовой метки у вас будет достаточно опыта, чтобы использовать сопрограммы в своем приложении для загрузки данных из сети, и вы сможете интегрировать сопрограммы в приложение. Вы также познакомитесь с лучшими практиками для сопрограмм и с тем, как написать тест для кода, использующего сопрограммы.

Предпосылки
Знакомство с компонентами архитектуры ViewModel, LiveData, Repository, и Room.
Опыт работы с синтаксисом Kotlin, включая функции расширения и лямбды.
Основное понимание использования потоков на Android, включая основной поток, фоновые потоки и обратные вызовы.
Что ты будешь делать
Вызовите код, написанный с сопрограммами и получите результаты.
Используйте функции приостановки, чтобы сделать асинхронный код последовательным.
Используйте launchи runBlockingдля управления выполнением кода.
Изучите методы преобразования существующих API в сопрограммы, используя suspendCoroutine.
Используйте сопрограммы с компонентами архитектуры.
Изучите лучшие практики для тестирования сопрограмм.
Введение в Room см. В разделе « Доступ к данным с использованием комнат DAO» .
Для ознакомления с другими компонентами архитектуры, используемыми в этой кодовой метке, см. Руководство по архитектуре приложения .
Для ознакомления с синтаксисом Kotlin см. Kotlin Bootcamp for Programmers .
Для ознакомления с основами многопоточности в Android см. Руководство по фоновой обработке .
Что вам нужно
Android Studio 3.6 (кодовая метка может работать с другими версиями, но некоторые вещи могут отсутствовать или выглядеть иначе).
Если вы столкнетесь с какими-либо проблемами (ошибками в коде, грамматическими ошибками, нечеткой формулировкой и т. Д.) Во время работы с этой кодовой меткой, сообщите о проблеме через ссылку Сообщить об ошибке в левом нижнем углу кодовой метки.

2. Начало настройки
Скачать код
Нажмите на следующую ссылку, чтобы загрузить весь код для этой кодовой метки:


... или клонировать GitHub-репозиторий из командной строки с помощью следующей команды:

$ git clone https://github.com/googlecodelabs/kotlin-coroutines.git
Котлин-сопрограмма хранилище содержит код для двух codelabs. Эта кодовая метка использует проект в каталоге coroutines-codelab . В этом проекте есть два модуля приложения:

android_studio_folder.pngstart - Простое приложение, использующее компоненты архитектуры Android, в которое вы добавите сопрограммы
android_studio_folder.pngзаконченный_код - проект с сопрограммами уже добавлен
Часто задаваемые вопросы
Как установить Android Studio?
Как настроить устройство для разработки?

3. Запустите начальный пример приложения
Во-первых, давайте посмотрим, как выглядит исходный пример приложения. Следуйте этим инструкциям, чтобы открыть образец приложения в Android Studio.

Если вы загрузили kotlin-coroutineszip-файл, распакуйте его.
Откройте coroutines-codelabпроект в Android Studio.
Выберите startмодуль приложения.
Нажмите кнопку « execute.pngВыполнить» и выберите эмулятор или подключите устройство Android, которое должно поддерживать Android Lollipop (минимальный поддерживаемый SDK - 21). Экран Kotlin Coroutines должен появиться:

Если вы видите сообщение об ошибке « Платформа Android обнаружена. Нажмите для настройки », убедитесь, что вы открываете coroutines-codelabкаталог, а не родительский каталог.

Это стартовое приложение использует потоки, чтобы увеличить счетчик с небольшой задержкой после нажатия на экран. Он также получит новый заголовок из сети и отобразит его на экране. Попробуйте сейчас, и вы увидите изменения количества и сообщений после небольшой задержки. В этой кодовой метке вы конвертируете это приложение для использования сопрограмм.

Это приложение использует компоненты архитектуры для отделения кода пользовательского интерфейса MainActivityот логики приложения MainViewModel. Найдите минутку, чтобы ознакомиться со структурой проекта.



MainActivityотображает пользовательский интерфейс, регистрирует прослушиватели щелчков и может отображать Snackbar. Он передает события MainViewModelи обновляет экран на основе LiveDataв MainViewModel.
MainViewModelобрабатывает события onMainViewClickedи будет общаться с MainActivityиспользованиемLiveData.
Executorsопределяет, BACKGROUND,что может запускать вещи в фоновом потоке.
TitleRepository извлекает результаты из сети и сохраняет их в базе данных.
Добавление сопрограмм в проект
Чтобы использовать сопрограммы в Kotlin, вы должны включить coroutines-coreбиблиотеку в build.gradle (Module: app)файл вашего проекта. Проекты Codelab уже сделали это для вас, поэтому вам не нужно делать это для завершения CodeLab.

Сопрограммы на Android доступны как базовая библиотека, а также специальные расширения для Android:

kotlinx-coroutines-core - основной интерфейс для использования сопрограмм в Kotlin
kotlinx-coroutines-android - Поддержка темы Android в сопрограммах
Начальное приложение уже содержит зависимости в build.gradle.При создании нового проекта приложения вам нужно будет открыть build.gradle (Module: app)и добавить зависимости сопрограмм в проект.

зависимости {
  ...
  реализация "org.jetbrains.kotlinx: kotlinx-coroutines-core: xxx"
  реализация "org.jetbrains.kotlinx: kotlinx-coroutines-android: xxx"
}
Сопрограммы и RxJava

Если вы используете RxJava в своей текущей кодовой базе, вы можете интегрироваться с сопрограммами с помощью библиотеки kotlin-coroutines-rx .

4. Сопрограммы в Котлине
На Android важно избегать блокировки основного потока. Основной поток - это отдельный поток, который обрабатывает все обновления пользовательского интерфейса. Это также поток, который вызывает все обработчики кликов и другие обратные вызовы пользовательского интерфейса. Как таковой, он должен работать бесперебойно, чтобы гарантировать отличный пользовательский опыт.

Чтобы ваше приложение отображалось пользователю без видимых пауз, основной поток должен обновлять экран каждые 16 мс или более , что составляет около 60 кадров в секунду. Многие общие задачи занимают больше времени, например, анализ больших наборов данных JSON, запись данных в базу данных или выборка данных из сети. Следовательно, вызов подобного кода из основного потока может привести к приостановке, заиканию или даже зависанию приложения. И если вы заблокируете основной поток слишком долго, приложение может даже аварийно завершить работу и отобразить диалоговое окно « Приложение не отвечает ».

Посмотрите видео ниже, чтобы познакомиться с тем, как сопрограммы решают эту проблему для нас на Android с помощью функции main-safety.


Шаблон обратного вызова
Одним из способов выполнения длительных задач без блокировки основного потока являются обратные вызовы. Используя обратные вызовы, вы можете запускать длительные задачи в фоновом потоке. Когда задача завершается, вызывается обратный вызов для информирования вас о результате в главном потоке.

Взгляните на пример шаблона обратного вызова.

// Slow request with callbacks
@UiThread
fun makeNetworkRequest() {
    // The slow network request runs on another thread
    slowFetch { result ->
        // When the result is ready, this callback will get the result
        show(result)
    }
    // makeNetworkRequest() exits after calling slowFetch without waiting for the result
}
Поскольку этот код помечен @UiThread, он должен выполняться достаточно быстро, чтобы выполняться в главном потоке. Это означает, что он должен вернуться очень быстро, чтобы следующее обновление экрана не задерживалось. Однако, поскольку slowFetchна завершение работы потребуются секунды или даже минуты, основной поток не может дождаться результата. show(result)Обратный вызов позволяет slowFetchзапускать в фоновом потоке и возвращает результат , когда он будет готов.

Использование сопрограмм для удаления обратных вызовов
Обратные вызовы - это отличный шаблон, однако они имеют несколько недостатков. Код, который интенсивно использует обратные вызовы, может стать трудным для чтения и трудным для рассуждения. Кроме того, обратные вызовы не позволяют использовать некоторые языковые функции, такие как исключения.

Сопрограммы Kotlin позволяют преобразовывать код на основе обратного вызова в последовательный код. Последовательный код, как правило, легче читать и может даже использовать такие функции языка, как исключения.

В конце концов, они делают одно и то же: ждут, пока не будет получен результат от долго выполняющейся задачи, и продолжают выполнение. Однако в коде они выглядят совсем иначе.

Ключевое слово suspend- это способ Котлина обозначить функцию или тип функции, доступный сопрограммам. Когда сопрограмма вызывает отмеченную функцию suspend, а не блокирует ее до тех пор, пока эта функция не вернется, как при обычном вызове функции, она приостанавливает выполнение до тех пор, пока результат не будет готов, а затем возобновляет работу с того места, где остановилась с результатом. В то время как он приостановлен в ожидании результата, он разблокирует поток, в котором он работает, чтобы могли запускаться другие функции или сопрограммы.

Например, в коде ниже, makeNetworkRequest()и slowFetch()обе suspendфункции.

// Slow request with coroutines
@UiThread
suspend fun makeNetworkRequest() {
    // slowFetch is another suspend function so instead of 
    // blocking the main thread  makeNetworkRequest will `suspend` until the result is 
    // ready
    val result = slowFetch()
    // continue to execute after the result is ready
    show(result)
}

// slowFetch is main-safe using coroutines
suspend fun slowFetch(): SlowResult { ... }
Как и в случае версии с обратным вызовом, makeNetworkRequestнеобходимо сразу же вернуться из основного потока, потому что он помечен @UiThread. Это означает, что обычно он не может вызывать методы блокировки, такие как slowFetch. Вот где suspendключевое слово работает свое волшебство.

Важное замечание : suspendКлючевое слово не определяет код потока, на котором выполняется. Функции приостановки могут выполняться в фоновом потоке или в основном потоке.

По сравнению с кодом, основанным на обратном вызове, код сопрограммы выполняет тот же результат, что и разблокирование текущего потока с меньшим количеством кода. Благодаря последовательному стилю, легко объединить несколько длительных задач без создания нескольких обратных вызовов. Например, код, который извлекает результат из двух сетевых конечных точек и сохраняет его в базе данных, может быть записан как функция в сопрограммах без обратных вызовов. Вот так:

// Request data from network and save it to database with coroutines

// Because of the @WorkerThread, this function cannot be called on the
// main thread without causing an error.
@WorkerThread
suspend fun makeNetworkRequest() {
    // slowFetch and anotherFetch are suspend functions
    val slow = slowFetch()
    val another = anotherFetch()
    // save is a regular function and will block this thread
    database.save(slow, another)
}

// slowFetch is main-safe using coroutines
suspend fun slowFetch(): SlowResult { ... }
// anotherFetch is main-safe using coroutines
suspend fun anotherFetch(): AnotherResult { ... }
Сопрограммы под другим именем

Образец asyncи awaitв других языках основан на сопрограммах. Если вы знакомы с этим шаблоном, suspendключевое слово похоже на async. Однако в Kotlin, await()неявно при вызове suspendфункции.

У Kotlin есть метод, Deferred.await()который используется для ожидания результата от сопрограммы, начатой ​​со asyncстроителя.

Вы познакомите сопрограммы с примером приложения в следующем разделе.

5. Управление пользовательским интерфейсом с сопрограммами
В этом упражнении вы напишите сопрограмму для отображения сообщения после задержки. Для начала убедитесь, что у вас открыт модуль startв Android Studio.

Понимание CoroutineScope
В Kotlin все сопрограммы работают внутри CoroutineScope. Область действия контролирует время жизни сопрограмм через свою работу. При отмене задания области действия отменяются все сопрограммы, запущенные в этой области. В Android вы можете использовать область действия для отмены всех запущенных сопрограмм, когда, например, пользователь отходит от Activityили Fragment. Области также позволяют указать диспетчер по умолчанию. Диспетчер контролирует, какой поток запускает сопрограмму.

Для сопрограмм, запускаемых пользовательским интерфейсом, обычно корректно запускать их, на Dispatchers.Mainкоторых основной поток в Android. Запуск сопрограммы Dispatchers.Mainне блокирует основной поток, пока он приостановлен. Поскольку ViewModelсопрограмма почти всегда обновляет пользовательский интерфейс в основном потоке, запуск сопрограмм в основном потоке экономит вам дополнительные переключатели потоков. Сопрограмма, запущенная в главном потоке, может переключать диспетчеры в любое время после ее запуска. Например, он может использовать другой диспетчер для анализа большого результата JSON из основного потока.

Сопрограммы предлагают главную безопасность

Поскольку сопрограммы могут легко переключать потоки в любое время и передавать результаты обратно в исходный поток, рекомендуется запустить сопрограммы, связанные с пользовательским интерфейсом, в главном потоке.

Библиотеки любят Roomи Retrofitпредлагают основную безопасность при использовании сопрограмм, поэтому вам не нужно управлять потоками для выполнения вызовов сети или базы данных. Это часто может привести к существенно более простому коду.

Однако для блокировки кода, такого как сортировка списка или чтение из файла, по-прежнему требуется явный код для обеспечения безопасности , даже при использовании сопрограмм. Это также верно, если вы используете сетевую библиотеку или библиотеку базы данных, которая (пока) не поддерживает сопрограммы.

Использование viewModelScope
Библиотека AndroidX lifecycle-viewmodel-ktxдобавляет CoroutineScope к ViewModels, который настроен для запуска сопрограмм, связанных с пользовательским интерфейсом. Чтобы использовать эту библиотеку, вы должны включить ее в build.gradle (Module: start)файл вашего проекта. Этот шаг уже сделан в проектах codelab.

зависимости {
  ...
  реализация "androidx.lifecycle: lifecycle-viewmodel-ktx: xxx"
}
Библиотека добавляет viewModelScopeв качестве функции расширения ViewModelкласса. Эта область привязана Dispatchers.Mainи будет автоматически отменена после ViewModelочистки.

Переключиться с темы на сопрограммы
В MainViewModel.ktнайти следующее TODO вместе с этим кодом:

MainViewModel.kt
/**
* Wait one second then update the tap count.
*/
private fun updateTaps() {
   // TODO: Convert updateTaps to use coroutines
   tapCount++
   BACKGROUND.submit {
       Thread.sleep(1_000)
       _taps.postValue("$tapCount taps")
   }
}
Этот код использует BACKGROUND ExecutorService(определенный в util/Executor.kt) для запуска в фоновом потоке. Поскольку sleepблокирует текущий поток, он заморозил бы пользовательский интерфейс, если бы он был вызван в основном потоке. Через одну секунду после того, как пользователь щелкает по основному виду, он запрашивает снэк-бар.

Это можно увидеть, удалив фоновую информацию из кода и снова запустив ее. Загрузочный счетчик не будет отображаться, и через секунду все «перейдет» в конечное состояние.

MainViewModel.kt
/**
* Wait one second then update the tap count.
*/
private fun updateTaps() {
   // TODO: Convert updateTaps to use coroutines
   tapCount++
   Thread.sleep(1_000)
   _taps.postValue("$tapCount taps")
}
Замените updateTapsэтим кодом на основе сопрограмм, который делает то же самое. Вам придется импортировать launchи delay.

MainViewModel.kt
/**
* Wait one second then display a snackbar.
*/
fun updateTaps() {
   // launch a coroutine in viewModelScope
   viewModelScope.launch {
       tapCount++
       // suspend this coroutine for one second
       delay(1_000)
       // resume in the main dispatcher
       // _snackbar.value can be called directly from main thread
       _taps.postValue("$tapCount taps")
   }
}
Этот код делает то же самое, ожидая одну секунду, прежде чем показывать закусочную. Тем не менее, есть некоторые важные различия:

viewModelScope.launchзапустит сопрограмму в viewModelScope. Это означает, что когда работа, которую мы передали, viewModelScopeбудет отменена, все сопрограммы в этой работе / области будут отменены. Если пользователь покинул Activity перед delayвозвратом, эта сопрограмма будет автоматически отменена при onClearedвызове после уничтожения ViewModel.
Так как viewModelScopeимеет диспетчер по умолчанию Dispatchers.Main, эта сопрограмма будет запущена в главном потоке. Позже мы увидим, как использовать разные темы.
Функция delayявляется suspendфункцией. Это показано в Android Studio значком в левом желобе. Даже если эта сопрограмма выполняется в основном потоке, delayона не будет блокировать поток в течение одной секунды. Вместо этого диспетчер запланирует возобновление сопрограммы через одну секунду при следующем утверждении.
Иди и беги. Когда вы щелкнете на главном экране, через секунду вы увидите закусочную.

В следующем разделе мы рассмотрим, как протестировать эту функцию.




