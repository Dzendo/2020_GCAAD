# Using Kotlin Coroutines in your Android app

This folder contains the source code for the [Kotlin Coroutines codelab](https://codelabs.developers.google.com/codelabs/kotlin-coroutines/index.html).

## License

    Copyright 2018 Google LLC

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

1. Прежде чем начать *****************************************************************************
В этой кодовой метке вы узнаете, как использовать Kotlin Coroutines в приложении для Android - новый способ управления фоновыми потоками, который может упростить код за счет уменьшения потребности в обратных вызовах. Сопрограммы - это функция Kotlin, которая преобразует асинхронные обратные вызовы для длительных задач, таких как доступ к базе данных или сети, в последовательный код.

Вот фрагмент кода, чтобы дать вам представление о том, что вы будете делать.

// Async callbacks
networkRequest { result ->
   // Successful network request
   databaseSave(result) { rows ->
     // Result saved
   }
}
Код на основе обратного вызова будет преобразован в последовательный код с использованием сопрограмм.

// The same code with coroutines
val result = networkRequest()
// Successful network request
databaseSave(result)
// Result saved
Вы начнете с существующего приложения, созданного с использованием компонентов архитектуры , которое использует стиль обратного вызова для длительных задач.

К концу этой кодовой метки у вас будет достаточно опыта, чтобы использовать сопрограммы в своем приложении для загрузки данных из сети, и вы сможете интегрировать сопрограммы в приложение. Вы также познакомитесь с лучшими практиками для сопрограмм и с тем, как написать тест для кода, использующего сопрограммы.

Предпосылки
Знакомство с компонентами архитектуры ViewModel, LiveData, Repository, и Room.
Опыт работы с синтаксисом Kotlin, включая функции расширения и лямбды.
Основное понимание использования потоков на Android, включая основной поток, фоновые потоки и обратные вызовы.
Что ты будешь делать
Вызовите код, написанный с сопрограммами и получите результаты.
Используйте функции приостановки, чтобы сделать асинхронный код последовательным.
Используйте launchи runBlockingдля управления выполнением кода.
Изучите методы преобразования существующих API в сопрограммы, используя suspendCoroutine.
Используйте сопрограммы с компонентами архитектуры.
Изучите лучшие практики для тестирования сопрограмм.
Введение в Room см. В разделе « Доступ к данным с использованием комнат DAO» .
Для ознакомления с другими компонентами архитектуры, используемыми в этой кодовой метке, см. Руководство по архитектуре приложения .
Для ознакомления с синтаксисом Kotlin см. Kotlin Bootcamp for Programmers .
Для ознакомления с основами многопоточности в Android см. Руководство по фоновой обработке .
Что вам нужно
Android Studio 3.6 (кодовая метка может работать с другими версиями, но некоторые вещи могут отсутствовать или выглядеть иначе).
Если вы столкнетесь с какими-либо проблемами (ошибками в коде, грамматическими ошибками, нечеткой формулировкой и т. Д.) Во время работы с этой кодовой меткой, сообщите о проблеме через ссылку Сообщить об ошибке в левом нижнем углу кодовой метки.

2. Начало настройки  *****************************************************************************

Скачать код
Нажмите на следующую ссылку, чтобы загрузить весь код для этой кодовой метки:


... или клонировать GitHub-репозиторий из командной строки с помощью следующей команды:

$ git clone https://github.com/googlecodelabs/kotlin-coroutines.git
Котлин-сопрограмма хранилище содержит код для двух codelabs. Эта кодовая метка использует проект в каталоге coroutines-codelab . В этом проекте есть два модуля приложения:

android_studio_folder.pngstart - Простое приложение, использующее компоненты архитектуры Android, в которое вы добавите сопрограммы
android_studio_folder.pngзаконченный_код - проект с сопрограммами уже добавлен
Часто задаваемые вопросы
Как установить Android Studio?
Как настроить устройство для разработки?

3. Запустите начальный пример приложения ***********************************************************************

Во-первых, давайте посмотрим, как выглядит исходный пример приложения. Следуйте этим инструкциям, чтобы открыть образец приложения в Android Studio.

Если вы загрузили kotlin-coroutineszip-файл, распакуйте его.
Откройте coroutines-codelabпроект в Android Studio.
Выберите startмодуль приложения.
Нажмите кнопку « execute.pngВыполнить» и выберите эмулятор или подключите устройство Android, которое должно поддерживать Android Lollipop (минимальный поддерживаемый SDK - 21). Экран Kotlin Coroutines должен появиться:

Если вы видите сообщение об ошибке « Платформа Android обнаружена. Нажмите для настройки », убедитесь, что вы открываете coroutines-codelabкаталог, а не родительский каталог.

Это стартовое приложение использует потоки, чтобы увеличить счетчик с небольшой задержкой после нажатия на экран. Он также получит новый заголовок из сети и отобразит его на экране. Попробуйте сейчас, и вы увидите изменения количества и сообщений после небольшой задержки. В этой кодовой метке вы конвертируете это приложение для использования сопрограмм.

Это приложение использует компоненты архитектуры для отделения кода пользовательского интерфейса MainActivityот логики приложения MainViewModel. Найдите минутку, чтобы ознакомиться со структурой проекта.



MainActivityотображает пользовательский интерфейс, регистрирует прослушиватели щелчков и может отображать Snackbar. Он передает события MainViewModelи обновляет экран на основе LiveDataв MainViewModel.
MainViewModelобрабатывает события onMainViewClickedи будет общаться с MainActivityиспользованиемLiveData.
Executorsопределяет, BACKGROUND,что может запускать вещи в фоновом потоке.
TitleRepository извлекает результаты из сети и сохраняет их в базе данных.
Добавление сопрограмм в проект
Чтобы использовать сопрограммы в Kotlin, вы должны включить coroutines-coreбиблиотеку в build.gradle (Module: app)файл вашего проекта. Проекты Codelab уже сделали это для вас, поэтому вам не нужно делать это для завершения CodeLab.

Сопрограммы на Android доступны как базовая библиотека, а также специальные расширения для Android:

kotlinx-coroutines-core - основной интерфейс для использования сопрограмм в Kotlin
kotlinx-coroutines-android - Поддержка темы Android в сопрограммах
Начальное приложение уже содержит зависимости в build.gradle.При создании нового проекта приложения вам нужно будет открыть build.gradle (Module: app)и добавить зависимости сопрограмм в проект.

зависимости {
  ...
  реализация "org.jetbrains.kotlinx: kotlinx-coroutines-core: xxx"
  реализация "org.jetbrains.kotlinx: kotlinx-coroutines-android: xxx"
}
Сопрограммы и RxJava

Если вы используете RxJava в своей текущей кодовой базе, вы можете интегрироваться с сопрограммами с помощью библиотеки kotlin-coroutines-rx .

4. Сопрограммы в Котлине ****************************************************************************

На Android важно избегать блокировки основного потока. Основной поток - это отдельный поток, который обрабатывает все обновления пользовательского интерфейса. Это также поток, который вызывает все обработчики кликов и другие обратные вызовы пользовательского интерфейса. Как таковой, он должен работать бесперебойно, чтобы гарантировать отличный пользовательский опыт.

Чтобы ваше приложение отображалось пользователю без видимых пауз, основной поток должен обновлять экран каждые 16 мс или более , что составляет около 60 кадров в секунду. Многие общие задачи занимают больше времени, например, анализ больших наборов данных JSON, запись данных в базу данных или выборка данных из сети. Следовательно, вызов подобного кода из основного потока может привести к приостановке, заиканию или даже зависанию приложения. И если вы заблокируете основной поток слишком долго, приложение может даже аварийно завершить работу и отобразить диалоговое окно « Приложение не отвечает ».

Посмотрите видео ниже, чтобы познакомиться с тем, как сопрограммы решают эту проблему для нас на Android с помощью функции main-safety.


Шаблон обратного вызова
Одним из способов выполнения длительных задач без блокировки основного потока являются обратные вызовы. Используя обратные вызовы, вы можете запускать длительные задачи в фоновом потоке. Когда задача завершается, вызывается обратный вызов для информирования вас о результате в главном потоке.

Взгляните на пример шаблона обратного вызова.

// Slow request with callbacks
@UiThread
fun makeNetworkRequest() {
    // The slow network request runs on another thread
    slowFetch { result ->
        // When the result is ready, this callback will get the result
        show(result)
    }
    // makeNetworkRequest() exits after calling slowFetch without waiting for the result
}
Поскольку этот код помечен @UiThread, он должен выполняться достаточно быстро, чтобы выполняться в главном потоке. Это означает, что он должен вернуться очень быстро, чтобы следующее обновление экрана не задерживалось. Однако, поскольку slowFetchна завершение работы потребуются секунды или даже минуты, основной поток не может дождаться результата. show(result)Обратный вызов позволяет slowFetchзапускать в фоновом потоке и возвращает результат , когда он будет готов.

Использование сопрограмм для удаления обратных вызовов
Обратные вызовы - это отличный шаблон, однако они имеют несколько недостатков. Код, который интенсивно использует обратные вызовы, может стать трудным для чтения и трудным для рассуждения. Кроме того, обратные вызовы не позволяют использовать некоторые языковые функции, такие как исключения.

Сопрограммы Kotlin позволяют преобразовывать код на основе обратного вызова в последовательный код. Последовательный код, как правило, легче читать и может даже использовать такие функции языка, как исключения.

В конце концов, они делают одно и то же: ждут, пока не будет получен результат от долго выполняющейся задачи, и продолжают выполнение. Однако в коде они выглядят совсем иначе.

Ключевое слово suspend- это способ Котлина обозначить функцию или тип функции, доступный сопрограммам. Когда сопрограмма вызывает отмеченную функцию suspend, а не блокирует ее до тех пор, пока эта функция не вернется, как при обычном вызове функции, она приостанавливает выполнение до тех пор, пока результат не будет готов, а затем возобновляет работу с того места, где остановилась с результатом. В то время как он приостановлен в ожидании результата, он разблокирует поток, в котором он работает, чтобы могли запускаться другие функции или сопрограммы.

Например, в коде ниже, makeNetworkRequest()и slowFetch()обе suspendфункции.

// Slow request with coroutines
@UiThread
suspend fun makeNetworkRequest() {
    // slowFetch is another suspend function so instead of 
    // blocking the main thread  makeNetworkRequest will `suspend` until the result is 
    // ready
    val result = slowFetch()
    // continue to execute after the result is ready
    show(result)
}

// slowFetch is main-safe using coroutines
suspend fun slowFetch(): SlowResult { ... }
Как и в случае версии с обратным вызовом, makeNetworkRequestнеобходимо сразу же вернуться из основного потока, потому что он помечен @UiThread. Это означает, что обычно он не может вызывать методы блокировки, такие как slowFetch. Вот где suspendключевое слово работает свое волшебство.

Важное замечание : suspendКлючевое слово не определяет код потока, на котором выполняется. Функции приостановки могут выполняться в фоновом потоке или в основном потоке.

По сравнению с кодом, основанным на обратном вызове, код сопрограммы выполняет тот же результат, что и разблокирование текущего потока с меньшим количеством кода. Благодаря последовательному стилю, легко объединить несколько длительных задач без создания нескольких обратных вызовов. Например, код, который извлекает результат из двух сетевых конечных точек и сохраняет его в базе данных, может быть записан как функция в сопрограммах без обратных вызовов. Вот так:

// Request data from network and save it to database with coroutines

// Because of the @WorkerThread, this function cannot be called on the
// main thread without causing an error.
@WorkerThread
suspend fun makeNetworkRequest() {
    // slowFetch and anotherFetch are suspend functions
    val slow = slowFetch()
    val another = anotherFetch()
    // save is a regular function and will block this thread
    database.save(slow, another)
}

// slowFetch is main-safe using coroutines
suspend fun slowFetch(): SlowResult { ... }
// anotherFetch is main-safe using coroutines
suspend fun anotherFetch(): AnotherResult { ... }
Сопрограммы под другим именем

Образец asyncи awaitв других языках основан на сопрограммах. Если вы знакомы с этим шаблоном, suspendключевое слово похоже на async. Однако в Kotlin, await()неявно при вызове suspendфункции.

У Kotlin есть метод, Deferred.await()который используется для ожидания результата от сопрограммы, начатой ​​со asyncстроителя.

Вы познакомите сопрограммы с примером приложения в следующем разделе.

5. Управление пользовательским интерфейсом с сопрограммами *****************************************************

В этом упражнении вы напишите сопрограмму для отображения сообщения после задержки. Для начала убедитесь, что у вас открыт модуль startв Android Studio.

Понимание CoroutineScope
В Kotlin все сопрограммы работают внутри CoroutineScope. Область действия контролирует время жизни сопрограмм через свою работу. При отмене задания области действия отменяются все сопрограммы, запущенные в этой области. В Android вы можете использовать область действия для отмены всех запущенных сопрограмм, когда, например, пользователь отходит от Activityили Fragment. Области также позволяют указать диспетчер по умолчанию. Диспетчер контролирует, какой поток запускает сопрограмму.

Для сопрограмм, запускаемых пользовательским интерфейсом, обычно корректно запускать их, на Dispatchers.Mainкоторых основной поток в Android. Запуск сопрограммы Dispatchers.Mainне блокирует основной поток, пока он приостановлен. Поскольку ViewModelсопрограмма почти всегда обновляет пользовательский интерфейс в основном потоке, запуск сопрограмм в основном потоке экономит вам дополнительные переключатели потоков. Сопрограмма, запущенная в главном потоке, может переключать диспетчеры в любое время после ее запуска. Например, он может использовать другой диспетчер для анализа большого результата JSON из основного потока.

Сопрограммы предлагают главную безопасность

Поскольку сопрограммы могут легко переключать потоки в любое время и передавать результаты обратно в исходный поток, рекомендуется запустить сопрограммы, связанные с пользовательским интерфейсом, в главном потоке.

Библиотеки любят Roomи Retrofitпредлагают основную безопасность при использовании сопрограмм, поэтому вам не нужно управлять потоками для выполнения вызовов сети или базы данных. Это часто может привести к существенно более простому коду.

Однако для блокировки кода, такого как сортировка списка или чтение из файла, по-прежнему требуется явный код для обеспечения безопасности , даже при использовании сопрограмм. Это также верно, если вы используете сетевую библиотеку или библиотеку базы данных, которая (пока) не поддерживает сопрограммы.

Использование viewModelScope
Библиотека AndroidX lifecycle-viewmodel-ktxдобавляет CoroutineScope к ViewModels, который настроен для запуска сопрограмм, связанных с пользовательским интерфейсом. Чтобы использовать эту библиотеку, вы должны включить ее в build.gradle (Module: start)файл вашего проекта. Этот шаг уже сделан в проектах codelab.

зависимости {
  ...
  реализация "androidx.lifecycle: lifecycle-viewmodel-ktx: xxx"
}
Библиотека добавляет viewModelScopeв качестве функции расширения ViewModelкласса. Эта область привязана Dispatchers.Mainи будет автоматически отменена после ViewModelочистки.

Переключиться с темы на сопрограммы
В MainViewModel.ktнайти следующее TODO вместе с этим кодом:

MainViewModel.kt
/**
* Wait one second then update the tap count.
*/
private fun updateTaps() {
   // TODO: Convert updateTaps to use coroutines
   tapCount++
   BACKGROUND.submit {
       Thread.sleep(1_000)
       _taps.postValue("$tapCount taps")
   }
}
Этот код использует BACKGROUND ExecutorService(определенный в util/Executor.kt) для запуска в фоновом потоке. Поскольку sleepблокирует текущий поток, он заморозил бы пользовательский интерфейс, если бы он был вызван в основном потоке. Через одну секунду после того, как пользователь щелкает по основному виду, он запрашивает снэк-бар.

Это можно увидеть, удалив фоновую информацию из кода и снова запустив ее. Загрузочный счетчик не будет отображаться, и через секунду все «перейдет» в конечное состояние.

MainViewModel.kt
/**
* Wait one second then update the tap count.
*/
private fun updateTaps() {
   // TODO: Convert updateTaps to use coroutines
   tapCount++
   Thread.sleep(1_000)
   _taps.postValue("$tapCount taps")
}
Замените updateTapsэтим кодом на основе сопрограмм, который делает то же самое. Вам придется импортировать launchи delay.

MainViewModel.kt
/**
* Wait one second then display a snackbar.
*/
fun updateTaps() {
   // launch a coroutine in viewModelScope
   viewModelScope.launch {
       tapCount++
       // suspend this coroutine for one second
       delay(1_000)
       // resume in the main dispatcher
       // _snackbar.value can be called directly from main thread
       _taps.postValue("$tapCount taps")
   }
}
Этот код делает то же самое, ожидая одну секунду, прежде чем показывать закусочную. Тем не менее, есть некоторые важные различия:

viewModelScope.launchзапустит сопрограмму в viewModelScope. Это означает, что когда работа, которую мы передали, viewModelScopeбудет отменена, все сопрограммы в этой работе / области будут отменены. Если пользователь покинул Activity перед delayвозвратом, эта сопрограмма будет автоматически отменена при onClearedвызове после уничтожения ViewModel.
Так как viewModelScopeимеет диспетчер по умолчанию Dispatchers.Main, эта сопрограмма будет запущена в главном потоке. Позже мы увидим, как использовать разные темы.
Функция delayявляется suspendфункцией. Это показано в Android Studio значком в левом желобе. Даже если эта сопрограмма выполняется в основном потоке, delayона не будет блокировать поток в течение одной секунды. Вместо этого диспетчер запланирует возобновление сопрограммы через одну секунду при следующем утверждении.
Иди и беги. Когда вы щелкнете на главном экране, через секунду вы увидите закусочную.

В следующем разделе мы рассмотрим, как протестировать эту функцию.

6. Проверка сопрограмм через поведение ********************************************************************
В этом упражнении вы напишете тест для только что написанного кода. В этом упражнении вы узнаете, как тестировать сопрограммы, запущенные с Dispatchers.Mainиспользованием библиотеки kotlinx-coroutines-test . Позже в этой кодовой метке вы реализуете тест, который напрямую взаимодействует с сопрограммами.

kotlinx-coroutines-testБиблиотека , используемая в данном разделе помечается как экспериментальные и может иметь важные изменения до выпуска.

Просмотрите существующий код
Откройте MainViewModelTest.ktв androidTestпапке.

MainViewModelTest.kt
class MainViewModelTest {
   @get:Rule
   val coroutineScope =  MainCoroutineScopeRule()
   @get:Rule
   val instantTaskExecutorRule = InstantTaskExecutorRule()

   lateinit var subject: MainViewModel

   @Before
   fun setup() {
       subject = MainViewModel(
           TitleRepository(
                   MainNetworkFake("OK"),
                   TitleDaoFake("initial")
           ))
   }
}
Правило - это способ запуска кода до и после выполнения теста в JUnit. Два правила используются, чтобы позволить нам тестировать MainViewModel в тесте вне устройства:

InstantTaskExecutorRuleявляется правилом JUnit, которое настраивает LiveDataвыполнение каждой задачи синхронно
MainCoroutineScopeRuleэто пользовательское правило в этой кодовой базе, которое настраивает Dispatchers.Mainиспользование TestCoroutineDispatcherfrom kotlinx-coroutines-test. Это позволяет тестам выдвигать виртуальные часы для тестирования и позволяет коду использовать Dispatchers.Mainв модульных тестах.
В этом setupметоде новый экземпляр MainViewModelсоздается с использованием фальшивых тестов - это фальшивые реализации сети и базы данных, представленные в начальном коде, чтобы помочь в написании тестов без использования реальной сети или базы данных.

Для этого теста подделки нужны только для удовлетворения зависимостей MainViewModel. Позже в этой лаборатории кода вы обновите подделки для поддержки сопрограмм.

Напишите тест, который контролирует сопрограммы
Добавьте новый тест, который гарантирует, что касания обновляются через одну секунду после нажатия основного вида:

MainViewModelTest.kt
@Test
fun whenMainClicked_updatesTaps() {
   subject.onMainViewClicked()
   Truth.assertThat(subject.taps.getValueForTest()).isEqualTo("0 taps")
   coroutineScope.advanceTimeBy(1000)
   Truth.assertThat(subject.taps.getValueForTest()).isEqualTo("1 taps")
}
При вызове onMainViewClickedзапускается только что созданная нами сопрограмма. Этот тест проверяет, что текст нажатий остается «0 нажатий» сразу после onMainViewClickedвызова, затем через 1 секунду он обновляется до «1 нажатий» .

Этот тест использует виртуальное время для управления выполнением сопрограммы, запущенной onMainViewClicked. MainCoroutineScopeRuleПозволяет приостановить, возобновить или контролировать выполнение сопрограмм, которые запускаются на Dispatchers.Main. Здесь мы вызываем, advanceTimeBy(1_000)что заставит главного диспетчера немедленно выполнить сопрограммы, которые должны возобновиться через 1 секунду.

Этот тест является полностью детерминированным, что означает, что он всегда будет выполняться одинаково. И, поскольку он полностью контролирует выполнение сопрограмм, запущенных на Dispatchers.Mainнем, ему не нужно ждать одну секунду для установки значения.

Запустите существующий тест
Щелкните правой кнопкой мыши на имени класса MainViewModelTestв вашем редакторе, чтобы открыть контекстное меню.
В контекстном меню выберите « execute.pngВыполнить MainViewModelTest».
Для будущих запусков вы можете выбрать эту тестовую конфигурацию в конфигурациях рядом с execute.pngкнопкой на панели инструментов. По умолчанию конфигурация будет называться MainViewModelTest .
Вы должны увидеть тестовый проход! И это должно занять чуть меньше одной секунды, чтобы бежать.

В следующем упражнении вы узнаете, как преобразовать существующие API-интерфейсы обратного вызова для использования сопрограмм.

7. Переход от обратных вызовов к сопрограммам  ******************************************************************

На этом этапе вы начнете преобразовывать репозиторий для использования сопрограмм. Для этого мы добавим сопрограмм к ViewModel, Repository, Roomи Retrofit.

Хорошая идея понять, за что отвечает каждая часть архитектуры, прежде чем переключать их на использование сопрограмм.

MainDatabaseреализует базу данных с помощью номера , который сохраняет и загружает Title.
MainNetworkреализует сетевой API, который выбирает новый заголовок. Он использует Retrofit для получения названий. Retrofitнастроен для случайного возврата ошибок или фиктивных данных, но в остальном ведет себя так, как будто он выполняет реальные сетевые запросы.
TitleRepository реализует единый API для извлечения или обновления заголовка путем объединения данных из сети и базы данных.
MainViewModelпредставляет состояние экрана и обрабатывает события. Он скажет хранилищу обновить заголовок, когда пользователь нажимает на экран.
Поскольку сетевой запрос управляется событиями пользовательского интерфейса, и мы хотим запустить сопрограмму на их основе, естественное место для начала использования сопрограмм - это ViewModel.

Версия обратного вызова
Откройте, MainViewModel.ktчтобы увидеть декларацию refreshTitle.

MainViewModel.kt
/**
* Update title text via this LiveData
*/
val title = repository.title


// ... other code ...


/**
* Refresh the title, showing a loading spinner while it refreshes and errors via snackbar.
*/
fun refreshTitle() {
   // TODO: Convert refreshTitle to use coroutines
   _spinner.value = true
   repository.refreshTitleWithCallbacks(object: TitleRefreshCallback {
       override fun onCompleted() {
           _spinner.postValue(false)
       }

       override fun onError(cause: Throwable) {
           _snackBar.postValue(cause.message)
           _spinner.postValue(false)
       }
   })
}
Эта функция вызывается каждый раз, когда пользователь нажимает на экран, и это заставит хранилище обновить заголовок и записать новый заголовок в базу данных.

Эта реализация использует обратный вызов, чтобы сделать несколько вещей:

Прежде чем начать запрос, он отображает загрузочный счетчик с _spinner.value = true
Когда он получает результат, он очищает загрузочный счетчик с _spinner.value = false
Если он получает ошибку, он показывает снэк-бар и очищает счетчик
Обратите внимание, что onCompletedобратный вызов не прошел title. Поскольку мы записываем все заголовки в Roomбазу данных, пользовательский интерфейс обновляет текущий заголовок, наблюдая за LiveDataобновлением Room.

В обновлении сопрограмм мы будем придерживаться точно такого же поведения. Это хороший шаблон для использования наблюдаемого источника данных, такого как Roomбаза данных, для автоматического обновления пользовательского интерфейса.

Что значит?object: TitleRefreshCallback

Это способ создать анонимный класс в Kotlin. Создает новый объект, который реализует TitleRefreshCallback.

Версия сопрограммы
Давайте перепишем refreshTitleс сопрограммами!

Так как он нам понадобится сразу, давайте сделаем пустую функцию приостановки в нашем репозитории ( TitleRespository.kt). Определите новую функцию, которая использует suspendоператор, чтобы сообщить Kotlin, что он работает с сопрограммами.

TitleRepository.kt
suspend fun refreshTitle() {
    // TODO: Refresh from network and write to database
    delay(500)
}
Когда вы закончите работу с этой кодовой меткой, вы обновите ее, чтобы использовать Retrofit и Room, чтобы получить новый заголовок и записать его в базу данных, используя сопрограммы. На данный момент он просто потратит 500 миллисекунд, делая вид, что выполняет работу, а затем продолжит.

В MainViewModel, замените версию обратного вызова на refreshTitleтот, который запускает новую сопрограмму:

MainViewModel.kt
/**
* Refresh the title, showing a loading spinner while it refreshes and errors via snackbar.
*/
fun refreshTitle() {
   viewModelScope.launch {
       try {
           _spinner.value = true
           repository.refreshTitle()
       } catch (error: TitleRefreshError) {
           _snackBar.value = error.message
       } finally {
           _spinner.value = false
       }
   }
}
Давайте пройдемся по этой функции:

viewModelScope.launch {
Точно так же, как сопрограмма для обновления счетчика, начните с запуска новой сопрограммы в viewModelScope. Это будет использовать, Dispatchers.Mainкоторый в порядке. Несмотря на то, что refreshTitleон сделает сетевой запрос и запрос к базе данных, он может использовать сопрограммы для предоставления главного безопасного интерфейса. Это означает, что будет безопасно вызывать его из основного потока.

Поскольку мы используем viewModelScope, когда пользователь отходит от этого экрана, работа, запущенная этой сопрограммой, будет автоматически отменена. Это означает, что он не будет делать дополнительные сетевые запросы или запросы к базе данных.

При создании сопрограммы из не-сопрограммы начните с запуска .

Таким образом, если они выдают неперехваченное исключение, оно будет автоматически передано неперехваченным обработчикам исключений (которые по умолчанию завершают работу приложения). Сопрограмма начали с asyncне сгенерирует исключение в вызывающем до вызова await. Тем не менее, вы можете вызывать только awaitиз сопрограммы, так как это функция приостановки.

Оказавшись внутри сопрограммы, вы можете использовать запуск или асинхронный запуск дочерних сопрограмм. Используйте, launchкогда у вас нет результата, чтобы вернуться, и asyncкогда у вас есть.

Следующие несколько строк кода на самом деле назвать refreshTitleв repository.

try {
    _spinner.value = true
    repository.refreshTitle()
}
Перед тем, как эта сопрограмма сделает что-либо, она запускает загрузчик - затем она вызывает refreshTitleкак обычная функция. Однако, поскольку refreshTitleфункция приостановки, она выполняется иначе, чем обычная функция.

Мы не должны передавать обратный вызов. Сопрограмма будет приостановлена, пока она не будет возобновлена refreshTitle. Несмотря на то, что он выглядит как обычный вызов функции блокировки, он будет автоматически ожидать завершения запроса сети и базы данных, прежде чем возобновить работу без блокировки основного потока.

} catch (error: TitleRefreshError) {
    _snackBar.value = error.message
} finally {
    _spinner.value = false
}
Исключения в функциях приостановки работают так же, как ошибки в обычных функциях. Если вы выбросите ошибку в функцию приостановки, она будет выдана вызывающей стороне. Поэтому, хотя они выполняются совершенно по-разному, вы можете использовать обычные блоки try / catch для их обработки. Это полезно, потому что позволяет вам полагаться на встроенную языковую поддержку для обработки ошибок вместо создания настраиваемой обработки ошибок для каждого обратного вызова.

И, если вы выбросите исключение из сопрограммы - эта сопрограмма по умолчанию отменит своего родителя. Это означает, что легко отменить несколько связанных задач вместе.

И затем, в блоке finally, мы можем убедиться, что счетчик всегда выключен после выполнения запроса.

Что происходит с неисследованными исключениями

Необработанные исключения в сопрограмме аналогичны неперехваченным исключениям в коде без сопрограмм. По умолчанию они отменяют сопрограммы Jobи уведомляют родительские сопрограммы, что они должны отменить себя. Если никакая сопрограмма не обработает исключение, оно в конечном итоге будет передано необработанному обработчику исключений в CoroutineScope.

По умолчанию неперехваченные исключения будут отправлены обработчику неперехваченных исключений потока в JVM. Вы можете настроить это поведение, предоставив CoroutineExceptionHandler .

Запустите приложение еще раз, выбрав начальную конфигурацию, а затем нажав execute.png, вы увидите загрузочный счетчик, когда вы нажимаете в любом месте. Название останется прежним, потому что мы еще не подключили нашу сеть или базу данных.

В следующем упражнении вы обновите хранилище, чтобы оно действительно выполняло свою работу.

8. Создание основных безопасных функций от блокировки кода ******************************************************

В этом упражнении вы узнаете, как переключать поток, в котором работает сопрограмма, для реализации рабочей версии TitleRepository.

Просмотрите существующий код обратного вызова в refreshTitle
Откройте TitleRepository.ktи просмотрите существующую реализацию на основе обратного вызова.

TitleRepository.kt
// TitleRepository.kt

fun refreshTitleWithCallbacks(titleRefreshCallback: TitleRefreshCallback) {
   // This request will be run on a background thread by retrofit
   BACKGROUND.submit {
       try {
           // Make network request using a blocking call
           val result = network.fetchNextTitle().execute()
           if (result.isSuccessful) {
               // Save it to database
               titleDao.insertTitle(Title(result.body()!!))
               // Inform the caller the refresh is completed
               titleRefreshCallback.onCompleted()
           } else {
               // If it's not successful, inform the callback of the error
               titleRefreshCallback.onError(
                       TitleRefreshError("Unable to refresh title", null))
           }
       } catch (cause: Throwable) {
           // If anything throws an exception, inform the caller
           titleRefreshCallback.onError(
                   TitleRefreshError("Unable to refresh title", cause))
       }
   }
}
В TitleRepository.ktметоде refreshTitleWithCallbacksреализован обратный вызов для передачи информации о загрузке и состоянии ошибки вызывающей стороне.

Эта функция делает несколько вещей, чтобы реализовать обновление.

Переключиться на другой поток с BACKGROUND ExecutorService
Запустите fetchNextTitleсетевой запрос, используя execute()метод блокировки . Это запустит сетевой запрос в текущем потоке, в этом случае один из потоков в BACKGROUND.
Если результат успешен, сохраните его в базе данных insertTitleи вызовите onCompleted()метод.
Если результат не был успешным или есть исключение, вызовите метод onError, чтобы сообщить вызывающей стороне о неудачном обновлении.
Эта реализация, основанная на обратном вызове, является главной безопасной, потому что она не будет блокировать основной поток. Но он должен использовать обратный вызов, чтобы сообщить звонящему о завершении работы. Он также вызывает обратные вызовы в BACKGROUNDпотоке, который он тоже переключил.

Звонки, блокирующие звонки от сопрограмм
Не вводя сопрограммы в сеть или базу данных, мы можем сделать этот код безопасным с помощью сопрограмм. Это позволит нам избавиться от обратного вызова и передать результат обратно в поток, который его первоначально вызвал.

Вы можете использовать этот шаблон в любое время, когда вам нужно выполнить блокировку или нагрузку на процессор изнутри сопрограммы, например, сортировку и фильтрацию большого списка или чтение с диска.

Этот шаблон следует использовать для интеграции с блокирующими API в вашем коде или выполнения работы, интенсивно использующей процессор. По возможности лучше использовать обычные функции приостановки из таких библиотек, как Room или Retrofit.

Для переключения между любым диспетчером используются сопрограммы withContext. Вызов withContextпереключается на другого диспетчера только для лямбды, а затем возвращается к диспетчеру, который вызвал его с результатом этой лямбды.

По умолчанию Котлин сопрограммы предоставляет три диспетчеры: Main, IO, и Default. Диспетчер ввода-вывода оптимизирован для такой работы ввода-вывода, как чтение из сети или с диска, а диспетчер по умолчанию оптимизирован для задач, интенсивно использующих процессор.

TitleRepository.kt
suspend fun refreshTitle() {
   // interact with *blocking* network and IO calls from a coroutine
   withContext(Dispatchers.IO) {
       val result = try {
           // Make network request using a blocking call
           network.fetchNextTitle().execute()
       } catch (cause: Throwable) {
           // If the network throws an exception, inform the caller
           throw TitleRefreshError("Unable to refresh title", cause)
       }

       if (result.isSuccessful) {
           // Save it to database
           titleDao.insertTitle(Title(result.body()!!))
       } else {
           // If it's not successful, inform the callback of the error
           throw TitleRefreshError("Unable to refresh title", null)
       }
   }
}
В этой реализации используются блокирующие вызовы для сети и базы данных, но она все же немного проще, чем версия для обратного вызова.

Этот код по-прежнему использует блокировку вызовов. Вызов execute()и insertTitle(...)оба заблокируют поток, в котором выполняется эта сопрограмма. Однако, переключаясь на Dispatchers.IOиспользование withContext, мы блокируем один из потоков в диспетчере ввода-вывода. Сопрограмма, которая вызвала это, возможно, работает Dispatchers.Main, будет приостановлена, пока withContextлямбда не будет завершена.

По сравнению с версией обратного вызова, есть два важных различия:

withContextв этом случае возвращает результат обратно Диспетчеру, который его вызвал Dispatchers.Main. Версия обратного вызова вызвала обратные вызовы в потоке в BACKGROUNDслужбе исполнителя.
Вызывающая сторона не должна передавать обратный вызов этой функции. Они могут рассчитывать на приостановку и возобновление, чтобы получить результат или ошибку.
Расширенный совет

Этот код не поддерживает отмену сопрограмм, но это возможно! Отмена сопрограмм является кооперативной . Это означает, что ваш код должен явно проверять отмену, что происходит при каждом вызове функций в kotlinx-сопрограммах.

Поскольку этот withContextблок вызывает только блокирующие вызовы, он не будет отменен, пока не вернется из withContext.

Чтобы это исправить, вы можете yieldрегулярно звонить, чтобы дать другим сопрограммам шанс на запуск и проверку на отмену. Здесь вы бы добавили вызов yieldмежду запросом сети и запросом базы данных. Затем, если сопрограмма отменяется во время сетевого запроса, результат не сохраняется в базе данных.

Вы также можете явно проверить отмену, что вы должны сделать при создании низкоуровневых сопрограммных интерфейсов.

Запустите приложение снова
Если вы снова запустите приложение, вы увидите, что новая реализация на основе сопрограмм загружает результаты из сети!

На следующем этапе вы интегрируете сопрограммы в Room и Retrofit.
**********************************************************************************************

9. Сопрограммы в комнате и модернизации
Чтобы продолжить интеграцию сопрограмм, мы будем использовать поддержку функций приостановки в стабильной версии Room и Retrofit, а затем существенно упростим код, который мы только что написали, с помощью функций приостановки.

Сопрограммы в номере
Сначала откройте MainDatabase.ktи сделайте insertTitleфункцию приостановки:

MainDatabase.kt
// add the suspend modifier to the existing insertTitle

@Insert(onConflict = OnConflictStrategy.REPLACE)
suspend fun insertTitle(title: Title)
Когда вы сделаете это, Room сделает ваш запрос главным образом безопасным и автоматически выполнит его в фоновом потоке. Однако это также означает, что вы можете вызывать этот запрос только из сопрограммы.

И - это все, что вам нужно сделать, чтобы использовать сопрограммы в комнате. Довольно изящный.

Сопрограммы в модификации
Далее давайте посмотрим, как интегрировать сопрограммы с Retrofit. Откройте MainNetwork.ktи перейдите fetchNextTitleк функции приостановки. Также измените тип возврата с Call<String>на String.

Для поддержки функции приостановки требуется Retrofit 2.6.0 или выше.

MainNetwork.kt
// add suspend modifier to the existing fetchNextTitle
// change return type from Call<String> to String

interface MainNetwork {
   @GET("next_title.json")
   suspend fun fetchNextTitle(): String
}
Чтобы использовать функции приостановки с Retrofit, вы должны сделать две вещи:

Добавьте модификатор приостановки к функции
Удалите Callоболочку из возвращаемого типа. Здесь мы возвращаемся String, но вы также можете вернуть сложный тип с поддержкой json. Если вы все еще хотите предоставить полный доступ к Retrofit Result, вы можете вернуться Result<String>вместо Stringфункции приостановки.
Retrofit автоматически сделает функции приостановки максимально безопасными, чтобы вы могли вызывать их напрямую Dispatchers.Main.

Как Room, так и Retrofit делают функции приостановки безопасными .

Безопасно вызывать эти функции приостановки Dispatchers.Main, даже если они извлекаются из сети и записываются в базу данных.

Как Room, так и Retrofit используют собственный диспетчер и не используют его Dispatchers.IO.

Room запустит сопрограммы, используя запрос и транзакцию по умолчанию, Executorкоторые настроены.

Retrofit создаст новый Callобъект под капотом и вызовет enqueue для него, чтобы отправить запрос асинхронно.

Использование комнаты и дооснащения
Теперь, когда Room и Retrofit поддерживают функции приостановки, мы можем использовать их из нашего репозитория. Откройте TitleRepository.ktи посмотрите, как использование функций приостановки значительно упрощает логику даже по сравнению с блокирующей версией:

Название репозитория.kt
suspend fun refreshTitle() {
   try {
       // Make network request using a blocking call
       val result = network.fetchNextTitle()
       titleDao.insertTitle(Title(result))
   } catch (cause: Throwable) {
       // If anything throws an exception, inform the caller
       throw TitleRefreshError("Unable to refresh title", cause)
   }
}
Вау, это намного короче. Что произошло? Оказывается, полагаясь на приостановку и возобновление, код становится намного короче. Модернизация позволяет нам использовать возвращаемые типы, такие как Stringили Userобъект, вместо Call. Это безопасно, потому что внутри функции suspend Retrofitможет выполнять сетевой запрос в фоновом потоке и возобновлять сопрограмму после завершения вызова.

Еще лучше, мы избавились от withContext. Поскольку как Room, так и Retrofit предоставляют основные безопасные функции приостановки, безопасно выполнять эту асинхронную работу Dispatchers.Main.

Вам не нужно использовать withContextдля вызова основных безопасных функций приостановки.

По соглашению, вы должны убедиться, что suspendфункции, написанные в вашем приложении, являются основными безопасными . Таким образом, можно позвонить им даже от любого диспетчера Dispatchers.Main.

Исправление ошибок компилятора
Переход к сопрограммам требует изменения сигнатуры функций, поскольку вы не можете вызвать функцию приостановки из обычной функции. Когда вы добавили suspendмодификатор на этом шаге, было сгенерировано несколько ошибок компилятора, которые показывают, что произойдет, если вы изменили функцию для приостановки в реальном проекте.

Пройдите проект и исправьте ошибки компилятора, изменив функцию приостановить созданную. Вот быстрые решения для каждого:

TestingFakes.kt
Обновите фальшивые тесты для поддержки новых модификаторов приостановки.

TitleDaoFake
Нажмите Alt-Enter (опция-Enter на Mac), чтобы добавить модификаторы приостановки для всех функций в иерархии
MainNetworkFake
Нажмите Alt-Enter, чтобы добавить модификаторы приостановки ко всем функциям в иерархии.
Заменить fetchNextTitleна эту функцию
override suspend fun fetchNextTitle() = result
MainNetworkCompletableFake
Нажмите Alt-Enter, чтобы добавить модификаторы приостановки ко всем функциям в иерархии.
Заменить fetchNextTitleна эту функцию
override suspend fun fetchNextTitle() = completable.await()
TitleRepository.kt
Удалите refreshTitleWithCallbacksфункцию, так как она больше не используется.
Запустите приложение
Запустите приложение снова, как только оно скомпилируется, вы увидите, что оно загружает данные с помощью сопрограмм на всем пути от ViewModel до Room и Retrofit!

Поздравляем, вы полностью переключили это приложение на использование сопрограмм! В заключение мы поговорим немного о том, как проверить, что мы только что сделали.
******************************************************************************************************************************

10. Тестирование сопрограмм напрямую
В этом упражнении вы напишете тест, который suspendнапрямую вызывает функцию.

Так refreshTitleкак выставляется как публичный API, он будет тестироваться напрямую, показывая, как вызывать функции сопрограмм из тестов.

Вот refreshTitleфункция, которую вы реализовали в последнем упражнении:

TitleRepository.kt
suspend fun refreshTitle() {
   try {
       // Make network request using a blocking call
       val result = network.fetchNextTitle()
       titleDao.insertTitle(Title(result))
   } catch (cause: Throwable) {
       // If anything throws an exception, inform the caller
       throw TitleRefreshError("Unable to refresh title", cause)
   }
}
Написать тест, который вызывает функцию приостановки
Откройте TitleRepositoryTest.ktв testпапке с двумя TODOS.

Попробуйте позвонить refreshTitleс первого теста whenRefreshTitleSuccess_insertsRows.

@Test
fun whenRefreshTitleSuccess_insertsRows() {
   val subject = TitleRepository(
       MainNetworkFake("OK"),
       TitleDaoFake("title")
   )

   subject.refreshTitle()
}
Поскольку refreshTitleэто suspendфункция, Kotlin не знает, как ее вызывать, кроме как из сопрограммы или другой функции приостановки, и вы получите ошибку компилятора, такую ​​как «Функция приостановки refreshTitle должна вызываться только из сопрограммы или другой функции приостановки».

Бегущий по тестам ничего не знает о сопрограммах, поэтому мы не можем сделать этот тест функцией приостановки. Мы могли launchбы сопрограмму, используя CoroutineScopelike в a ViewModel, однако тесты должны выполнить сопрограммы до завершения, прежде чем они вернутся. Как только тестовая функция возвращается, тест заканчивается. Сопрограммы, с launchкоторых начинается, представляют собой асинхронный код, который может завершиться в какой-то момент в будущем. Поэтому, чтобы протестировать этот асинхронный код, вам нужно каким-то образом указать тесту, чтобы он ожидал, пока ваша сопрограмма не завершится. Поскольку launchэто неблокирующий вызов, это означает, что он сразу возвращается и может продолжить выполнение сопрограммы после возврата из функции - его нельзя использовать в тестах. Например:

@Test
fun whenRefreshTitleSuccess_insertsRows() {
   val subject = TitleRepository(
       MainNetworkFake("OK"),
       TitleDaoFake("title")
   )

   // launch starts a coroutine then immediately returns
   GlobalScope.launch {
       // since this is asynchronous code, this may be called *after* the test completes
       subject.refreshTitle()
   }
   // test function returns immediately, and
   // doesn't see the results of refreshTitle
}
Этот тест иногда не удался. Вызов launchнемедленно вернется и выполнится в то же время, что и остальная часть тестового примера. Тест не может определить, был ли refreshTitleон запущен или нет, и любые утверждения, такие как проверка обновления базы данных, были бы ошибочными. И, если refreshTitleвыдается исключение, оно не будет выброшено в стек тестовых вызовов. Вместо этого он будет добавлен в GlobalScopeнеобработанный обработчик исключений.

В библиотеке kotlinx-coroutines-testесть runBlockingTestфункция, которая блокирует при вызове функции приостановки. Когда runBlockingTestвызывается функция приостановки или launchesновая сопрограмма, она выполняет ее немедленно по умолчанию. Вы можете думать об этом как о способе преобразования приостановленных функций и сопрограмм в обычные вызовы функций.

Кроме того, runBlockingTestвыкинут непонятные для вас исключения. Это облегчает проверку, когда сопрограмма выдает исключение.

Важное замечание : Функция runBlockingTestвсегда будет блокировать вызывающего, как при обычном вызове функции. Сопрограмма будет работать синхронно в том же потоке. Вы должны избегать runBlockingи runBlockingTestв своем коде приложения и предпочесть тот, launchкоторый возвращается немедленно.

runBlockingTestследует использовать только из тестов, так как он выполняет сопрограммы управляемым тестом способом, в то время как runBlockingможет использоваться для обеспечения интерфейсов блокировки сопрограмм.

Выполнить тест с одной сопрограммой
Заверните вызов refreshTitleс runBlockingTestи удалить GlobalScope.launchоболочку из subject.refreshTitle ().

TitleRepositoryTest.kt
@Test
fun whenRefreshTitleSuccess_insertsRows() = runBlockingTest {
   val titleDao = TitleDaoFake("title")
   val subject = TitleRepository(
           MainNetworkFake("OK"),
           titleDao
   )

   subject.refreshTitle()
   Truth.assertThat(titleDao.nextInsertedOrNull()).isEqualTo("OK")
}
Этот тест использует фальшивки, предоставленные для проверки того, что "OK" вставлено в базу данных refreshTitle.

Когда тест вызывает runBlockingTest, он блокируется до завершения сопрограммы, запущенной runBlockingTest. Затем внутри, когда мы refreshTitleего вызываем, он использует обычный механизм приостановки и возобновления, чтобы дождаться добавления строки базы данных в нашу фальшивку.

После завершения теста сопрограмма runBlockingTestвозвращается.

Написать тест тайм-аута
Мы хотим добавить короткий таймаут в сетевой запрос. Давайте сначала напишем тест, а затем реализуем тайм-аут. Создать новый тест:

TitleRepositoryTest.kt
@Test(expected = TitleRefreshError::class)
fun whenRefreshTitleTimeout_throws() = runBlockingTest {
   val network = MainNetworkCompletableFake()
   val subject = TitleRepository(
           network,
           TitleDaoFake("title")
   )

   launch {
       subject.refreshTitle()
   }

   advanceTimeBy(5_000)
}
В этом тесте используется предоставленная подделка MainNetworkCompletableFake, которая является сетевым подделкой, предназначенной для приостановки звонящих, пока тест не продолжит их. Когда refreshTitleпытается сделать сетевой запрос, он будет зависать вечно, потому что мы хотим проверить тайм-ауты.

Затем он запускает отдельную сопрограмму для вызова refreshTitle. Это ключевая часть тестирования тайм-аутов, тайм-аут должен происходить в другом сопрограмме, чем тот, который runBlockingTestсоздается. Сделав это, мы можем вызвать следующую строку, advanceTimeBy(5_000)которая увеличит время на 5 секунд и приведет к превышению времени ожидания для другой сопрограммы.

Это полный тест тайм-аута, и он пройдет, как только мы введем тайм-аут.

Запустите его сейчас и посмотрите, что произойдет:

Вызвано: kotlinx.coroutines.test.UncompletedCoroutinesError: Тест завершен с активными заданиями: ["...]
Одна из особенностей runBlockingTestзаключается в том, что он не даст вам утечки сопрограмм после завершения теста. Если в конце теста появятся незавершенные сопрограммы, такие как наша сопрограмма запуска, тест не пройден.

Добавить тайм-аут
Откройте TitleRepositoryи добавьте пятисекундный таймаут к сетевому извлечению. Вы можете сделать это с помощью withTimeoutфункции:

TitleRepository.kt
suspend fun refreshTitle() {
   try {
       // Make network request using a blocking call
       val result = withTimeout(5_000) {
           network.fetchNextTitle()
       }
       titleDao.insertTitle(Title(result))
   } catch (cause: Throwable) {
       // If anything throws an exception, inform the caller
       throw TitleRefreshError("Unable to refresh title", cause)
   }
}
Запустите тест. При запуске тестов вы должны увидеть, что все тесты пройдены!



В следующем упражнении вы узнаете, как писать функции более высокого порядка, используя сопрограммы.

runBlockingTestполагается на TestCoroutineDispatcherконтроль сопрограмм.

В результате, это хорошая идея, чтобы ввести TestCoroutineDispatcherили TestCoroutineScopeпри использовании runBlockingTest. Это делает сопрограммы однопоточными и дает возможность явно контролировать все сопрограммы в тестах.

Если вы не хотите изменять поведение сопрограмм - например, в интеграционном тесте - вы можете вместо этого использовать runBlockingс реализациями по умолчанию всех диспетчеров.

runBlockingTestявляется экспериментальным и в настоящее время имеет ошибку , из-за которой он не проходит тест, если сопрограмма переключается на диспетчер, который выполняет сопрограмму в другом потоке. В финальной стабильной версии не ожидается этой ошибки.
*******************************************************************************************************
11. Использование сопрограмм в функциях высшего порядка
В этом упражнении вы реорганизовать refreshTitleв MainViewModelиспользовать общую функцию загрузки данных. Это научит вас, как создавать функции более высокого порядка, которые используют сопрограммы.

Текущая реализация refreshTitleработает, но мы можем создать общую подпрограмму загрузки данных, которая всегда показывает счетчик. Это может быть полезно в кодовой базе, которая загружает данные в ответ на несколько событий и хочет обеспечить постоянное отображение счетчика загрузки.

Просмотр текущей реализации в каждой строке, за исключением repository.refreshTitle()примера, показывает счетчик и отображает ошибки.

// MainViewModel.kt

fun refreshTitle() {
   viewModelScope.launch {
       try {
           _spinner.value = true
           // this is the only part that changes between sources
           repository.refreshTitle()
       } catch (error: TitleRefreshError) {
           _snackBar.value = error.message
       } finally {
           _spinner.value = false
       }
   }
}
Важное замечание: Несмотря на то, что мы используем только viewModelScope в этой кодовой метке, как правило, хорошо добавлять область видимости везде, где это имеет смысл. Не забудьте отменить его, если он больше не нужен.

Например, вы можете объявить его в адаптере RecyclerView для выполнения операций DiffUtil.

Использование сопрограмм в функциях высшего порядка
Добавьте этот код в MainViewModel.kt

MainViewModel.kt
private fun launchDataLoad(block: suspend () -> Unit): Job {
   return viewModelScope.launch {
       try {
           _spinner.value = true
           block()
       } catch (error: TitleRefreshError) {
           _snackBar.value = error.message
       } finally {
           _spinner.value = false
       }
   }
}
Теперь рефакторинг, refreshTitle()чтобы использовать эту функцию более высокого порядка.

MainViewModel.kt
fun refreshTitle() {
   launchDataLoad {
       repository.refreshTitle()
   }
}
Абстрагируя логику показа загрузочного счетчика и ошибок, мы упростили наш фактический код, необходимый для загрузки данных. Отображение счетчика или отображение ошибки - это то, что легко обобщить для любой загрузки данных, в то время как фактический источник данных и место назначения необходимо указывать каждый раз.

Чтобы построить эту абстракцию, launchDataLoadтребуется аргумент, blockкоторый является лямбда-приостановкой. Приостановить лямбду позволяет вызывать функции приостановки. Вот как Kotlin внедряет компиляторы сопрограмм, launchи runBlockingмы использовали его в этом коде.

// suspend lambda

block: suspend () -> Unit
Чтобы приостановить лямбду, начните с suspendключевого слова. Стрелка функции и возвращаемый тип Unitзавершают объявление.

Вам не часто приходится объявлять свои собственные приостановленные лямбды, но они могут быть полезны для создания таких абстракций, которые инкапсулируют повторяющуюся логику!
********************************************************************************

12. Использование сопрограмм с WorkManager
В этом упражнении вы узнаете, как использовать код на основе сопрограмм из WorkManager.

Что такое WorkManager

Есть много вариантов на Android для отложенной фоновой работы. В этом упражнении показано, как интегрировать WorkManager с сопрограммами. WorkManager - это совместимая, гибкая и простая библиотека для отложенной фоновой работы. WorkManager является рекомендуемым решением для этих случаев использования на Android.

WorkManager является частью Android Jetpack и компонентом архитектуры для фоновой работы, который требует сочетания условного и гарантированного выполнения. Оппортунистическое выполнение означает, что WorkManager выполнит вашу фоновую работу, как только сможет. Гарантированное выполнение означает, что WorkManager позаботится о логике, чтобы начать работу в различных ситуациях, даже если вы уходите из приложения.

По этой причине WorkManager является хорошим выбором для задач, которые в конечном итоге должны быть выполнены.

Некоторые примеры задач, которые хорошо используют WorkManager:

Загрузка логов
Применение фильтров к изображениям и сохранение изображения
Периодическая синхронизация локальных данных с сетью
Чтобы узнать больше о WorkManager, ознакомьтесь с документацией .

Использование сопрограмм с WorkManager
WorkManager предоставляет разные реализации своего базового ListenableWorkerкласса для разных вариантов использования.

Простейший класс Worker позволяет нам выполнять некоторые синхронные операции, выполняемые WorkManager. Однако, проделав до настоящего времени преобразование нашей кодовой базы для использования сопрограмм и функций приостановки, лучший способ использовать WorkManager - через CoroutineWorkerкласс, который позволяет определить нашу doWork()функцию как функцию приостановки.

Чтобы начать, откройте RefreshMainDataWork. Это уже распространяется CoroutineWorker, и вам нужно реализовать doWork.

Внутри suspend doWorkфункции вызовите refreshTitle()из репозитория и верните соответствующий результат!

После того, как вы завершили TODO, код будет выглядеть так:

override suspend fun doWork(): Result {
   val database = getDatabase(applicationContext)
   val repository = TitleRepository(network, database.titleDao)

   return try {
       repository.refreshTitle()
       Result.success()
   } catch (error: TitleRefreshError) {
       Result.failure()
   }
}
Обратите внимание, что CoroutineWorker.doWork()это приостановка функции. В отличие от более простого Workerкласса, этот код НЕ выполняется на Executor, указанном в вашей конфигурации WorkManager, но вместо этого использует диспетчер в coroutineContext member (по умолчанию Dispatchers.Default).

Тестирование нашего CoroutineWorker
Ни одна кодовая база не должна быть полной без тестирования.

WorkManager предоставляет несколько различных способов тестирования ваших Workerклассов, чтобы узнать больше об исходной инфраструктуре тестирования, вы можете прочитать документацию .

WorkManager v2.1 представляет новый набор API для поддержки более простого способа тестирования ListenableWorkerклассов и, как следствие, CoroutineWorker. В нашем коде мы будем использовать один из этих новых API: TestListenableWorkerBuilder.

Чтобы добавить наш новый тест, обновите RefreshMainDataWorkTestфайл в androidTestпапке.

Содержание файла:

package com.example.android.kotlincoroutines.main

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import androidx.work.ListenableWorker.Result
import android.content.Context
import androidx.test.core.app.ApplicationProvider
import androidx.work.ListenableWorker.Result
import androidx.work.testing.TestListenableWorkerBuilder
import com.example.android.kotlincoroutines.fakes.MainNetworkFake
import com.google.common.truth.Truth.assertThat
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.JUnit4


@RunWith(JUnit4::class)
class RefreshMainDataWorkTest {

@Test
fun testRefreshMainDataWork() {
   val fakeNetwork = MainNetworkFake("OK")

   val context = ApplicationProvider.getApplicationContext<Context>()
   val worker = TestListenableWorkerBuilder<RefreshMainDataWork>(context)
           .setWorkerFactory(RefreshMainDataWork.Factory(fakeNetwork))
           .build()

   // Start the work synchronously
   val result = worker.startWork().get()

   assertThat(result).isEqualTo(Result.success())
}

}
Прежде чем мы перейдем к тесту, мы расскажем WorkManagerо фабрике, чтобы мы могли внедрить поддельную сеть.

Сам тест использует TestListenableWorkerBuilderдля создания нашего работника, который мы затем можем запустить, вызывая startWork()метод.

WorkManager - это только один пример того, как сопрограммы могут быть использованы для упрощения проектирования API.
*******************************************************************************************
13. Поздравляем!
В этом коде мы рассмотрели основы, которые вам понадобятся, чтобы начать использовать сопрограммы в вашем приложении!

Мы покрыли:

Как интегрировать сопрограммы в приложения Android из заданий UI и WorkManager для упрощения асинхронного программирования,
Как использовать сопрограммы внутри ViewModelдля извлечения данных из сети и сохранения их в базе данных без блокировки основного потока.
И как отменить все сопрограммы, когда ViewModelзакончено.
Для тестирования кода на основе сопрограмм мы рассмотрели как тестирование поведения, так и прямой вызов suspendфункций из тестов.

Выучить больше
Посмотрите кодовую метку « Расширенные сопрограммы с Kotlin Flow и LiveData », чтобы узнать больше об использовании сопрограмм на Android.

Чтобы узнать больше об отмене и исключениях в сопрограммах, ознакомьтесь с этой серией статей: Часть 1. Сопрограммы , Часть 2. Отмена в сопрограммах и Часть 3: Исключения в сопрограммах .

Сопрограммы Kotlin имеют много функций, которые не были включены в эту кодовую метку. Если вы хотите узнать больше о сопрограммах Kotlin, прочитайте руководства по сопрограммам, опубликованные JetBrains. Также ознакомьтесь с разделом « Повышение производительности приложений с сопрограммами Kotlin », чтобы узнать больше примеров использования сопрограмм на Android.

https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#12





