# Android Lifecycle-aware Components Codelab

Please follow along the codelab steps [here](https://codelabs.developers.google.com/codelabs/android-lifecycles/).

# Filing issues

If you find errors in the codelab steps or the code, please file them [here](https://github.com/googlecodelabs/android-lifecycles/issues/new)

Устаревший пример на JAVA
ViewModel - предоставляет способ создавать и извлекать объекты, связанные с определенным жизненным циклом.
 A ViewModelобычно хранит состояние данных представления и связывается с другими компонентами,
 такими как хранилища данных или уровень домена, который обрабатывает бизнес-логику.
    Чтобы прочитать вводное руководство по этой теме, см. ViewModel .
LifecycleOwner - LifecycleOwnerэто интерфейс , реализуемый AppCompatActivityи Fragmentклассы.
 Вы можете подписать другие компоненты на объекты владельца, которые реализуют этот интерфейс,
  чтобы наблюдать изменения в жизненном цикле владельца.
    Чтобы прочитать вводное руководство по этой теме, см. Обработка жизненных циклов .
LiveData - позволяет наблюдать за изменениями данных в нескольких компонентах вашего приложения,
 не создавая четких, жестких путей зависимости между ними.
  LiveDataучитывает сложные жизненные циклы компонентов вашего приложения, включая действия,
   фрагменты, сервисы или любые другие, LifecycleOwnerопределенные в вашем приложении.
    LiveDataуправляет подписками наблюдателей путем
     приостановки подписок на остановленные LifecycleOwnerобъекты и
      отмены подписок на LifecycleOwnerзавершенные объекты.
    Чтобы прочитать вводное руководство по этой теме, см. LiveData .

Внимание! Хранение ссылки на Context или View в ViewModelможет привести к утечкам памяти.
Избегайте полей, которые ссылаются на экземпляры классов Context или View.
Метод onCleared () полезен для отмены подписки или удаления ссылок на другие объекты
с более длинным жизненным циклом, но не для очистки ссылок Context или Viewобъектов.

Примечание. Чтобы представить данные как наблюдаемые, оберните тип в LiveDataклассе.

Примечание:LiveData объекты отправляют обновления только тогда, когда активность LifecycleOwner активна.
 Если вы переходите к другому приложению, сообщения журнала приостанавливаются, пока вы не вернетесь.
  LiveDataобъекты рассматривать только подписки как активные,
   когда их соответствующий владелец жизненного цикла либо НАЧАТЬ или ВОЗОБНОВЛЕННЫЙ .

Примечание . Наблюдатель переводится в текущее состояние провайдера,
 поэтому нет необходимости вызывать addLocationListener()конструктор.
  Он вызывается для вас, когда наблюдатель добавляется к владельцу жизненного цикла.

Используйте эмулятор Android для симуляции изменения местоположения устройства
(щелкните три точки, чтобы отобразить расширенные элементы управления).
TextViewОбновляется , когда она меняется:

6. Шаг 5. Совместное использование ViewModel между фрагментами.
Примечание. Вы должны использовать это действие в качестве владельца жизненного цикла,
 поскольку жизненный цикл каждого фрагмента независим.

7. Шаг 6 - Сохранение состояния ViewModel в процессе восстановления (бета)
Из Обзора управления памятью : когда пользователи переключаются между приложениями,
Android сохраняет приложения, которые не являются передними,
то есть невидимыми для пользователя, или не запускает такие службы переднего плана,
как воспроизведение музыки, в кеше (LRU), который использовался не так давно.
Например, когда пользователь впервые запускает приложение, для него создается процесс;
но когда пользователь покидает приложение, этот процесс не завершается.
Система сохраняет процесс в кэше. Если пользователь позже возвращается в приложение,
система повторно использует процесс, тем самым ускоряя переключение приложения.

lifecycle-viewmodel-savedstateМодуль обеспечивает доступ к сохраненному состоянию на ViewModels.

Зависимость gradle для этого модуля
"androidx.lifecycle:lifecycle-viewmodel-savedstate:$savedStateVersion"
Если у вас есть зависимость, если вы используете фрагмент или действие по умолчанию,
у вас будет доступ к SavedStateHandle в вашей модели представления.
A SavedStateHandle- это отображение ключ-значение, которое переживает смерть процесса.
adb shell am kill com.example.android.codelabs.lifecycle

Некоторые элементы пользовательского интерфейса, в том числе EditText,
сохраняют свое состояние, используя собственную onSaveInstanceStateреализацию.
Это состояние восстанавливается после того, как процесс завершается так же,
как восстанавливается после изменения конфигурации.
Прочтите ViewModels: Persistence, onSaveInstanceState (),
Восстановление состояния пользовательского интерфейса и загрузчиков
для получения дополнительной информации.