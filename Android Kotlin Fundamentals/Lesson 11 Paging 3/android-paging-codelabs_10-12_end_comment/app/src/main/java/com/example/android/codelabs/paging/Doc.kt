package com.example.android.codelabs.paging

/*
Эта лаборатория кода знакомит вас с библиотекой подкачки страниц и ее основными компонентами:

- PagingData- контейнер для данных с разбивкой на страницы.
  Каждому обновлению данных будет соответствовать отдельный PagingData.

- PagingSource- a PagingSource- это базовый класс для загрузки снимков данных в поток PagingData.

- Pager.flow - строит на Flow<PagingData> основе a PagingConfig и функцию,
  которая определяет, как построить реализованный PagingSource.

- PagingDataAdapter - a RecyclerView.Adapter, представленный PagingData в a RecyclerView.
  PagingDataAdapterМожет быть подключен к Котлин Flow, А LiveData, в RxJava Flowable, или RxJava Observable.
  Он PagingDataAdapter прослушивает внутренние PagingData события загрузки по мере загрузки страниц
   и использует их DiffUtil в фоновом потоке для вычисления детализированных обновлений
    по мере получения обновленного содержимого в форме новых PagingData объектов.

- RemoteMediator - помогает реализовать пагинацию из сети и базы данных.

 */

/*
- Отслеживает ключи, которые будут использоваться для перехода к следующей и предыдущей странице.
- Автоматически запрашивает правильную страницу, когда пользователь прокручивает список до конца.
- Гарантирует, что несколько запросов не будут запущены одновременно.
- Позволяет кэшировать данные: если вы используете Kotlin, это делается в файле CoroutineScope;
  если вы используете Java, это можно сделать с помощью LiveData.
- Отслеживает состояние загрузки и позволяет отображать его в RecyclerView элементе списка
  или в другом месте пользовательского интерфейса, а также легко повторять неудачные загрузки.
- Позволяет выполнять общие операции, такие как map или filter в списке, который будет отображаться,
  независимо от того, используете ли вы Flow, LiveData или RxJava Flowable или Observable.
- Предоставляет простой способ реализации разделителей списков.
 */

/*
Руководство по архитектуре приложений предлагает архитектуру со следующими основными компонентами:

- Локальная база данных, которая служит единым источником достоверных данных для данных, представленных пользователю и управляемых пользователем.
- Служба веб-API.
- Репозиторий, который работает с базой данных и службой веб-API, обеспечивая единый интерфейс данных.
- Который ViewModel предоставляет данные, относящиеся к пользовательскому интерфейсу.
- Пользовательский интерфейс, который показывает визуальное представление данных в ViewModel.
 */

/*
5. Определите источник данных.
Итак, в data пакете создадим PagingSource реализацию под названием GithubPagingSource:

6. Создайте и настройте PagingData.
В нашей текущей реализации мы используем Flow<RepoSearchResult>в классе,
 GitHubRepository чтобы получить данные из сети и передать их в ViewModel.
  ViewModelЗатем преобразует его в LiveData и подвергает его к UI.
   Когда мы дойдем до конца отображаемого списка и из сети Flow<RepoSearchResult>будет загружено больше данных ,
    в дополнение к последним данным будет содержаться весь список ранее полученных данных для этого запроса.

RepoSearchResult инкапсулирует как случаи успеха, так и ошибки.
 В случае успеха хранятся данные репозитория. Случай ошибки содержит Exceptionпричину.

С Paging 3.0 нам больше не нужно RepoSearchResult,
 так как библиотека моделирует как успешные, так и ошибочные случаи с помощью LoadResult.
  Не стесняйтесь удалять, так RepoSearchResult как в следующих нескольких шагах мы заменим его.

Чтобы создать PagingData, нам сначала нужно решить,
 какой API мы хотим использовать для передачи PagingData другим уровням нашего приложения:

Котлин Flow- пользуйся Pager.flow.
LiveData- использовать Pager.liveData.
RxJava Flowable- используйте Pager.flowable.
RxJava Observable- используйте Pager.observable.
Поскольку мы уже используем Flow в нашем приложении, мы продолжим этот подход;
 но вместо использования Flow<RepoSearchResult> мы будем использовать Flow<PagingData<Repo>>.

 Теперь у вас должны быть ошибки компиляции в SearchRepositoriesViewModel.
  Посмотрим, какие изменения нужно там внести!

  7. Запросить и кэшировать PagingData в ViewModel.
Примечание. Если вы выполняете какие-либо операции с Flow, например, map или filter,
 обязательно вызывайте cachedIn после выполнения этих операций,
  чтобы убедиться, что вам не нужно запускать их снова.

  Теперь посмотрим, какие изменения мы внесли SearchRepositoriesViewModel:

Добавлены новые элементы запроса Stringи результатов поиска Flow.
Обновлен searchRepo()метод с использованием ранее описанных функций.
Удалены queryLiveData и, repoResult поскольку их назначение покрывается Paging 3.0 и Flow.
Удален, listScrolled()поскольку библиотека подкачки справится с этим за нас.
Удален, companion object потому что VISIBLE_THRESHOLD больше не нужен.
Удалено repoLoadStatus, поскольку в Paging 3.0 также есть механизм для отслеживания статуса загрузки,
 как мы увидим на следующем шаге.

 8. Заставьте адаптер работать с PagingData.
 Чтобы привязать a PagingData к a RecyclerView, используйте a PagingDataAdapter.
  Он PagingDataAdapter получает уведомление всякий раз, когда PagingData контент загружается,
   а затем сигнализирует об RecyclerView обновлении.

До сих пор мы внесли много изменений, но теперь мы всего в одном шаге от возможности запускать приложение
 - нам просто нужно подключить пользовательский интерфейс!

 9. Запуск обновлений сети.
 Давайте обновимся SearchRepositoriesActivity для работы с Paging 3.0.
 Чтобы иметь возможность работать Flow<PagingData>, нам нужно запустить новую сопрограмму.
 Мы сделаем это в lifecycleScope, который отвечает за отмену запроса при воссоздании действия.

 Наше приложение должно скомпилироваться и запуститься,
 но без нижнего колонтитула состояния загрузки и того, Toast что отображается при ошибке.
  На следующем шаге мы увидим, как отобразить нижний колонтитул состояния загрузки.

10. Отображение состояния загрузки в нижнем колонтитуле

В нашем приложении мы хотим иметь возможность отображать нижний колонтитул в зависимости от статуса загрузки:
 когда список загружается, мы хотим отображать индикатор выполнения.
  В случае ошибки мы хотим показать ошибку и кнопку повтора.
  Верхний / нижний колонтитул, который нам нужно создать, следует идее списка,
   который необходимо добавить либо в начало (как заголовок),
    либо в конец (как нижний колонтитул) фактического списка элементов, которые мы отображаем.
     Верхний / нижний колонтитул - это список, состоящий только из одного элемента:
      представления, в котором отображается индикатор выполнения или сообщение об ошибке
       с кнопкой повтора на основе разбивки на страницы LoadState.

Поскольку отображение верхнего / нижнего колонтитула на основе состояния загрузки
 и реализация механизма повторных попыток являются общими задачами, API Paging 3.0 помогает нам в обоих из них.

 Для реализации верхнего / нижнего колонтитула мы будем использовать файл LoadStateAdapter. Эта реализация RecyclerView.Adapterавтоматически уведомляется об изменениях в состоянии загрузки. Он уверено , что только Loadingи Errorсостояния приводят к отображаемым элементам и оповещает , RecyclerViewкогда элемент удаляется, вставленные или изменены, в зависимости от LoadState.

В качестве механизма повтора мы используем adapter.retry(). Под капотом этот метод вызывает вашу PagingSourceреализацию для нужной страницы. Ответ будет автоматически передан через Flow<PagingData>.

Давайте посмотрим, как выглядит наша реализация верхнего / нижнего колонтитула!

Как и в любом списке, у нас есть 3 файла для создания:

Файл макета, содержащий элементы пользовательского интерфейса для отображения хода выполнения, ошибки и кнопки повтора.
Файл делает элементы пользовательского интерфейса , видимые на основе пейджингаViewHolder LoadState
Файл адаптера, определяющий, как создавать и связывать ViewHolder. Вместо того, чтобы расширять RecyclerView.Adapter, мы будем расширять LoadStateAdapterPaging 3.0.

Создать макет вида repos_load_state_footer_view_item
Создать ViewHolder
Создать LoadStateAdapter
Свяжите адаптер нижнего колонтитула со списком
  Обновите SearchRepositoriesActivity.initAdapter()метод и вызовите withLoadStateHeaderAndFooter()адаптер.
   В качестве функции повтора мы можем вызвать adapter.retry().

  11. Отображение состояния загрузки в Activity

  Вы могли заметить, что всякий раз, когда вы ищете новый запрос,
   текущий результат остается на экране до тех пор, пока мы не получим сетевой ответ.
    Это плохой пользовательский опыт!
     Вместо этого мы должны отобразить индикатор выполнения или кнопку повтора.

     Давайте обновим наш, activity_search_repositories.xml
     чтобы включить эти элементы пользовательского интерфейса вместо emptyList TextView:

     Наша кнопка повтора должна вызвать перезагрузку файла PagingData.
      Чтобы сделать это, мы называем adapter.retry()в onClickListener реализации,
       как мы это делали для верхнего / нижнего колонтитула:

      Чтобы исправить нашу функциональность, нам нужно реагировать на изменения состояния загрузки в нашем SearchRepositoriesActivity.
       Для этого воспользуемся PagingDataAdapter.addLoadStateListener()методом.
        Этот обратный вызов уведомляет нас каждый раз,
         когда происходит изменение состояния загрузки через CombinedLoadStates объект.

         Убедитесь, что вы удалили showEmptyList()метод, поскольку он нам больше не нужен.

         12. Добавление разделителей списков
       Один из способов улучшить читаемость вашего списка - это добавить разделители.
        Например, в нашем приложении, поскольку репозитории упорядочены по количеству звезд по убыванию,
         мы могли бы использовать разделители через каждые 10 тысяч звезд.
          Чтобы помочь реализовать это, API Paging 3.0 позволяет вставлять разделители в PagingData.

          Добавление разделителей PagingDataприведет к изменению списка, который мы отображаем на нашем экране. Мы больше не отображаем только Repoобъекты, но и объекты-разделители. Следовательно, мы должны изменить модель пользовательского интерфейса, которую мы представляем, с ViewModelfrom Repoна другой тип, который может инкапсулировать оба типа: RepoItemи SeparatorItem. Затем нам нужно будет обновить наш пользовательский интерфейс для поддержки разделителей:

Добавьте макет и ViewHolderдля разделителей.
Обновление RepoAdapterдля поддержки создания и привязки как разделителей, так и репозиториев.
Давайте рассмотрим это шаг за шагом и посмотрим, как выглядит реализация.

Изменить модель пользовательского интерфейса
В настоящее время SearchRepositoriesViewModel.searchRepo()возвращается Flow<PagingData<Repo>>.
 Чтобы поддерживать как репозитории, так и разделители,
  мы создадим UiModelзапечатанный класс в том же файле с расширением SearchRepositoriesViewModel.
   У нас может быть 2 типа UiModelобъектов: RepoItemи SeparatorItem.
Поскольку мы хотим разделить репозитории на основе 10 тыс. Звезд, давайте создадим свойство расширения,
 RepoItemкоторое округляет количество звезд для нас:

 Вставить разделители
Теперь мы можем вставить разделители! Для каждого выброса Flowмы будем звонить PagingData.insertSeparators().
 Этот метод возвращает, PagingData содержащий каждый исходный элемент, с необязательным разделителем,
  который вы создадите, учитывая элементы до и после.
   В граничных условиях (в начале или конце списка) будут соответствующие элементы до или после null.
    Если разделитель создавать не нужно, вернитесь null.

    Поддержка нескольких типов просмотра

    Обновите ReposAdapterдля поддержки UiModelвместо Repo:

Обновите PagingDataAdapterпараметр с Repoна UiModel.
Реализуйте UiModelкомпаратор и замените REPO_COMPARATORим.
Создайте свой SeparatorViewHolderи свяжите его с описанием UiModel.SeparatorItem.
Это оно! При запуске приложения вы должны увидеть разделители!
Вы можете найти полный код выполненных шагов в ветке step12_separators .

 */